// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ComponentStatusStatus.
const (
	ComponentStatusStatusError ComponentStatusStatus = "error"
	ComponentStatusStatusOk    ComponentStatusStatus = "ok"
)

// Defines values for CurrentServiceInfoStatus.
const (
	CurrentServiceInfoStatusOk          CurrentServiceInfoStatus = "ok"
	CurrentServiceInfoStatusUnavailable CurrentServiceInfoStatus = "unavailable"
)

// Defines values for DvrCapabilitiesSeriesMode.
const (
	DvrCapabilitiesSeriesModeDelegated DvrCapabilitiesSeriesMode = "delegated"
	DvrCapabilitiesSeriesModeManaged   DvrCapabilitiesSeriesMode = "managed"
	DvrCapabilitiesSeriesModeNone      DvrCapabilitiesSeriesMode = "none"
)

// Defines values for EPGConfigSource.
const (
	EPGConfigSourceBouquet    EPGConfigSource = "bouquet"
	EPGConfigSourcePerService EPGConfigSource = "per-service"
)

// Defines values for EPGStatusStatus.
const (
	EPGStatusStatusMissing EPGStatusStatus = "missing"
	EPGStatusStatusOk      EPGStatusStatus = "ok"
)

// Defines values for IntentRequestHwaccel.
const (
	Auto  IntentRequestHwaccel = "auto"
	Force IntentRequestHwaccel = "force"
	Off   IntentRequestHwaccel = "off"
)

// Defines values for IntentRequestType.
const (
	StreamStart IntentRequestType = "stream.start"
	StreamStop  IntentRequestType = "stream.stop"
)

// Defines values for PlaybackDecisionMode.
const (
	PlaybackDecisionModeDeny         PlaybackDecisionMode = "deny"
	PlaybackDecisionModeDirectPlay   PlaybackDecisionMode = "direct_play"
	PlaybackDecisionModeDirectStream PlaybackDecisionMode = "direct_stream"
	PlaybackDecisionModeTranscode    PlaybackDecisionMode = "transcode"
)

// Defines values for PlaybackDecisionSelectedOutputKind.
const (
	PlaybackDecisionSelectedOutputKindFile PlaybackDecisionSelectedOutputKind = "file"
	PlaybackDecisionSelectedOutputKindHls  PlaybackDecisionSelectedOutputKind = "hls"
)

// Defines values for PlaybackFeedbackRequestEvent.
const (
	PlaybackFeedbackRequestEventError   PlaybackFeedbackRequestEvent = "error"
	PlaybackFeedbackRequestEventInfo    PlaybackFeedbackRequestEvent = "info"
	PlaybackFeedbackRequestEventWarning PlaybackFeedbackRequestEvent = "warning"
)

// Defines values for PlaybackInfoDurationSource.
const (
	Cache PlaybackInfoDurationSource = "cache"
	Probe PlaybackInfoDurationSource = "probe"
	Store PlaybackInfoDurationSource = "store"
)

// Defines values for PlaybackInfoMode.
const (
	PlaybackInfoModeDeny      PlaybackInfoMode = "deny"
	PlaybackInfoModeDirectMp4 PlaybackInfoMode = "direct_mp4"
	PlaybackInfoModeHls       PlaybackInfoMode = "hls"
)

// Defines values for PlaybackInfoReason.
const (
	PlaybackInfoReasonContainerMismatch PlaybackInfoReason = "container_mismatch"
	PlaybackInfoReasonDirectplayMatch   PlaybackInfoReason = "directplay_match"
	PlaybackInfoReasonTranscodeAll      PlaybackInfoReason = "transcode_all"
	PlaybackInfoReasonTranscodeAudio    PlaybackInfoReason = "transcode_audio"
	PlaybackInfoReasonTranscodeVideo    PlaybackInfoReason = "transcode_video"
	PlaybackInfoReasonUnknown           PlaybackInfoReason = "unknown"
)

// Defines values for PlaybackOutputFileKind.
const (
	PlaybackOutputFileKindFile PlaybackOutputFileKind = "file"
)

// Defines values for PlaybackOutputHlsKind.
const (
	Hls PlaybackOutputHlsKind = "hls"
)

// Defines values for ProblemCapabilitiesInvalidCode.
const (
	CapabilitiesInvalid ProblemCapabilitiesInvalidCode = "capabilities_invalid"
)

// Defines values for ProblemCapabilitiesMissingCode.
const (
	CapabilitiesMissing ProblemCapabilitiesMissingCode = "capabilities_missing"
)

// Defines values for ProblemDecisionAmbiguousCode.
const (
	DecisionAmbiguous ProblemDecisionAmbiguousCode = "decision_ambiguous"
)

// Defines values for RecordingBuildStatusAttemptMode.
const (
	Fast   RecordingBuildStatusAttemptMode = "fast"
	Robust RecordingBuildStatusAttemptMode = "robust"
)

// Defines values for RecordingBuildStatusState.
const (
	RecordingBuildStatusStateFAILED  RecordingBuildStatusState = "FAILED"
	RecordingBuildStatusStateIDLE    RecordingBuildStatusState = "IDLE"
	RecordingBuildStatusStateREADY   RecordingBuildStatusState = "READY"
	RecordingBuildStatusStateRUNNING RecordingBuildStatusState = "RUNNING"
)

// Defines values for RecordingItemStatus.
const (
	RecordingItemStatusCompleted RecordingItemStatus = "completed"
	RecordingItemStatusDeleting  RecordingItemStatus = "deleting"
	RecordingItemStatusFailed    RecordingItemStatus = "failed"
	RecordingItemStatusPending   RecordingItemStatus = "pending"
	RecordingItemStatusRecording RecordingItemStatus = "recording"
)

// Defines values for ScanStatusState.
const (
	ScanStatusStateCancelled ScanStatusState = "cancelled"
	ScanStatusStateComplete  ScanStatusState = "complete"
	ScanStatusStateFailed    ScanStatusState = "failed"
	ScanStatusStateIdle      ScanStatusState = "idle"
	ScanStatusStateRunning   ScanStatusState = "running"
)

// Defines values for SeriesRuleRunReportStatus.
const (
	Failed  SeriesRuleRunReportStatus = "failed"
	Partial SeriesRuleRunReportStatus = "partial"
	Success SeriesRuleRunReportStatus = "success"
)

// Defines values for SessionRecordReason.
const (
	SessionRecordReasonRBADREQUEST         SessionRecordReason = "R_BAD_REQUEST"
	SessionRecordReasonRCANCELLED          SessionRecordReason = "R_CANCELLED"
	SessionRecordReasonRCLIENTSTOP         SessionRecordReason = "R_CLIENT_STOP"
	SessionRecordReasonRFFMPEGSTARTFAILED  SessionRecordReason = "R_FFMPEG_START_FAILED"
	SessionRecordReasonRIDLETIMEOUT        SessionRecordReason = "R_IDLE_TIMEOUT"
	SessionRecordReasonRINVARIANTVIOLATION SessionRecordReason = "R_INVARIANT_VIOLATION"
	SessionRecordReasonRLEASEBUSY          SessionRecordReason = "R_LEASE_BUSY"
	SessionRecordReasonRLEASEEXPIRED       SessionRecordReason = "R_LEASE_EXPIRED"
	SessionRecordReasonRNONE               SessionRecordReason = "R_NONE"
	SessionRecordReasonRNOTFOUND           SessionRecordReason = "R_NOT_FOUND"
	SessionRecordReasonRPACKAGERFAILED     SessionRecordReason = "R_PACKAGER_FAILED"
	SessionRecordReasonRPROCESSENDED       SessionRecordReason = "R_PROCESS_ENDED"
	SessionRecordReasonRTUNEFAILED         SessionRecordReason = "R_TUNE_FAILED"
	SessionRecordReasonRTUNETIMEOUT        SessionRecordReason = "R_TUNE_TIMEOUT"
	SessionRecordReasonRUNKNOWN            SessionRecordReason = "R_UNKNOWN"
)

// Defines values for SessionRecordState.
const (
	SessionRecordStateCANCELLED SessionRecordState = "CANCELLED"
	SessionRecordStateDRAINING  SessionRecordState = "DRAINING"
	SessionRecordStateFAILED    SessionRecordState = "FAILED"
	SessionRecordStateNEW       SessionRecordState = "NEW"
	SessionRecordStatePRIMING   SessionRecordState = "PRIMING"
	SessionRecordStateREADY     SessionRecordState = "READY"
	SessionRecordStateSTARTING  SessionRecordState = "STARTING"
	SessionRecordStateSTOPPED   SessionRecordState = "STOPPED"
	SessionRecordStateSTOPPING  SessionRecordState = "STOPPING"
)

// Defines values for SessionResponseMode.
const (
	LIVE      SessionResponseMode = "LIVE"
	RECORDING SessionResponseMode = "RECORDING"
)

// Defines values for SessionResponseReason.
const (
	SessionResponseReasonRBADREQUEST         SessionResponseReason = "R_BAD_REQUEST"
	SessionResponseReasonRCANCELLED          SessionResponseReason = "R_CANCELLED"
	SessionResponseReasonRCLIENTSTOP         SessionResponseReason = "R_CLIENT_STOP"
	SessionResponseReasonRFFMPEGSTARTFAILED  SessionResponseReason = "R_FFMPEG_START_FAILED"
	SessionResponseReasonRIDLETIMEOUT        SessionResponseReason = "R_IDLE_TIMEOUT"
	SessionResponseReasonRINVARIANTVIOLATION SessionResponseReason = "R_INVARIANT_VIOLATION"
	SessionResponseReasonRLEASEBUSY          SessionResponseReason = "R_LEASE_BUSY"
	SessionResponseReasonRLEASEEXPIRED       SessionResponseReason = "R_LEASE_EXPIRED"
	SessionResponseReasonRNONE               SessionResponseReason = "R_NONE"
	SessionResponseReasonRNOTFOUND           SessionResponseReason = "R_NOT_FOUND"
	SessionResponseReasonRPACKAGERFAILED     SessionResponseReason = "R_PACKAGER_FAILED"
	SessionResponseReasonRPROCESSENDED       SessionResponseReason = "R_PROCESS_ENDED"
	SessionResponseReasonRTUNEFAILED         SessionResponseReason = "R_TUNE_FAILED"
	SessionResponseReasonRTUNETIMEOUT        SessionResponseReason = "R_TUNE_TIMEOUT"
	SessionResponseReasonRUNKNOWN            SessionResponseReason = "R_UNKNOWN"
)

// Defines values for SessionResponseState.
const (
	ACTIVE    SessionResponseState = "ACTIVE"
	BUFFERING SessionResponseState = "BUFFERING"
	CANCELLED SessionResponseState = "CANCELLED"
	DRAINING  SessionResponseState = "DRAINING"
	ENDING    SessionResponseState = "ENDING"
	ERROR     SessionResponseState = "ERROR"
	FAILED    SessionResponseState = "FAILED"
	IDLE      SessionResponseState = "IDLE"
	NEW       SessionResponseState = "NEW"
	PRIMING   SessionResponseState = "PRIMING"
	READY     SessionResponseState = "READY"
	STALLED   SessionResponseState = "STALLED"
	STARTING  SessionResponseState = "STARTING"
	STOPPED   SessionResponseState = "STOPPED"
	STOPPING  SessionResponseState = "STOPPING"
)

// Defines values for StorageItemAccess.
const (
	StorageItemAccessNone StorageItemAccess = "none"
	StorageItemAccessRo   StorageItemAccess = "ro"
	StorageItemAccessRw   StorageItemAccess = "rw"
)

// Defines values for StorageItemHealthStatus.
const (
	StorageItemHealthStatusError   StorageItemHealthStatus = "error"
	StorageItemHealthStatusOk      StorageItemHealthStatus = "ok"
	StorageItemHealthStatusSkipped StorageItemHealthStatus = "skipped"
	StorageItemHealthStatusTimeout StorageItemHealthStatus = "timeout"
	StorageItemHealthStatusUnknown StorageItemHealthStatus = "unknown"
)

// Defines values for StorageItemMountStatus.
const (
	StorageItemMountStatusMounted   StorageItemMountStatus = "mounted"
	StorageItemMountStatusUnknown   StorageItemMountStatus = "unknown"
	StorageItemMountStatusUnmounted StorageItemMountStatus = "unmounted"
)

// Defines values for StreamSessionState.
const (
	StreamSessionStateActive    StreamSessionState = "active"
	StreamSessionStateBuffering StreamSessionState = "buffering"
	StreamSessionStateEnding    StreamSessionState = "ending"
	StreamSessionStateError     StreamSessionState = "error"
	StreamSessionStateIdle      StreamSessionState = "idle"
	StreamSessionStateStalled   StreamSessionState = "stalled"
	StreamSessionStateStarting  StreamSessionState = "starting"
)

// Defines values for StreamingConfigDeliveryPolicy.
const (
	Universal StreamingConfigDeliveryPolicy = "universal"
)

// Defines values for SystemHealthStatus.
const (
	Degraded SystemHealthStatus = "degraded"
	Error    SystemHealthStatus = "error"
	Ok       SystemHealthStatus = "ok"
)

// Defines values for TimerState.
const (
	TimerStateCompleted TimerState = "completed"
	TimerStateDisabled  TimerState = "disabled"
	TimerStateRecording TimerState = "recording"
	TimerStateScheduled TimerState = "scheduled"
	TimerStateUnknown   TimerState = "unknown"
)

// Defines values for TimerConflictType.
const (
	TimerConflictTypeDuplicate  TimerConflictType = "duplicate"
	TimerConflictTypeOverlap    TimerConflictType = "overlap"
	TimerConflictTypeTunerLimit TimerConflictType = "tuner_limit"
	TimerConflictTypeUnknown    TimerConflictType = "unknown"
)

// Defines values for TimerConflictPreviewRequestMode.
const (
	Conservative  TimerConflictPreviewRequestMode = "conservative"
	ReceiverAware TimerConflictPreviewRequestMode = "receiverAware"
)

// Defines values for TimerConflictPreviewResponseSuggestionsKind.
const (
	ReducePadding TimerConflictPreviewResponseSuggestionsKind = "reduce_padding"
	ShiftEnd      TimerConflictPreviewResponseSuggestionsKind = "shift_end"
	ShiftStart    TimerConflictPreviewResponseSuggestionsKind = "shift_start"
)

// Defines values for TimerCreateRequestAfterEvent.
const (
	Deepstandby TimerCreateRequestAfterEvent = "deepstandby"
	Default     TimerCreateRequestAfterEvent = "default"
	Nothing     TimerCreateRequestAfterEvent = "nothing"
	Standby     TimerCreateRequestAfterEvent = "standby"
)

// APIError defines model for APIError.
type APIError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Optional additional context
	Details interface{} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Request ID for debugging
	RequestId string `json:"requestId"`
}

// AppConfig defines model for AppConfig.
type AppConfig struct {
	Bouquets  *[]string        `json:"bouquets,omitempty"`
	DataDir   *string          `json:"dataDir,omitempty"`
	Epg       *EPGConfig       `json:"epg,omitempty"`
	LogLevel  *string          `json:"logLevel,omitempty"`
	OpenWebIF *OpenWebIFConfig `json:"openWebIF,omitempty"`
	Picons    *PiconsConfig    `json:"picons,omitempty"`

	// Streaming Streaming delivery policy configuration (ADR-00X)
	Streaming    *StreamingConfig    `json:"streaming,omitempty"`
	Verification *VerificationConfig `json:"verification,omitempty"`
	Version      *string             `json:"version,omitempty"`
}

// Bouquet defines model for Bouquet.
type Bouquet struct {
	Name     *string `json:"name,omitempty"`
	Services *int    `json:"services,omitempty"`
}

// Breadcrumb defines model for Breadcrumb.
type Breadcrumb struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// ComponentStatus defines model for ComponentStatus.
type ComponentStatus struct {
	LastCheck *time.Time             `json:"lastCheck,omitempty"`
	Status    *ComponentStatusStatus `json:"status,omitempty"`
}

// ComponentStatusStatus defines model for ComponentStatus.Status.
type ComponentStatusStatus string

// ConfigUpdate defines model for ConfigUpdate.
type ConfigUpdate struct {
	Bouquets *[]string  `json:"bouquets,omitempty"`
	Epg      *EPGConfig `json:"epg,omitempty"`

	// LogLevel Log level to set (debug, info, warn, error)
	LogLevel     *string             `json:"logLevel,omitempty"`
	OpenWebIF    *OpenWebIFConfig    `json:"openWebIF,omitempty"`
	Picons       *PiconsConfig       `json:"picons,omitempty"`
	Verification *VerificationConfig `json:"verification,omitempty"`
}

// CurrentServiceInfo Current live service and EPG information from receiver
type CurrentServiceInfo struct {
	Channel *struct {
		Name *string `json:"name,omitempty"`
		Ref  *string `json:"ref,omitempty"`
	} `json:"channel,omitempty"`
	Next *struct {
		Title *string `json:"title,omitempty"`
	} `json:"next,omitempty"`
	Now *struct {
		BeginTimestamp *int64  `json:"beginTimestamp,omitempty"`
		Description    *string `json:"description,omitempty"`
		DurationSec    *int    `json:"durationSec,omitempty"`
		Title          *string `json:"title,omitempty"`
	} `json:"now,omitempty"`
	Status *CurrentServiceInfoStatus `json:"status,omitempty"`
}

// CurrentServiceInfoStatus defines model for CurrentServiceInfo.Status.
type CurrentServiceInfoStatus string

// DirectoryItem defines model for DirectoryItem.
type DirectoryItem struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// DvrCapabilities defines model for DvrCapabilities.
type DvrCapabilities struct {
	Conflicts struct {
		Preview       *bool `json:"preview,omitempty"`
		ReceiverAware *bool `json:"receiverAware,omitempty"`
	} `json:"conflicts"`
	Series struct {
		DelegatedProvider *string                    `json:"delegatedProvider,omitempty"`
		Mode              *DvrCapabilitiesSeriesMode `json:"mode,omitempty"`
		Supported         *bool                      `json:"supported,omitempty"`
	} `json:"series"`
	Timers struct {
		Delete         *bool `json:"delete,omitempty"`
		Edit           *bool `json:"edit,omitempty"`
		ReadBackVerify *bool `json:"readBackVerify,omitempty"`
	} `json:"timers"`
}

// DvrCapabilitiesSeriesMode defines model for DvrCapabilities.Series.Mode.
type DvrCapabilitiesSeriesMode string

// EPGConfig defines model for EPGConfig.
type EPGConfig struct {
	Days    *int             `json:"days,omitempty"`
	Enabled *bool            `json:"enabled,omitempty"`
	Source  *EPGConfigSource `json:"source,omitempty"`
}

// EPGConfigSource defines model for EPGConfig.Source.
type EPGConfigSource string

// EPGStatus defines model for EPGStatus.
type EPGStatus struct {
	MissingChannels *int             `json:"missingChannels,omitempty"`
	Status          *EPGStatusStatus `json:"status,omitempty"`
}

// EPGStatusStatus defines model for EPGStatus.Status.
type EPGStatusStatus string

// IntentRequest defines model for IntentRequest.
type IntentRequest struct {
	// CorrelationId Optional correlation ID for end-to-end tracing
	CorrelationId *string `json:"correlationId,omitempty"`

	// Hwaccel Hardware acceleration override (v3.1+).
	// - auto: Server decides based on GPU availability
	// - force: Force GPU encoding (fails if no GPU)
	// - off: Force CPU encoding
	Hwaccel *IntentRequestHwaccel `json:"hwaccel,omitempty"`

	// IdempotencyKey Optional idempotency key for at-most-once semantics
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`

	// Params Additional parameters
	Params *map[string]string `json:"params,omitempty"`

	// PlaybackDecisionToken Required for stream.start. A secure cryptographically bound JWT token verifying the backend decision policy.
	PlaybackDecisionToken *string `json:"playbackDecisionToken,omitempty"`

	// ServiceRef Required for stream.start. Enigma2 service reference (live playback only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// SessionId Required for stream.stop intent
	SessionId *openapi_types.UUID `json:"sessionId,omitempty"`
	Type      *IntentRequestType  `json:"type,omitempty"`
}

// IntentRequestHwaccel Hardware acceleration override (v3.1+).
// - auto: Server decides based on GPU availability
// - force: Force GPU encoding (fails if no GPU)
// - off: Force CPU encoding
type IntentRequestHwaccel string

// IntentRequestType defines model for IntentRequest.Type.
type IntentRequestType string

// LogEntry defines model for LogEntry.
type LogEntry struct {
	Fields  *map[string]interface{} `json:"fields,omitempty"`
	Level   *string                 `json:"level,omitempty"`
	Message *string                 `json:"message,omitempty"`
	Time    *time.Time              `json:"time,omitempty"`
}

// NowNextEntry defines model for NowNextEntry.
type NowNextEntry struct {
	// End Unix timestamp (seconds)
	End int `json:"end"`

	// Start Unix timestamp (seconds)
	Start int    `json:"start"`
	Title string `json:"title"`
}

// NowNextItem defines model for NowNextItem.
type NowNextItem struct {
	Next       *NowNextEntry `json:"next,omitempty"`
	Now        *NowNextEntry `json:"now,omitempty"`
	ServiceRef string        `json:"serviceRef"`
}

// NowNextRequest defines model for NowNextRequest.
type NowNextRequest struct {
	Services []string `json:"services"`
}

// NowNextResponse defines model for NowNextResponse.
type NowNextResponse struct {
	Items []NowNextItem `json:"items"`
}

// OpenWebIFConfig defines model for OpenWebIFConfig.
type OpenWebIFConfig struct {
	BaseUrl    *string `json:"baseUrl,omitempty"`
	Password   *string `json:"password,omitempty"`
	StreamPort *int    `json:"streamPort,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// PiconsConfig defines model for PiconsConfig.
type PiconsConfig struct {
	BaseUrl *string `json:"baseUrl,omitempty"`
}

// PlaybackCapabilities Client capabilities for playback decision (P4-1)
type PlaybackCapabilities struct {
	// AllowTranscode Whether client allows transcoding (force bypass)
	AllowTranscode *bool `json:"allowTranscode,omitempty"`

	// AudioCodecs Supported audio codecs
	AudioCodecs []string `json:"audioCodecs"`

	// CapabilitiesVersion Capabilities contract version (current: 1)
	CapabilitiesVersion int `json:"capabilitiesVersion"`

	// Container Supported container formats
	Container []string `json:"container"`

	// DeviceType Client device category for policy decisions
	DeviceType *string `json:"deviceType,omitempty"`

	// MaxVideo Optional resolution/FPS constraints
	MaxVideo *struct {
		Fps    *int `json:"fps,omitempty"`
		Height *int `json:"height,omitempty"`
		Width  *int `json:"width,omitempty"`
	} `json:"maxVideo,omitempty"`

	// SupportsHls Whether client supports HLS playlists
	SupportsHls *bool `json:"supportsHls,omitempty"`

	// SupportsRange Whether client supports HTTP range requests
	SupportsRange *bool `json:"supportsRange,omitempty"`

	// VideoCodecs Supported video codecs
	VideoCodecs []string `json:"videoCodecs"`
}

// PlaybackDecision Complete playback decision from backend (P4-1)
type PlaybackDecision struct {
	// Constraints Applied constraints (e.g., downscale_required)
	Constraints []string `json:"constraints"`

	// Mode Playback mode decision
	Mode PlaybackDecisionMode `json:"mode"`

	// Outputs Available output URLs/playlists
	Outputs []PlaybackOutput `json:"outputs"`

	// Reasons Machine-readable decision reason codes
	Reasons []string `json:"reasons"`

	// Selected Selected output format
	Selected struct {
		AudioCodec string `json:"audioCodec"`
		Container  string `json:"container"`
		VideoCodec string `json:"videoCodec"`
	} `json:"selected"`

	// SelectedOutputKind The explicitly selected playback kind.
	SelectedOutputKind PlaybackDecisionSelectedOutputKind `json:"selectedOutputKind"`

	// SelectedOutputUrl The explicitly selected playback URL (backend-driven).
	SelectedOutputUrl string `json:"selectedOutputUrl"`

	// Trace Traceability information
	Trace PlaybackTrace `json:"trace"`
}

// PlaybackDecisionMode Playback mode decision
type PlaybackDecisionMode string

// PlaybackDecisionSelectedOutputKind The explicitly selected playback kind.
type PlaybackDecisionSelectedOutputKind string

// PlaybackFeedbackRequest defines model for PlaybackFeedbackRequest.
type PlaybackFeedbackRequest struct {
	// Code MediaError code if applicable
	Code    *int                         `json:"code,omitempty"`
	Details *map[string]interface{}      `json:"details,omitempty"`
	Event   PlaybackFeedbackRequestEvent `json:"event"`
	Message *string                      `json:"message,omitempty"`
}

// PlaybackFeedbackRequestEvent defines model for PlaybackFeedbackRequest.Event.
type PlaybackFeedbackRequestEvent string

// PlaybackInfo defines model for PlaybackInfo.
type PlaybackInfo struct {
	// AudioCodec Truthful audio codec if known (e.g., aac, ac3, mp2).
	AudioCodec *string `json:"audioCodec,omitempty"`

	// Container Truthful container name if known (e.g., ts, mp4, mkv).
	Container *string `json:"container,omitempty"`

	// Decision Complete playback decision from backend (P4-1)
	Decision *PlaybackDecision `json:"decision,omitempty"`

	// DecisionReason Machine-readable constant explaining why this mode was chosen (e.g. 'CAPABILITY_H264_UNSUPPORTED').
	DecisionReason *string `json:"decisionReason,omitempty"`

	// DurationSeconds Duration in seconds. Omitted if unknown or preparing.
	DurationSeconds *int64 `json:"durationSeconds,omitempty"`

	// DurationSource Source of the reported duration, when durationSeconds is present.
	DurationSource *PlaybackInfoDurationSource `json:"durationSource,omitempty"`

	// DvrWindowSeconds Absolute DVR window length in seconds. Becomes required in P3-4.
	DvrWindowSeconds *int64 `json:"dvrWindowSeconds,omitempty"`

	// IsSeekable Authoritative flag if the stream is seekable. Becomes required in P3-4.
	IsSeekable *bool `json:"isSeekable,omitempty"`

	// LiveEdgeUnix wall-clock timestamp (UNIX) of the latest segment. Becomes required in P3-4.
	LiveEdgeUnix *int64 `json:"liveEdgeUnix,omitempty"`

	// Mode Selected playback strategy output mode.
	Mode PlaybackInfoMode `json:"mode"`

	// PlaybackDecisionToken Attestation token for live playback intent creation
	PlaybackDecisionToken *string `json:"playbackDecisionToken,omitempty"`

	// Reason Reason for the playback decision.
	Reason *PlaybackInfoReason `json:"reason,omitempty"`

	// RequestId Correlation ID for the request. Mandatory in P3-1.
	RequestId string         `json:"requestId"`
	Resume    *ResumeSummary `json:"resume,omitempty"`

	// Seekable Whether the stream is seekable. Omitted if unknown. Deprecated in favor of isSeekable.
	Seekable *bool `json:"seekable,omitempty"`

	// SessionId Unique ID for the stream session. Mandatory in P3-1.
	SessionId string `json:"sessionId"`

	// StartUnix wall-clock timestamp (UNIX) of the earliest segment in window. Becomes required in P3-4.
	StartUnix *int64 `json:"startUnix,omitempty"`

	// Url Relative URL for the selected playback strategy. Optional for deny or decision-led cases.
	Url *string `json:"url,omitempty"`

	// VideoCodec Truthful video codec if known (e.g., h264, hevc, mpeg2).
	VideoCodec *string `json:"videoCodec,omitempty"`
}

// PlaybackInfoDurationSource Source of the reported duration, when durationSeconds is present.
type PlaybackInfoDurationSource string

// PlaybackInfoMode Selected playback strategy output mode.
type PlaybackInfoMode string

// PlaybackInfoReason Reason for the playback decision.
type PlaybackInfoReason string

// PlaybackOutput Output URL for client playback
type PlaybackOutput struct {
	union json.RawMessage
}

// PlaybackOutputFile defines model for PlaybackOutputFile.
type PlaybackOutputFile struct {
	// Kind Static file output
	Kind PlaybackOutputFileKind `json:"kind"`

	// Url Direct playback URL
	Url string `json:"url"`
}

// PlaybackOutputFileKind Static file output
type PlaybackOutputFileKind string

// PlaybackOutputHls defines model for PlaybackOutputHls.
type PlaybackOutputHls struct {
	// Kind HLS stream output
	Kind PlaybackOutputHlsKind `json:"kind"`

	// PlaylistUrl Canonical HLS playlist URL (.m3u8)
	PlaylistUrl string `json:"playlistUrl"`

	// Url Alternate playback URL (optional)
	Url *string `json:"url,omitempty"`
}

// PlaybackOutputHlsKind HLS stream output
type PlaybackOutputHlsKind string

// PlaybackTrace Traceability information
type PlaybackTrace struct {
	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string  `json:"requestId"`
	SessionId *string `json:"sessionId"`
}

// ProblemCapabilitiesInvalid defines model for ProblemCapabilitiesInvalid.
type ProblemCapabilitiesInvalid struct {
	Code      *ProblemCapabilitiesInvalidCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict                `json:"conflicts,omitempty"`
	Detail    *string                         `json:"detail,omitempty"`
	Fields    *map[string]interface{}         `json:"fields,omitempty"`
	Instance  *string                         `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemCapabilitiesInvalidCode defines model for ProblemCapabilitiesInvalid.Code.
type ProblemCapabilitiesInvalidCode string

// ProblemCapabilitiesMissing defines model for ProblemCapabilitiesMissing.
type ProblemCapabilitiesMissing struct {
	Code      *ProblemCapabilitiesMissingCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict                `json:"conflicts,omitempty"`
	Detail    *string                         `json:"detail,omitempty"`
	Fields    *map[string]interface{}         `json:"fields,omitempty"`
	Instance  *string                         `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemCapabilitiesMissingCode defines model for ProblemCapabilitiesMissing.Code.
type ProblemCapabilitiesMissingCode string

// ProblemDecisionAmbiguous defines model for ProblemDecisionAmbiguous.
type ProblemDecisionAmbiguous struct {
	Code      *ProblemDecisionAmbiguousCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict              `json:"conflicts,omitempty"`
	Detail    *string                       `json:"detail,omitempty"`
	Fields    *map[string]interface{}       `json:"fields,omitempty"`
	Instance  *string                       `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemDecisionAmbiguousCode defines model for ProblemDecisionAmbiguous.Code.
type ProblemDecisionAmbiguousCode string

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	// Code Stable machine-readable short code (e.g. "NOT_FOUND")
	Code      *string                 `json:"code,omitempty"`
	Conflicts *[]TimerConflict        `json:"conflicts,omitempty"`
	Detail    *string                 `json:"detail,omitempty"`
	Fields    *map[string]interface{} `json:"fields,omitempty"`
	Instance  *string                 `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// RecordingBuildStatus defines model for RecordingBuildStatus.
type RecordingBuildStatus struct {
	AttemptMode  *RecordingBuildStatusAttemptMode `json:"attemptMode,omitempty"`
	Error        *string                          `json:"error,omitempty"`
	LastProgress *time.Time                       `json:"lastProgress,omitempty"`

	// ProgressiveReady True if a progressive (timeshift) playlist is playable.
	ProgressiveReady *bool `json:"progressiveReady,omitempty"`

	// RequestId Correlation ID for the request.
	RequestId    string                    `json:"requestId"`
	SegmentCount *int                      `json:"segmentCount,omitempty"`
	StartedAt    *time.Time                `json:"startedAt,omitempty"`
	State        RecordingBuildStatusState `json:"state"`
}

// RecordingBuildStatusAttemptMode defines model for RecordingBuildStatus.AttemptMode.
type RecordingBuildStatusAttemptMode string

// RecordingBuildStatusState defines model for RecordingBuildStatus.State.
type RecordingBuildStatusState string

// RecordingItem defines model for RecordingItem.
type RecordingItem struct {
	// BeginUnixSeconds Recording start time as UNIX seconds.
	BeginUnixSeconds *int64  `json:"beginUnixSeconds,omitempty"`
	Description      *string `json:"description,omitempty"`

	// DurationSeconds Recording duration in seconds, if known.
	DurationSeconds *int64  `json:"durationSeconds,omitempty"`
	Filename        *string `json:"filename,omitempty"`

	// Length Human-readable duration string for display only.
	Length *string `json:"length,omitempty"`

	// RecordingId Base64url-encoded recording ID (RFC 4648, unpadded) to use for /recordings/{recordingId}.
	RecordingId *string        `json:"recordingId,omitempty"`
	Resume      *ResumeSummary `json:"resume,omitempty"`

	// ServiceRef Legacy receiver service reference (read-only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// Status Consolidated recording status. Becomes required in P3-3.
	Status *RecordingItemStatus `json:"status,omitempty"`
	Title  *string              `json:"title,omitempty"`
}

// RecordingItemStatus Consolidated recording status. Becomes required in P3-3.
type RecordingItemStatus string

// RecordingResponse defines model for RecordingResponse.
type RecordingResponse struct {
	Breadcrumbs *[]Breadcrumb    `json:"breadcrumbs,omitempty"`
	CurrentPath *string          `json:"currentPath,omitempty"`
	CurrentRoot *string          `json:"currentRoot,omitempty"`
	Directories *[]DirectoryItem `json:"directories,omitempty"`
	Recordings  *[]RecordingItem `json:"recordings,omitempty"`

	// RequestId Correlation ID for the request.
	RequestId string           `json:"requestId"`
	Roots     *[]RecordingRoot `json:"roots,omitempty"`
}

// RecordingRoot defines model for RecordingRoot.
type RecordingRoot struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// RecordingStatus defines model for RecordingStatus.
type RecordingStatus struct {
	IsRecording bool    `json:"isRecording"`
	ServiceName *string `json:"serviceName,omitempty"`
}

// ResumeSummary defines model for ResumeSummary.
type ResumeSummary struct {
	DurationSeconds *int64     `json:"durationSeconds,omitempty"`
	Finished        *bool      `json:"finished,omitempty"`
	PosSeconds      int64      `json:"posSeconds"`
	UpdatedAt       *time.Time `json:"updatedAt,omitempty"`
}

// RuleSnapshot defines model for RuleSnapshot.
type RuleSnapshot struct {
	ChannelRef  *string `json:"channelRef,omitempty"`
	Days        *[]int  `json:"days,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Id          *string `json:"id,omitempty"`
	Keyword     *string `json:"keyword,omitempty"`
	Priority    *int    `json:"priority,omitempty"`
	StartWindow *string `json:"startWindow,omitempty"`
}

// RunConflict defines model for RunConflict.
type RunConflict struct {
	Begin           *int64  `json:"begin,omitempty"`
	BlockingTimerId *string `json:"blockingTimerId,omitempty"`
	End             *int64  `json:"end,omitempty"`
	Message         *string `json:"message,omitempty"`
	OverlapSeconds  *int64  `json:"overlapSeconds,omitempty"`
	ServiceRef      *string `json:"serviceRef,omitempty"`
	Title           *string `json:"title,omitempty"`
}

// RunDecision defines model for RunDecision.
type RunDecision struct {
	Action      *string   `json:"action,omitempty"`
	Begin       *int64    `json:"begin,omitempty"`
	Details     *string   `json:"details,omitempty"`
	End         *int64    `json:"end,omitempty"`
	MatchReason *[]string `json:"matchReason,omitempty"`
	Reason      *string   `json:"reason,omitempty"`
	ServiceRef  *string   `json:"serviceRef,omitempty"`
	TimerId     *string   `json:"timerId,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// RunError defines model for RunError.
type RunError struct {
	At        *time.Time `json:"at,omitempty"`
	Message   *string    `json:"message,omitempty"`
	Retryable *bool      `json:"retryable,omitempty"`
	Type      *string    `json:"type,omitempty"`
}

// RunSummary defines model for RunSummary.
type RunSummary struct {
	EpgItemsMatched             *int  `json:"epgItemsMatched,omitempty"`
	EpgItemsScanned             *int  `json:"epgItemsScanned,omitempty"`
	MaxMatchesScannedPerRuleHit *bool `json:"maxMatchesScannedPerRuleHit,omitempty"`
	MaxTimersGlobalPerRunHit    *bool `json:"maxTimersGlobalPerRunHit,omitempty"`
	ReceiverUnreachable         *bool `json:"receiverUnreachable,omitempty"`
	TimersAttempted             *int  `json:"timersAttempted,omitempty"`
	TimersConflicted            *int  `json:"timersConflicted,omitempty"`
	TimersCreated               *int  `json:"timersCreated,omitempty"`
	TimersErrored               *int  `json:"timersErrored,omitempty"`
	TimersSkipped               *int  `json:"timersSkipped,omitempty"`
}

// ScanStatus defines model for ScanStatus.
type ScanStatus struct {
	// FinishedAt Unix timestamp of when the last scan completed
	FinishedAt *int64  `json:"finishedAt,omitempty"`
	LastError  *string `json:"lastError,omitempty"`

	// ScannedChannels Number of attempts (successful/failed) to probe channels so far
	ScannedChannels *int `json:"scannedChannels,omitempty"`

	// StartedAt Unix timestamp of when the current or last scan started
	StartedAt *int64           `json:"startedAt,omitempty"`
	State     *ScanStatusState `json:"state,omitempty"`

	// TotalChannels Total number of channels in the playlist
	TotalChannels *int `json:"totalChannels,omitempty"`

	// UpdatedCount Number of capabilities successfully updated in the store
	UpdatedCount *int `json:"updatedCount,omitempty"`
}

// ScanStatusState defines model for ScanStatus.State.
type ScanStatusState string

// SeriesRule defines model for SeriesRule.
type SeriesRule struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channelRef,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int  `json:"days,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Id      *string `json:"id,omitempty"`

	// Keyword Search term or regex for event title
	Keyword        *string     `json:"keyword,omitempty"`
	LastRunAt      *time.Time  `json:"lastRunAt,omitempty"`
	LastRunStatus  *string     `json:"lastRunStatus,omitempty"`
	LastRunSummary *RunSummary `json:"lastRunSummary,omitempty"`
	Priority       *int        `json:"priority,omitempty"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"startWindow,omitempty"`
}

// SeriesRuleRunReport defines model for SeriesRuleRunReport.
type SeriesRuleRunReport struct {
	Conflicts  *[]RunConflict             `json:"conflicts,omitempty"`
	Decisions  *[]RunDecision             `json:"decisions,omitempty"`
	DurationMs *int64                     `json:"durationMs,omitempty"`
	Errors     *[]RunError                `json:"errors,omitempty"`
	FinishedAt *time.Time                 `json:"finishedAt,omitempty"`
	RuleId     *string                    `json:"ruleId,omitempty"`
	RunId      *string                    `json:"runId,omitempty"`
	Snapshot   *RuleSnapshot              `json:"snapshot,omitempty"`
	StartedAt  *time.Time                 `json:"startedAt,omitempty"`
	Status     *SeriesRuleRunReportStatus `json:"status,omitempty"`
	Summary    *RunSummary                `json:"summary,omitempty"`
	Trigger    *string                    `json:"trigger,omitempty"`
	WindowFrom *int64                     `json:"windowFrom,omitempty"`
	WindowTo   *int64                     `json:"windowTo,omitempty"`
}

// SeriesRuleRunReportStatus defines model for SeriesRuleRunReport.Status.
type SeriesRuleRunReportStatus string

// SeriesRuleUpdate defines model for SeriesRuleUpdate.
type SeriesRuleUpdate struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channelRef,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int `json:"days,omitempty"`
	Enabled bool   `json:"enabled"`

	// Keyword Search term or regex for event title
	Keyword  string `json:"keyword"`
	Priority int    `json:"priority"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"startWindow,omitempty"`
}

// Service defines model for Service.
type Service struct {
	// Codec Video codec (e.g. h264)
	Codec   *string `json:"codec,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Group   *string `json:"group,omitempty"`
	Id      *string `json:"id,omitempty"`
	LogoUrl *string `json:"logoUrl,omitempty"`
	Name    *string `json:"name,omitempty"`
	Number  *string `json:"number,omitempty"`

	// Resolution Video resolution (e.g. 1920x1080)
	Resolution *string `json:"resolution,omitempty"`

	// ServiceRef Service reference for streaming (extracted from M3U URL)
	ServiceRef *string `json:"serviceRef,omitempty"`
}

// SessionRecord defines model for SessionRecord.
type SessionRecord struct {
	ContextData    *map[string]string      `json:"contextData,omitempty"`
	CorrelationId  *string                 `json:"correlationId,omitempty"`
	CreatedAtUnix  *int64                  `json:"createdAtUnix,omitempty"`
	LastAccessUnix *int64                  `json:"lastAccessUnix,omitempty"`
	Profile        *map[string]interface{} `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionRecordReason `json:"reason,omitempty"`
	ReasonDetail *string              `json:"reasonDetail,omitempty"`
	ServiceRef   *string              `json:"serviceRef,omitempty"`
	SessionId    *openapi_types.UUID  `json:"sessionId,omitempty"`

	// State Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
	// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
	State         *SessionRecordState `json:"state,omitempty"`
	TunerID       *string             `json:"tunerID,omitempty"`
	UpdatedAtUnix *int64              `json:"updatedAtUnix,omitempty"`
}

// SessionRecordReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionRecordReason string

// SessionRecordState Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
type SessionRecordState string

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	CorrelationId *string `json:"correlationId,omitempty"`

	// DurationSeconds DVR window length for live sessions, in seconds.
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// LiveEdgeSeconds Current live edge position in seconds (live only).
	LiveEdgeSeconds *float32 `json:"liveEdgeSeconds,omitempty"`

	// Mode Playback mode for the session.
	Mode *SessionResponseMode `json:"mode,omitempty"`

	// PlaybackUrl Playback URL for the HLS playlist.
	PlaybackUrl *string `json:"playbackUrl,omitempty"`
	Profile     *string `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionResponseReason `json:"reason,omitempty"`
	ReasonDetail *string                `json:"reasonDetail,omitempty"`

	// RequestId Request ID for debugging/tracing. Mandatory in P3-1.
	RequestId string `json:"requestId"`

	// SeekableEndSeconds Latest seekable position in seconds.
	SeekableEndSeconds *float32 `json:"seekableEndSeconds,omitempty"`

	// SeekableStartSeconds Earliest seekable position in seconds.
	SeekableStartSeconds *float32           `json:"seekableStartSeconds,omitempty"`
	ServiceRef           *string            `json:"serviceRef,omitempty"`
	SessionId            openapi_types.UUID `json:"sessionId"`

	// State Session lifecycle state. STARTING guarantees a session ticket is allocated.
	// READY/ACTIVE guarantees a playable HLS stream.
	State       SessionResponseState `json:"state"`
	UpdatedAtMs *int                 `json:"updatedAtMs,omitempty"`
}

// SessionResponseMode Playback mode for the session.
type SessionResponseMode string

// SessionResponseReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionResponseReason string

// SessionResponseState Session lifecycle state. STARTING guarantees a session ticket is allocated.
// READY/ACTIVE guarantees a playable HLS stream.
type SessionResponseState string

// StorageItem defines model for StorageItem.
type StorageItem struct {
	// Access Access level detected during probe.
	Access    StorageItemAccess `json:"access"`
	Capacity  *string           `json:"capacity,omitempty"`
	CheckedAt *time.Time        `json:"checkedAt,omitempty"`
	FsType    *string           `json:"fsType,omitempty"`

	// HealthStatus Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
	HealthStatus StorageItemHealthStatus `json:"healthStatus"`
	IsNas        bool                    `json:"isNas"`
	Model        *string                 `json:"model,omitempty"`
	Mount        *string                 `json:"mount,omitempty"`
	MountStatus  StorageItemMountStatus  `json:"mountStatus"`
}

// StorageItemAccess Access level detected during probe.
type StorageItemAccess string

// StorageItemHealthStatus Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
type StorageItemHealthStatus string

// StorageItemMountStatus defines model for StorageItem.MountStatus.
type StorageItemMountStatus string

// StreamSession defines model for StreamSession.
type StreamSession struct {
	ChannelName *string `json:"channelName,omitempty"`
	ClientIp    *string `json:"clientIp,omitempty"`

	// Id Internal database ID (deprecated).
	Id      *string `json:"id,omitempty"`
	Program *struct {
		BeginTimestamp *int64  `json:"beginTimestamp,omitempty"`
		Description    *string `json:"description,omitempty"`
		DurationSec    *int    `json:"durationSec,omitempty"`
		Title          *string `json:"title,omitempty"`
	} `json:"program,omitempty"`

	// RequestId Correlation ID for the trace. Mandatory in P3-1.
	RequestId string `json:"requestId"`

	// SessionId Mandatory stream lifecycle ID (domain truth).
	SessionId openapi_types.UUID `json:"sessionId"`
	StartedAt *time.Time         `json:"startedAt,omitempty"`
	State     StreamSessionState `json:"state"`
}

// StreamSessionState defines model for StreamSession.State.
type StreamSessionState string

// StreamingConfig Streaming delivery policy configuration (ADR-00X)
type StreamingConfig struct {
	// DeliveryPolicy Streaming delivery policy (only 'universal' is supported)
	DeliveryPolicy *StreamingConfigDeliveryPolicy `json:"deliveryPolicy,omitempty"`
}

// StreamingConfigDeliveryPolicy Streaming delivery policy (only 'universal' is supported)
type StreamingConfigDeliveryPolicy string

// SystemHealth defines model for SystemHealth.
type SystemHealth struct {
	Epg           *EPGStatus          `json:"epg,omitempty"`
	Receiver      *ComponentStatus    `json:"receiver,omitempty"`
	Status        *SystemHealthStatus `json:"status,omitempty"`
	UptimeSeconds *int64              `json:"uptimeSeconds,omitempty"`
	Version       *string             `json:"version,omitempty"`
}

// SystemHealthStatus defines model for SystemHealth.Status.
type SystemHealthStatus string

// SystemInfoData defines model for SystemInfoData.
type SystemInfoData struct {
	Hardware *struct {
		Boxtype            *string `json:"boxtype,omitempty"`
		Brand              *string `json:"brand,omitempty"`
		Chipset            *string `json:"chipset,omitempty"`
		ChipsetDescription *string `json:"chipsetDescription,omitempty"`
		Model              *string `json:"model,omitempty"`
	} `json:"hardware,omitempty"`
	Network *struct {
		Interfaces *[]struct {
			Dhcp  *bool   `json:"dhcp,omitempty"`
			Ip    *string `json:"ip,omitempty"`
			Ipv6  *string `json:"ipv6,omitempty"`
			Mac   *string `json:"mac,omitempty"`
			Name  *string `json:"name,omitempty"`
			Speed *string `json:"speed,omitempty"`
			Type  *string `json:"type,omitempty"`
		} `json:"interfaces,omitempty"`
	} `json:"network,omitempty"`
	Resource *struct {
		MemoryAvailable *string `json:"memoryAvailable,omitempty"`
		MemoryTotal     *string `json:"memoryTotal,omitempty"`
		MemoryUsed      *string `json:"memoryUsed,omitempty"`
	} `json:"resource,omitempty"`
	Runtime *struct {
		Uptime *string `json:"uptime,omitempty"`
	} `json:"runtime,omitempty"`
	Software *struct {
		DriverDate    *string `json:"driverDate,omitempty"`
		EnigmaVersion *string `json:"enigmaVersion,omitempty"`
		ImageDistro   *string `json:"imageDistro,omitempty"`
		ImageVersion  *string `json:"imageVersion,omitempty"`
		KernelVersion *string `json:"kernelVersion,omitempty"`
		OeVersion     *string `json:"oeVersion,omitempty"`
		WebifVersion  *string `json:"webifVersion,omitempty"`
	} `json:"software,omitempty"`
	Storage *struct {
		Devices   *[]StorageItem `json:"devices,omitempty"`
		Locations *[]StorageItem `json:"locations,omitempty"`
	} `json:"storage,omitempty"`
	Tuners *[]struct {
		Name   *string `json:"name,omitempty"`
		Status *string `json:"status,omitempty"`
		Type   *string `json:"type,omitempty"`
	} `json:"tuners,omitempty"`
}

// Timer defines model for Timer.
type Timer struct {
	Begin         int64                   `json:"begin"`
	CreatedAt     *time.Time              `json:"createdAt,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	End           int64                   `json:"end"`
	Name          string                  `json:"name"`
	ReceiverState *map[string]interface{} `json:"receiverState,omitempty"`
	ServiceName   *string                 `json:"serviceName,omitempty"`
	ServiceRef    string                  `json:"serviceRef"`
	State         TimerState              `json:"state"`
	TimerId       string                  `json:"timerId"`
	UpdatedAt     *time.Time              `json:"updatedAt,omitempty"`
}

// TimerState defines model for Timer.State.
type TimerState string

// TimerConflict defines model for TimerConflict.
type TimerConflict struct {
	BlockingTimer  Timer             `json:"blockingTimer"`
	Message        *string           `json:"message,omitempty"`
	OverlapSeconds *int              `json:"overlapSeconds,omitempty"`
	Type           TimerConflictType `json:"type"`
}

// TimerConflictType defines model for TimerConflict.Type.
type TimerConflictType string

// TimerConflictPreviewRequest defines model for TimerConflictPreviewRequest.
type TimerConflictPreviewRequest struct {
	Mode     *TimerConflictPreviewRequestMode `json:"mode,omitempty"`
	Proposed TimerCreateRequest               `json:"proposed"`
}

// TimerConflictPreviewRequestMode defines model for TimerConflictPreviewRequest.Mode.
type TimerConflictPreviewRequestMode string

// TimerConflictPreviewResponse defines model for TimerConflictPreviewResponse.
type TimerConflictPreviewResponse struct {
	CanSchedule bool            `json:"canSchedule"`
	Conflicts   []TimerConflict `json:"conflicts"`
	Suggestions *[]struct {
		Kind          *TimerConflictPreviewResponseSuggestionsKind `json:"kind,omitempty"`
		Note          *string                                      `json:"note,omitempty"`
		ProposedBegin *int64                                       `json:"proposedBegin,omitempty"`
		ProposedEnd   *int64                                       `json:"proposedEnd,omitempty"`
	} `json:"suggestions,omitempty"`
}

// TimerConflictPreviewResponseSuggestionsKind defines model for TimerConflictPreviewResponse.Suggestions.Kind.
type TimerConflictPreviewResponseSuggestionsKind string

// TimerCreateRequest defines model for TimerCreateRequest.
type TimerCreateRequest struct {
	AfterEvent       *TimerCreateRequestAfterEvent `json:"afterEvent,omitempty"`
	Begin            int64                         `json:"begin"`
	Description      *string                       `json:"description,omitempty"`
	Enabled          *bool                         `json:"enabled,omitempty"`
	End              int64                         `json:"end"`
	IdempotencyKey   *string                       `json:"idempotencyKey,omitempty"`
	JustPlay         *bool                         `json:"justPlay,omitempty"`
	Name             string                        `json:"name"`
	PaddingAfterSec  *int                          `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int                          `json:"paddingBeforeSec,omitempty"`
	ServiceRef       string                        `json:"serviceRef"`
}

// TimerCreateRequestAfterEvent defines model for TimerCreateRequest.AfterEvent.
type TimerCreateRequestAfterEvent string

// TimerList defines model for TimerList.
type TimerList struct {
	Items []Timer `json:"items"`
}

// TimerPatchRequest defines model for TimerPatchRequest.
type TimerPatchRequest struct {
	Begin            *int64  `json:"begin,omitempty"`
	Description      *string `json:"description,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty"`
	End              *int64  `json:"end,omitempty"`
	Name             *string `json:"name,omitempty"`
	PaddingAfterSec  *int    `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int    `json:"paddingBeforeSec,omitempty"`
}

// VerificationConfig defines model for VerificationConfig.
type VerificationConfig struct {
	Enabled *bool `json:"enabled,omitempty"`

	// Interval Drift verification interval (e.g. "1m")
	Interval *string `json:"interval,omitempty"`
}

// GetEpgParams defines parameters for GetEpg.
type GetEpgParams struct {
	// From Start timestamp (unix seconds)
	From *int `form:"from,omitempty" json:"from,omitempty"`

	// To End timestamp (unix seconds)
	To *int `form:"to,omitempty" json:"to,omitempty"`

	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`

	// Q Filter by search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// PostLivePlaybackInfoJSONBody defines parameters for PostLivePlaybackInfo.
type PostLivePlaybackInfoJSONBody struct {
	// Capabilities Client capabilities for playback decision (P4-1)
	Capabilities PlaybackCapabilities `json:"capabilities"`

	// ServiceRef The Enigma2 service reference
	ServiceRef string `json:"serviceRef"`
}

// GetRecordingsParams defines parameters for GetRecordings.
type GetRecordingsParams struct {
	// Root Root location ID
	Root *string `form:"root,omitempty" json:"root,omitempty"`

	// Path Relative path
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// RunAllSeriesRulesParams defines parameters for RunAllSeriesRules.
type RunAllSeriesRulesParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// RunSeriesRuleParams defines parameters for RunSeriesRule.
type RunSeriesRuleParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`
}

// PostServicesIdToggleJSONBody defines parameters for PostServicesIdToggle.
type PostServicesIdToggleJSONBody struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Pagination limit (max 1000)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTimersParams defines parameters for GetTimers.
type GetTimersParams struct {
	State *string `form:"state,omitempty" json:"state,omitempty"`
	From  *int    `form:"from,omitempty" json:"from,omitempty"`
}

// CreateIntentJSONRequestBody defines body for CreateIntent for application/json ContentType.
type CreateIntentJSONRequestBody = IntentRequest

// PostLivePlaybackInfoJSONRequestBody defines body for PostLivePlaybackInfo for application/json ContentType.
type PostLivePlaybackInfoJSONRequestBody PostLivePlaybackInfoJSONBody

// PostRecordingPlaybackInfoJSONRequestBody defines body for PostRecordingPlaybackInfo for application/json ContentType.
type PostRecordingPlaybackInfoJSONRequestBody = PlaybackCapabilities

// CreateSeriesRuleJSONRequestBody defines body for CreateSeriesRule for application/json ContentType.
type CreateSeriesRuleJSONRequestBody = SeriesRule

// UpdateSeriesRuleJSONRequestBody defines body for UpdateSeriesRule for application/json ContentType.
type UpdateSeriesRuleJSONRequestBody = SeriesRuleUpdate

// PostServicesNowNextJSONRequestBody defines body for PostServicesNowNext for application/json ContentType.
type PostServicesNowNextJSONRequestBody = NowNextRequest

// PostServicesIdToggleJSONRequestBody defines body for PostServicesIdToggle for application/json ContentType.
type PostServicesIdToggleJSONRequestBody PostServicesIdToggleJSONBody

// ReportPlaybackFeedbackJSONRequestBody defines body for ReportPlaybackFeedback for application/json ContentType.
type ReportPlaybackFeedbackJSONRequestBody = PlaybackFeedbackRequest

// PutSystemConfigJSONRequestBody defines body for PutSystemConfig for application/json ContentType.
type PutSystemConfigJSONRequestBody = ConfigUpdate

// AddTimerJSONRequestBody defines body for AddTimer for application/json ContentType.
type AddTimerJSONRequestBody = TimerCreateRequest

// PreviewConflictsJSONRequestBody defines body for PreviewConflicts for application/json ContentType.
type PreviewConflictsJSONRequestBody = TimerConflictPreviewRequest

// UpdateTimerJSONRequestBody defines body for UpdateTimer for application/json ContentType.
type UpdateTimerJSONRequestBody = TimerPatchRequest

// AsPlaybackOutputFile returns the union data inside the PlaybackOutput as a PlaybackOutputFile
func (t PlaybackOutput) AsPlaybackOutputFile() (PlaybackOutputFile, error) {
	var body PlaybackOutputFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackOutputFile overwrites any union data inside the PlaybackOutput as the provided PlaybackOutputFile
func (t *PlaybackOutput) FromPlaybackOutputFile(v PlaybackOutputFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackOutputFile performs a merge with any union data inside the PlaybackOutput, using the provided PlaybackOutputFile
func (t *PlaybackOutput) MergePlaybackOutputFile(v PlaybackOutputFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaybackOutputHls returns the union data inside the PlaybackOutput as a PlaybackOutputHls
func (t PlaybackOutput) AsPlaybackOutputHls() (PlaybackOutputHls, error) {
	var body PlaybackOutputHls
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackOutputHls overwrites any union data inside the PlaybackOutput as the provided PlaybackOutputHls
func (t *PlaybackOutput) FromPlaybackOutputHls(v PlaybackOutputHls) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackOutputHls performs a merge with any union data inside the PlaybackOutput, using the provided PlaybackOutputHls
func (t *PlaybackOutput) MergePlaybackOutputHls(v PlaybackOutputHls) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlaybackOutput) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlaybackOutput) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
