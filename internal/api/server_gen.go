// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ComponentStatusStatus.
const (
	ComponentStatusStatusError ComponentStatusStatus = "error"
	ComponentStatusStatusOk    ComponentStatusStatus = "ok"
)

// Defines values for CurrentServiceInfoStatus.
const (
	CurrentServiceInfoStatusOk          CurrentServiceInfoStatus = "ok"
	CurrentServiceInfoStatusUnavailable CurrentServiceInfoStatus = "unavailable"
)

// Defines values for DvrCapabilitiesSeriesMode.
const (
	DvrCapabilitiesSeriesModeDelegated DvrCapabilitiesSeriesMode = "delegated"
	DvrCapabilitiesSeriesModeManaged   DvrCapabilitiesSeriesMode = "managed"
	DvrCapabilitiesSeriesModeNone      DvrCapabilitiesSeriesMode = "none"
)

// Defines values for EPGConfigSource.
const (
	EPGConfigSourceBouquet    EPGConfigSource = "bouquet"
	EPGConfigSourcePerService EPGConfigSource = "per-service"
)

// Defines values for EPGStatusStatus.
const (
	EPGStatusStatusMissing EPGStatusStatus = "missing"
	EPGStatusStatusOk      EPGStatusStatus = "ok"
)

// Defines values for IntentRequestHwaccel.
const (
	Auto  IntentRequestHwaccel = "auto"
	Force IntentRequestHwaccel = "force"
	Off   IntentRequestHwaccel = "off"
)

// Defines values for IntentRequestType.
const (
	StreamStart IntentRequestType = "stream.start"
	StreamStop  IntentRequestType = "stream.stop"
)

// Defines values for PlaybackCapabilitiesHlsEngines.
const (
	PlaybackCapabilitiesHlsEnginesHlsjs  PlaybackCapabilitiesHlsEngines = "hlsjs"
	PlaybackCapabilitiesHlsEnginesNative PlaybackCapabilitiesHlsEngines = "native"
)

// Defines values for PlaybackDecisionMode.
const (
	Deny         PlaybackDecisionMode = "deny"
	DirectPlay   PlaybackDecisionMode = "direct_play"
	DirectStream PlaybackDecisionMode = "direct_stream"
	Transcode    PlaybackDecisionMode = "transcode"
)

// Defines values for PlaybackDecisionSelectedOutputKind.
const (
	PlaybackDecisionSelectedOutputKindFile PlaybackDecisionSelectedOutputKind = "file"
	PlaybackDecisionSelectedOutputKindHls  PlaybackDecisionSelectedOutputKind = "hls"
)

// Defines values for PlaybackFeedbackRequestEvent.
const (
	PlaybackFeedbackRequestEventError   PlaybackFeedbackRequestEvent = "error"
	PlaybackFeedbackRequestEventInfo    PlaybackFeedbackRequestEvent = "info"
	PlaybackFeedbackRequestEventWarning PlaybackFeedbackRequestEvent = "warning"
)

// Defines values for PlaybackInfoDurationConfidence.
const (
	High   PlaybackInfoDurationConfidence = "high"
	Low    PlaybackInfoDurationConfidence = "low"
	Medium PlaybackInfoDurationConfidence = "medium"
)

// Defines values for PlaybackInfoDurationReason.
const (
	DurationContainerMissing    PlaybackInfoDurationReason = "duration_container_missing"
	DurationFromContainer       PlaybackInfoDurationReason = "duration_from_container"
	DurationFromFfprobe         PlaybackInfoDurationReason = "duration_from_ffprobe"
	DurationFromHeuristic       PlaybackInfoDurationReason = "duration_from_heuristic"
	DurationFromSourceMetadata  PlaybackInfoDurationReason = "duration_from_source_metadata"
	DurationInconsistentClamped PlaybackInfoDurationReason = "duration_inconsistent_clamped"
	DurationPrimaryMissing      PlaybackInfoDurationReason = "duration_primary_missing"
	DurationProbeFailed         PlaybackInfoDurationReason = "duration_probe_failed"
	DurationUnknownDeniedSeek   PlaybackInfoDurationReason = "duration_unknown_denied_seek"
	ResumeClampedToDuration     PlaybackInfoDurationReason = "resume_clamped_to_duration"
)

// Defines values for PlaybackInfoDurationSource.
const (
	PlaybackInfoDurationSourceContainer      PlaybackInfoDurationSource = "container"
	PlaybackInfoDurationSourceFfprobe        PlaybackInfoDurationSource = "ffprobe"
	PlaybackInfoDurationSourceHeuristic      PlaybackInfoDurationSource = "heuristic"
	PlaybackInfoDurationSourceSourceMetadata PlaybackInfoDurationSource = "source_metadata"
	PlaybackInfoDurationSourceUnknown        PlaybackInfoDurationSource = "unknown"
)

// Defines values for PlaybackInfoMode.
const (
	PlaybackInfoModeDeny      PlaybackInfoMode = "deny"
	PlaybackInfoModeDirectMp4 PlaybackInfoMode = "direct_mp4"
	PlaybackInfoModeHlsjs     PlaybackInfoMode = "hlsjs"
	PlaybackInfoModeNativeHls PlaybackInfoMode = "native_hls"
	PlaybackInfoModeTranscode PlaybackInfoMode = "transcode"
)

// Defines values for PlaybackInfoReason.
const (
	PlaybackInfoReasonAudioCodecNotSupportedByClient PlaybackInfoReason = "audio_codec_not_supported_by_client"
	PlaybackInfoReasonContainerNotSupportedByClient  PlaybackInfoReason = "container_not_supported_by_client"
	PlaybackInfoReasonDecisionAmbiguous              PlaybackInfoReason = "decision_ambiguous"
	PlaybackInfoReasonDirectplayMatch                PlaybackInfoReason = "directplay_match"
	PlaybackInfoReasonDirectstreamMatch              PlaybackInfoReason = "directstream_match"
	PlaybackInfoReasonHlsNotSupportedByClient        PlaybackInfoReason = "hls_not_supported_by_client"
	PlaybackInfoReasonNoCompatiblePlaybackPath       PlaybackInfoReason = "no_compatible_playback_path"
	PlaybackInfoReasonPolicyDeniesTranscode          PlaybackInfoReason = "policy_denies_transcode"
	PlaybackInfoReasonUnknown                        PlaybackInfoReason = "unknown"
	PlaybackInfoReasonVideoCodecNotSupportedByClient PlaybackInfoReason = "video_codec_not_supported_by_client"
)

// Defines values for PlaybackOutputFileKind.
const (
	PlaybackOutputFileKindFile PlaybackOutputFileKind = "file"
)

// Defines values for PlaybackOutputHlsKind.
const (
	Hls PlaybackOutputHlsKind = "hls"
)

// Defines values for ProblemCapabilitiesInvalidCode.
const (
	CapabilitiesInvalid ProblemCapabilitiesInvalidCode = "capabilities_invalid"
)

// Defines values for ProblemCapabilitiesMissingCode.
const (
	CapabilitiesMissing ProblemCapabilitiesMissingCode = "capabilities_missing"
)

// Defines values for ProblemDecisionAmbiguousCode.
const (
	DecisionAmbiguous ProblemDecisionAmbiguousCode = "decision_ambiguous"
)

// Defines values for RecordingBuildStatusAttemptMode.
const (
	Fast   RecordingBuildStatusAttemptMode = "fast"
	Robust RecordingBuildStatusAttemptMode = "robust"
)

// Defines values for RecordingBuildStatusState.
const (
	RecordingBuildStatusStateFAILED  RecordingBuildStatusState = "FAILED"
	RecordingBuildStatusStateIDLE    RecordingBuildStatusState = "IDLE"
	RecordingBuildStatusStateREADY   RecordingBuildStatusState = "READY"
	RecordingBuildStatusStateRUNNING RecordingBuildStatusState = "RUNNING"
)

// Defines values for RecordingItemStatus.
const (
	RecordingItemStatusCompleted RecordingItemStatus = "completed"
	RecordingItemStatusDeleting  RecordingItemStatus = "deleting"
	RecordingItemStatusFailed    RecordingItemStatus = "failed"
	RecordingItemStatusPending   RecordingItemStatus = "pending"
	RecordingItemStatusRecording RecordingItemStatus = "recording"
)

// Defines values for ScanStatusState.
const (
	ScanStatusStateCancelled ScanStatusState = "cancelled"
	ScanStatusStateComplete  ScanStatusState = "complete"
	ScanStatusStateFailed    ScanStatusState = "failed"
	ScanStatusStateIdle      ScanStatusState = "idle"
	ScanStatusStateRunning   ScanStatusState = "running"
)

// Defines values for SeriesRuleRunReportStatus.
const (
	Failed  SeriesRuleRunReportStatus = "failed"
	Partial SeriesRuleRunReportStatus = "partial"
	Success SeriesRuleRunReportStatus = "success"
)

// Defines values for SessionRecordReason.
const (
	SessionRecordReasonRBADREQUEST         SessionRecordReason = "R_BAD_REQUEST"
	SessionRecordReasonRCANCELLED          SessionRecordReason = "R_CANCELLED"
	SessionRecordReasonRCLIENTSTOP         SessionRecordReason = "R_CLIENT_STOP"
	SessionRecordReasonRFFMPEGSTARTFAILED  SessionRecordReason = "R_FFMPEG_START_FAILED"
	SessionRecordReasonRIDLETIMEOUT        SessionRecordReason = "R_IDLE_TIMEOUT"
	SessionRecordReasonRINVARIANTVIOLATION SessionRecordReason = "R_INVARIANT_VIOLATION"
	SessionRecordReasonRLEASEBUSY          SessionRecordReason = "R_LEASE_BUSY"
	SessionRecordReasonRLEASEEXPIRED       SessionRecordReason = "R_LEASE_EXPIRED"
	SessionRecordReasonRNONE               SessionRecordReason = "R_NONE"
	SessionRecordReasonRNOTFOUND           SessionRecordReason = "R_NOT_FOUND"
	SessionRecordReasonRPACKAGERFAILED     SessionRecordReason = "R_PACKAGER_FAILED"
	SessionRecordReasonRPROCESSENDED       SessionRecordReason = "R_PROCESS_ENDED"
	SessionRecordReasonRTUNEFAILED         SessionRecordReason = "R_TUNE_FAILED"
	SessionRecordReasonRTUNETIMEOUT        SessionRecordReason = "R_TUNE_TIMEOUT"
	SessionRecordReasonRUNKNOWN            SessionRecordReason = "R_UNKNOWN"
)

// Defines values for SessionRecordState.
const (
	SessionRecordStateCANCELLED SessionRecordState = "CANCELLED"
	SessionRecordStateDRAINING  SessionRecordState = "DRAINING"
	SessionRecordStateFAILED    SessionRecordState = "FAILED"
	SessionRecordStateNEW       SessionRecordState = "NEW"
	SessionRecordStatePRIMING   SessionRecordState = "PRIMING"
	SessionRecordStateREADY     SessionRecordState = "READY"
	SessionRecordStateSTARTING  SessionRecordState = "STARTING"
	SessionRecordStateSTOPPED   SessionRecordState = "STOPPED"
	SessionRecordStateSTOPPING  SessionRecordState = "STOPPING"
)

// Defines values for SessionResponseMode.
const (
	LIVE      SessionResponseMode = "LIVE"
	RECORDING SessionResponseMode = "RECORDING"
)

// Defines values for SessionResponseReason.
const (
	SessionResponseReasonRBADREQUEST         SessionResponseReason = "R_BAD_REQUEST"
	SessionResponseReasonRCANCELLED          SessionResponseReason = "R_CANCELLED"
	SessionResponseReasonRCLIENTSTOP         SessionResponseReason = "R_CLIENT_STOP"
	SessionResponseReasonRFFMPEGSTARTFAILED  SessionResponseReason = "R_FFMPEG_START_FAILED"
	SessionResponseReasonRIDLETIMEOUT        SessionResponseReason = "R_IDLE_TIMEOUT"
	SessionResponseReasonRINVARIANTVIOLATION SessionResponseReason = "R_INVARIANT_VIOLATION"
	SessionResponseReasonRLEASEBUSY          SessionResponseReason = "R_LEASE_BUSY"
	SessionResponseReasonRLEASEEXPIRED       SessionResponseReason = "R_LEASE_EXPIRED"
	SessionResponseReasonRNONE               SessionResponseReason = "R_NONE"
	SessionResponseReasonRNOTFOUND           SessionResponseReason = "R_NOT_FOUND"
	SessionResponseReasonRPACKAGERFAILED     SessionResponseReason = "R_PACKAGER_FAILED"
	SessionResponseReasonRPROCESSENDED       SessionResponseReason = "R_PROCESS_ENDED"
	SessionResponseReasonRTUNEFAILED         SessionResponseReason = "R_TUNE_FAILED"
	SessionResponseReasonRTUNETIMEOUT        SessionResponseReason = "R_TUNE_TIMEOUT"
	SessionResponseReasonRUNKNOWN            SessionResponseReason = "R_UNKNOWN"
)

// Defines values for SessionResponseState.
const (
	ACTIVE    SessionResponseState = "ACTIVE"
	BUFFERING SessionResponseState = "BUFFERING"
	CANCELLED SessionResponseState = "CANCELLED"
	DRAINING  SessionResponseState = "DRAINING"
	ENDING    SessionResponseState = "ENDING"
	ERROR     SessionResponseState = "ERROR"
	FAILED    SessionResponseState = "FAILED"
	IDLE      SessionResponseState = "IDLE"
	NEW       SessionResponseState = "NEW"
	PRIMING   SessionResponseState = "PRIMING"
	READY     SessionResponseState = "READY"
	STALLED   SessionResponseState = "STALLED"
	STARTING  SessionResponseState = "STARTING"
	STOPPED   SessionResponseState = "STOPPED"
	STOPPING  SessionResponseState = "STOPPING"
)

// Defines values for StorageItemAccess.
const (
	StorageItemAccessNone StorageItemAccess = "none"
	StorageItemAccessRo   StorageItemAccess = "ro"
	StorageItemAccessRw   StorageItemAccess = "rw"
)

// Defines values for StorageItemHealthStatus.
const (
	StorageItemHealthStatusError   StorageItemHealthStatus = "error"
	StorageItemHealthStatusOk      StorageItemHealthStatus = "ok"
	StorageItemHealthStatusSkipped StorageItemHealthStatus = "skipped"
	StorageItemHealthStatusTimeout StorageItemHealthStatus = "timeout"
	StorageItemHealthStatusUnknown StorageItemHealthStatus = "unknown"
)

// Defines values for StorageItemMountStatus.
const (
	StorageItemMountStatusMounted   StorageItemMountStatus = "mounted"
	StorageItemMountStatusUnknown   StorageItemMountStatus = "unknown"
	StorageItemMountStatusUnmounted StorageItemMountStatus = "unmounted"
)

// Defines values for StreamSessionState.
const (
	StreamSessionStateActive    StreamSessionState = "active"
	StreamSessionStateBuffering StreamSessionState = "buffering"
	StreamSessionStateEnding    StreamSessionState = "ending"
	StreamSessionStateError     StreamSessionState = "error"
	StreamSessionStateIdle      StreamSessionState = "idle"
	StreamSessionStateStalled   StreamSessionState = "stalled"
	StreamSessionStateStarting  StreamSessionState = "starting"
)

// Defines values for StreamingConfigDeliveryPolicy.
const (
	Universal StreamingConfigDeliveryPolicy = "universal"
)

// Defines values for SystemHealthStatus.
const (
	Degraded SystemHealthStatus = "degraded"
	Error    SystemHealthStatus = "error"
	Ok       SystemHealthStatus = "ok"
)

// Defines values for TimerState.
const (
	TimerStateCompleted TimerState = "completed"
	TimerStateDisabled  TimerState = "disabled"
	TimerStateRecording TimerState = "recording"
	TimerStateScheduled TimerState = "scheduled"
	TimerStateUnknown   TimerState = "unknown"
)

// Defines values for TimerConflictType.
const (
	Duplicate  TimerConflictType = "duplicate"
	Overlap    TimerConflictType = "overlap"
	TunerLimit TimerConflictType = "tuner_limit"
	Unknown    TimerConflictType = "unknown"
)

// Defines values for TimerConflictPreviewRequestMode.
const (
	Conservative  TimerConflictPreviewRequestMode = "conservative"
	ReceiverAware TimerConflictPreviewRequestMode = "receiverAware"
)

// Defines values for TimerConflictPreviewResponseSuggestionsKind.
const (
	ReducePadding TimerConflictPreviewResponseSuggestionsKind = "reduce_padding"
	ShiftEnd      TimerConflictPreviewResponseSuggestionsKind = "shift_end"
	ShiftStart    TimerConflictPreviewResponseSuggestionsKind = "shift_start"
)

// Defines values for TimerCreateRequestAfterEvent.
const (
	Deepstandby TimerCreateRequestAfterEvent = "deepstandby"
	Default     TimerCreateRequestAfterEvent = "default"
	Nothing     TimerCreateRequestAfterEvent = "nothing"
	Standby     TimerCreateRequestAfterEvent = "standby"
)

// APIError defines model for APIError.
type APIError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Optional additional context
	Details interface{} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Request ID for debugging
	RequestId string `json:"requestId"`
}

// AppConfig defines model for AppConfig.
type AppConfig struct {
	Bouquets  *[]string        `json:"bouquets,omitempty"`
	DataDir   *string          `json:"dataDir,omitempty"`
	Epg       *EPGConfig       `json:"epg,omitempty"`
	LogLevel  *string          `json:"logLevel,omitempty"`
	OpenWebIF *OpenWebIFConfig `json:"openWebIF,omitempty"`
	Picons    *PiconsConfig    `json:"picons,omitempty"`

	// Streaming Streaming delivery policy configuration (ADR-00X)
	Streaming    *StreamingConfig    `json:"streaming,omitempty"`
	Verification *VerificationConfig `json:"verification,omitempty"`
	Version      *string             `json:"version,omitempty"`
}

// Bouquet defines model for Bouquet.
type Bouquet struct {
	Name     *string `json:"name,omitempty"`
	Services *int    `json:"services,omitempty"`
}

// Breadcrumb defines model for Breadcrumb.
type Breadcrumb struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// ComponentStatus defines model for ComponentStatus.
type ComponentStatus struct {
	LastCheck *time.Time             `json:"lastCheck,omitempty"`
	Status    *ComponentStatusStatus `json:"status,omitempty"`
}

// ComponentStatusStatus defines model for ComponentStatus.Status.
type ComponentStatusStatus string

// ConfigUpdate defines model for ConfigUpdate.
type ConfigUpdate struct {
	Bouquets *[]string  `json:"bouquets,omitempty"`
	Epg      *EPGConfig `json:"epg,omitempty"`

	// LogLevel Log level to set (debug, info, warn, error)
	LogLevel     *string             `json:"logLevel,omitempty"`
	OpenWebIF    *OpenWebIFConfig    `json:"openWebIF,omitempty"`
	Picons       *PiconsConfig       `json:"picons,omitempty"`
	Verification *VerificationConfig `json:"verification,omitempty"`
}

// CurrentServiceInfo Current live service and EPG information from receiver
type CurrentServiceInfo struct {
	Channel *struct {
		Name *string `json:"name,omitempty"`
		Ref  *string `json:"ref,omitempty"`
	} `json:"channel,omitempty"`
	Next *struct {
		Title *string `json:"title,omitempty"`
	} `json:"next,omitempty"`
	Now *struct {
		BeginTimestamp *int64  `json:"beginTimestamp,omitempty"`
		Description    *string `json:"description,omitempty"`
		DurationSec    *int    `json:"durationSec,omitempty"`
		Title          *string `json:"title,omitempty"`
	} `json:"now,omitempty"`
	Status *CurrentServiceInfoStatus `json:"status,omitempty"`
}

// CurrentServiceInfoStatus defines model for CurrentServiceInfo.Status.
type CurrentServiceInfoStatus string

// DirectoryItem defines model for DirectoryItem.
type DirectoryItem struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// DvrCapabilities defines model for DvrCapabilities.
type DvrCapabilities struct {
	Conflicts struct {
		Preview       *bool `json:"preview,omitempty"`
		ReceiverAware *bool `json:"receiverAware,omitempty"`
	} `json:"conflicts"`
	Series struct {
		DelegatedProvider *string                    `json:"delegatedProvider,omitempty"`
		Mode              *DvrCapabilitiesSeriesMode `json:"mode,omitempty"`
		Supported         *bool                      `json:"supported,omitempty"`
	} `json:"series"`
	Timers struct {
		Delete         *bool `json:"delete,omitempty"`
		Edit           *bool `json:"edit,omitempty"`
		ReadBackVerify *bool `json:"readBackVerify,omitempty"`
	} `json:"timers"`
}

// DvrCapabilitiesSeriesMode defines model for DvrCapabilities.Series.Mode.
type DvrCapabilitiesSeriesMode string

// EPGConfig defines model for EPGConfig.
type EPGConfig struct {
	Days    *int             `json:"days,omitempty"`
	Enabled *bool            `json:"enabled,omitempty"`
	Source  *EPGConfigSource `json:"source,omitempty"`
}

// EPGConfigSource defines model for EPGConfig.Source.
type EPGConfigSource string

// EPGStatus defines model for EPGStatus.
type EPGStatus struct {
	MissingChannels *int             `json:"missingChannels,omitempty"`
	Status          *EPGStatusStatus `json:"status,omitempty"`
}

// EPGStatusStatus defines model for EPGStatus.Status.
type EPGStatusStatus string

// IntentRequest defines model for IntentRequest.
type IntentRequest struct {
	// CorrelationId Optional correlation ID for end-to-end tracing
	CorrelationId *string `json:"correlationId,omitempty"`

	// Hwaccel Hardware acceleration override (v3.1+).
	// - auto: Server decides based on GPU availability
	// - force: Force GPU encoding (fails if no GPU)
	// - off: Force CPU encoding
	Hwaccel *IntentRequestHwaccel `json:"hwaccel,omitempty"`

	// IdempotencyKey Optional idempotency key for at-most-once semantics
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`

	// Params Additional parameters.
	// Live playback attestation keys:
	// - canonical: playback_decision_token
	// - deprecated alias: playback_decision_id (temporary compatibility)
	// Conflict rule:
	// - if both keys are present and values differ, request is rejected with HTTP 400 (code INVALID_INPUT)
	Params *map[string]string `json:"params,omitempty"`

	// ServiceRef Required for stream.start. Enigma2 service reference (live playback only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// SessionId Required for stream.stop intent
	SessionId *openapi_types.UUID `json:"sessionId,omitempty"`
	Type      *IntentRequestType  `json:"type,omitempty"`
}

// IntentRequestHwaccel Hardware acceleration override (v3.1+).
// - auto: Server decides based on GPU availability
// - force: Force GPU encoding (fails if no GPU)
// - off: Force CPU encoding
type IntentRequestHwaccel string

// IntentRequestType defines model for IntentRequest.Type.
type IntentRequestType string

// LivePlaybackInfoRequest defines model for LivePlaybackInfoRequest.
type LivePlaybackInfoRequest struct {
	// Capabilities Client capabilities for playback decision (P4-1)
	Capabilities PlaybackCapabilities `json:"capabilities"`

	// ServiceRef Live service reference to evaluate.
	ServiceRef string `json:"serviceRef"`
}

// LogEntry defines model for LogEntry.
type LogEntry struct {
	Fields  *map[string]interface{} `json:"fields,omitempty"`
	Level   *string                 `json:"level,omitempty"`
	Message *string                 `json:"message,omitempty"`
	Time    *time.Time              `json:"time,omitempty"`
}

// NowNextEntry defines model for NowNextEntry.
type NowNextEntry struct {
	// End Unix timestamp (seconds)
	End int `json:"end"`

	// Start Unix timestamp (seconds)
	Start int    `json:"start"`
	Title string `json:"title"`
}

// NowNextItem defines model for NowNextItem.
type NowNextItem struct {
	Next       *NowNextEntry `json:"next,omitempty"`
	Now        *NowNextEntry `json:"now,omitempty"`
	ServiceRef string        `json:"serviceRef"`
}

// NowNextRequest defines model for NowNextRequest.
type NowNextRequest struct {
	Services []string `json:"services"`
}

// NowNextResponse defines model for NowNextResponse.
type NowNextResponse struct {
	Items []NowNextItem `json:"items"`
}

// OpenWebIFConfig defines model for OpenWebIFConfig.
type OpenWebIFConfig struct {
	BaseUrl    *string `json:"baseUrl,omitempty"`
	Password   *string `json:"password,omitempty"`
	StreamPort *int    `json:"streamPort,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// PiconsConfig defines model for PiconsConfig.
type PiconsConfig struct {
	BaseUrl *string `json:"baseUrl,omitempty"`
}

// PlaybackCapabilities Client capabilities for playback decision (P4-1)
type PlaybackCapabilities struct {
	// AllowTranscode Whether client allows transcoding (force bypass)
	AllowTranscode *bool `json:"allowTranscode,omitempty"`

	// AudioCodecs Supported audio codecs
	AudioCodecs []string `json:"audioCodecs"`

	// CapabilitiesVersion Capabilities contract version (current: 1)
	CapabilitiesVersion int `json:"capabilitiesVersion"`

	// Container Supported container formats
	Container []string `json:"container"`

	// DeviceType Client device category for policy decisions
	DeviceType *string `json:"deviceType,omitempty"`

	// HlsEngines Available HLS playback engines measured by the client runtime.
	HlsEngines *[]PlaybackCapabilitiesHlsEngines `json:"hlsEngines,omitempty"`

	// MaxVideo Optional resolution/FPS constraints
	MaxVideo *struct {
		Fps    *int `json:"fps,omitempty"`
		Height *int `json:"height,omitempty"`
		Width  *int `json:"width,omitempty"`
	} `json:"maxVideo,omitempty"`

	// SupportsHls Whether client supports HLS playlists
	SupportsHls *bool `json:"supportsHls,omitempty"`

	// SupportsRange Whether client supports HTTP range requests
	SupportsRange *bool `json:"supportsRange,omitempty"`

	// VideoCodecs Supported video codecs
	VideoCodecs []string `json:"videoCodecs"`
}

// PlaybackCapabilitiesHlsEngines defines model for PlaybackCapabilities.HlsEngines.
type PlaybackCapabilitiesHlsEngines string

// PlaybackDecision Complete playback decision from backend (P4-1)
type PlaybackDecision struct {
	// Constraints Applied constraints (e.g., downscale_required)
	Constraints []string `json:"constraints"`

	// Mode Playback mode decision
	Mode PlaybackDecisionMode `json:"mode"`

	// Outputs Available output URLs/playlists
	Outputs []PlaybackOutput `json:"outputs"`

	// Reasons Machine-readable decision reason codes
	Reasons []string `json:"reasons"`

	// Selected Selected output format
	Selected struct {
		AudioCodec string `json:"audioCodec"`
		Container  string `json:"container"`
		VideoCodec string `json:"videoCodec"`
	} `json:"selected"`

	// SelectedOutputKind The explicitly selected playback kind. Omitted for deny.
	SelectedOutputKind *PlaybackDecisionSelectedOutputKind `json:"selectedOutputKind"`

	// SelectedOutputUrl The explicitly selected playback URL (backend-driven). Omitted for deny.
	SelectedOutputUrl *string `json:"selectedOutputUrl"`

	// Trace Traceability information
	Trace PlaybackTrace `json:"trace"`
}

// PlaybackDecisionMode Playback mode decision
type PlaybackDecisionMode string

// PlaybackDecisionSelectedOutputKind The explicitly selected playback kind. Omitted for deny.
type PlaybackDecisionSelectedOutputKind string

// PlaybackFeedbackRequest defines model for PlaybackFeedbackRequest.
type PlaybackFeedbackRequest struct {
	// Code MediaError code if applicable
	Code    *int                         `json:"code,omitempty"`
	Details *map[string]interface{}      `json:"details,omitempty"`
	Event   PlaybackFeedbackRequestEvent `json:"event"`
	Message *string                      `json:"message,omitempty"`
}

// PlaybackFeedbackRequestEvent defines model for PlaybackFeedbackRequest.Event.
type PlaybackFeedbackRequestEvent string

// PlaybackInfo defines model for PlaybackInfo.
type PlaybackInfo struct {
	// AudioCodec Truthful audio codec if known (e.g., aac, ac3, mp2).
	AudioCodec *string `json:"audioCodec,omitempty"`

	// Container Truthful container name if known (e.g., ts, mp4, mkv).
	Container *string `json:"container,omitempty"`

	// Decision Complete playback decision from backend (P4-1)
	Decision *PlaybackDecision `json:"decision,omitempty"`

	// DurationConfidence Confidence of the resolved duration.
	DurationConfidence *PlaybackInfoDurationConfidence `json:"durationConfidence,omitempty"`

	// DurationMs Authoritative finite duration in milliseconds. Omitted if unknown.
	DurationMs *int64 `json:"durationMs,omitempty"`

	// DurationReasons Machine-readable duration provenance/fallback reasons.
	DurationReasons *[]PlaybackInfoDurationReason `json:"durationReasons,omitempty"`

	// DurationSeconds Deprecated compatibility field. Prefer durationMs. Omitted if unknown or preparing.
	DurationSeconds *int64 `json:"durationSeconds,omitempty"`

	// DurationSource Source of the reported duration, when durationMs is present.
	DurationSource *PlaybackInfoDurationSource `json:"durationSource,omitempty"`

	// DvrWindowSeconds Absolute DVR window length in seconds. Becomes required in P3-4.
	DvrWindowSeconds *int64 `json:"dvrWindowSeconds,omitempty"`

	// IsSeekable Authoritative flag if the stream is seekable. Becomes required in P3-4.
	IsSeekable *bool `json:"isSeekable,omitempty"`

	// LiveEdgeUnix wall-clock timestamp (UNIX) of the latest segment. Becomes required in P3-4.
	LiveEdgeUnix *int64 `json:"liveEdgeUnix,omitempty"`

	// Mode Backend-selected playback execution mode.
	Mode PlaybackInfoMode `json:"mode"`

	// PlaybackDecisionToken Signed short-lived attestation token required when submitting live playback_mode to /intents.
	PlaybackDecisionToken *string `json:"playbackDecisionToken,omitempty"`

	// Reason Reason for the playback decision.
	Reason *PlaybackInfoReason `json:"reason,omitempty"`

	// RequestId Correlation ID for the request. Mandatory in P3-1.
	RequestId string         `json:"requestId"`
	Resume    *ResumeSummary `json:"resume,omitempty"`

	// Seekable Whether the stream is seekable. Omitted if unknown. Deprecated in favor of isSeekable.
	Seekable *bool `json:"seekable,omitempty"`

	// SessionId Unique ID for the stream session. Mandatory in P3-1.
	SessionId string `json:"sessionId"`

	// StartUnix wall-clock timestamp (UNIX) of the earliest segment in window. Becomes required in P3-4.
	StartUnix *int64 `json:"startUnix,omitempty"`

	// Url Relative URL selected by backend playback decision (manifest or media URL). Optional for deny.
	Url *string `json:"url,omitempty"`

	// VideoCodec Truthful video codec if known (e.g., h264, hevc, mpeg2).
	VideoCodec *string `json:"videoCodec,omitempty"`
}

// PlaybackInfoDurationConfidence Confidence of the resolved duration.
type PlaybackInfoDurationConfidence string

// PlaybackInfoDurationReason Frozen duration reason vocabulary.
type PlaybackInfoDurationReason string

// PlaybackInfoDurationSource Source of the reported duration, when durationMs is present.
type PlaybackInfoDurationSource string

// PlaybackInfoMode Backend-selected playback execution mode.
type PlaybackInfoMode string

// PlaybackInfoReason Reason for the playback decision.
type PlaybackInfoReason string

// PlaybackOutput Output URL for client playback
type PlaybackOutput struct {
	union json.RawMessage
}

// PlaybackOutputFile defines model for PlaybackOutputFile.
type PlaybackOutputFile struct {
	// Kind Static file output
	Kind PlaybackOutputFileKind `json:"kind"`

	// Url Direct playback URL
	Url string `json:"url"`
}

// PlaybackOutputFileKind Static file output
type PlaybackOutputFileKind string

// PlaybackOutputHls defines model for PlaybackOutputHls.
type PlaybackOutputHls struct {
	// Kind HLS stream output
	Kind PlaybackOutputHlsKind `json:"kind"`

	// PlaylistUrl Canonical HLS playlist URL (.m3u8)
	PlaylistUrl string `json:"playlistUrl"`

	// Url Alternate playback URL (optional)
	Url *string `json:"url,omitempty"`
}

// PlaybackOutputHlsKind HLS stream output
type PlaybackOutputHlsKind string

// PlaybackTrace Traceability information
type PlaybackTrace struct {
	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string  `json:"requestId"`
	SessionId *string `json:"sessionId"`
}

// ProblemCapabilitiesInvalid defines model for ProblemCapabilitiesInvalid.
type ProblemCapabilitiesInvalid struct {
	Code      *ProblemCapabilitiesInvalidCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict                `json:"conflicts,omitempty"`
	Detail    *string                         `json:"detail,omitempty"`
	Fields    *map[string]interface{}         `json:"fields,omitempty"`
	Instance  *string                         `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemCapabilitiesInvalidCode defines model for ProblemCapabilitiesInvalid.Code.
type ProblemCapabilitiesInvalidCode string

// ProblemCapabilitiesMissing defines model for ProblemCapabilitiesMissing.
type ProblemCapabilitiesMissing struct {
	Code      *ProblemCapabilitiesMissingCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict                `json:"conflicts,omitempty"`
	Detail    *string                         `json:"detail,omitempty"`
	Fields    *map[string]interface{}         `json:"fields,omitempty"`
	Instance  *string                         `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemCapabilitiesMissingCode defines model for ProblemCapabilitiesMissing.Code.
type ProblemCapabilitiesMissingCode string

// ProblemDecisionAmbiguous defines model for ProblemDecisionAmbiguous.
type ProblemDecisionAmbiguous struct {
	Code      *ProblemDecisionAmbiguousCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict              `json:"conflicts,omitempty"`
	Detail    *string                       `json:"detail,omitempty"`
	Fields    *map[string]interface{}       `json:"fields,omitempty"`
	Instance  *string                       `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemDecisionAmbiguousCode defines model for ProblemDecisionAmbiguous.Code.
type ProblemDecisionAmbiguousCode string

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	// Code Stable machine-readable short code (e.g. "NOT_FOUND")
	Code      *string                 `json:"code,omitempty"`
	Conflicts *[]TimerConflict        `json:"conflicts,omitempty"`
	Detail    *string                 `json:"detail,omitempty"`
	Fields    *map[string]interface{} `json:"fields,omitempty"`
	Instance  *string                 `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// RecordingBuildStatus defines model for RecordingBuildStatus.
type RecordingBuildStatus struct {
	AttemptMode  *RecordingBuildStatusAttemptMode `json:"attemptMode,omitempty"`
	Error        *string                          `json:"error,omitempty"`
	LastProgress *time.Time                       `json:"lastProgress,omitempty"`

	// ProgressiveReady True if a progressive (timeshift) playlist is playable.
	ProgressiveReady *bool `json:"progressiveReady,omitempty"`

	// RequestId Correlation ID for the request.
	RequestId    string                    `json:"requestId"`
	SegmentCount *int                      `json:"segmentCount,omitempty"`
	StartedAt    *time.Time                `json:"startedAt,omitempty"`
	State        RecordingBuildStatusState `json:"state"`
}

// RecordingBuildStatusAttemptMode defines model for RecordingBuildStatus.AttemptMode.
type RecordingBuildStatusAttemptMode string

// RecordingBuildStatusState defines model for RecordingBuildStatus.State.
type RecordingBuildStatusState string

// RecordingItem defines model for RecordingItem.
type RecordingItem struct {
	// BeginUnixSeconds Recording start time as UNIX seconds.
	BeginUnixSeconds *int64  `json:"beginUnixSeconds,omitempty"`
	Description      *string `json:"description,omitempty"`

	// DurationSeconds Recording duration in seconds, if known.
	DurationSeconds *int64  `json:"durationSeconds,omitempty"`
	Filename        *string `json:"filename,omitempty"`

	// Length Human-readable duration string for display only.
	Length *string `json:"length,omitempty"`

	// RecordingId Base64url-encoded recording ID (RFC 4648, unpadded) to use for /recordings/{recordingId}.
	RecordingId *string        `json:"recordingId,omitempty"`
	Resume      *ResumeSummary `json:"resume,omitempty"`

	// ServiceRef Legacy receiver service reference (read-only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// Status Consolidated recording status. Becomes required in P3-3.
	Status *RecordingItemStatus `json:"status,omitempty"`
	Title  *string              `json:"title,omitempty"`
}

// RecordingItemStatus Consolidated recording status. Becomes required in P3-3.
type RecordingItemStatus string

// RecordingResponse defines model for RecordingResponse.
type RecordingResponse struct {
	Breadcrumbs *[]Breadcrumb    `json:"breadcrumbs,omitempty"`
	CurrentPath *string          `json:"currentPath,omitempty"`
	CurrentRoot *string          `json:"currentRoot,omitempty"`
	Directories *[]DirectoryItem `json:"directories,omitempty"`
	Recordings  *[]RecordingItem `json:"recordings,omitempty"`

	// RequestId Correlation ID for the request.
	RequestId string           `json:"requestId"`
	Roots     *[]RecordingRoot `json:"roots,omitempty"`
}

// RecordingRoot defines model for RecordingRoot.
type RecordingRoot struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// RecordingStatus defines model for RecordingStatus.
type RecordingStatus struct {
	IsRecording bool    `json:"isRecording"`
	ServiceName *string `json:"serviceName,omitempty"`
}

// ResumeSummary defines model for ResumeSummary.
type ResumeSummary struct {
	DurationSeconds *int64     `json:"durationSeconds,omitempty"`
	Finished        *bool      `json:"finished,omitempty"`
	PosSeconds      int64      `json:"posSeconds"`
	UpdatedAt       *time.Time `json:"updatedAt,omitempty"`
}

// RuleSnapshot defines model for RuleSnapshot.
type RuleSnapshot struct {
	ChannelRef  *string `json:"channelRef,omitempty"`
	Days        *[]int  `json:"days,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Id          *string `json:"id,omitempty"`
	Keyword     *string `json:"keyword,omitempty"`
	Priority    *int    `json:"priority,omitempty"`
	StartWindow *string `json:"startWindow,omitempty"`
}

// RunConflict defines model for RunConflict.
type RunConflict struct {
	Begin           *int64  `json:"begin,omitempty"`
	BlockingTimerId *string `json:"blockingTimerId,omitempty"`
	End             *int64  `json:"end,omitempty"`
	Message         *string `json:"message,omitempty"`
	OverlapSeconds  *int64  `json:"overlapSeconds,omitempty"`
	ServiceRef      *string `json:"serviceRef,omitempty"`
	Title           *string `json:"title,omitempty"`
}

// RunDecision defines model for RunDecision.
type RunDecision struct {
	Action      *string   `json:"action,omitempty"`
	Begin       *int64    `json:"begin,omitempty"`
	Details     *string   `json:"details,omitempty"`
	End         *int64    `json:"end,omitempty"`
	MatchReason *[]string `json:"matchReason,omitempty"`
	Reason      *string   `json:"reason,omitempty"`
	ServiceRef  *string   `json:"serviceRef,omitempty"`
	TimerId     *string   `json:"timerId,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// RunError defines model for RunError.
type RunError struct {
	At        *time.Time `json:"at,omitempty"`
	Message   *string    `json:"message,omitempty"`
	Retryable *bool      `json:"retryable,omitempty"`
	Type      *string    `json:"type,omitempty"`
}

// RunSummary defines model for RunSummary.
type RunSummary struct {
	EpgItemsMatched             *int  `json:"epgItemsMatched,omitempty"`
	EpgItemsScanned             *int  `json:"epgItemsScanned,omitempty"`
	MaxMatchesScannedPerRuleHit *bool `json:"maxMatchesScannedPerRuleHit,omitempty"`
	MaxTimersGlobalPerRunHit    *bool `json:"maxTimersGlobalPerRunHit,omitempty"`
	ReceiverUnreachable         *bool `json:"receiverUnreachable,omitempty"`
	TimersAttempted             *int  `json:"timersAttempted,omitempty"`
	TimersConflicted            *int  `json:"timersConflicted,omitempty"`
	TimersCreated               *int  `json:"timersCreated,omitempty"`
	TimersErrored               *int  `json:"timersErrored,omitempty"`
	TimersSkipped               *int  `json:"timersSkipped,omitempty"`
}

// ScanStatus defines model for ScanStatus.
type ScanStatus struct {
	// FinishedAt Unix timestamp of when the last scan completed
	FinishedAt *int64  `json:"finishedAt,omitempty"`
	LastError  *string `json:"lastError,omitempty"`

	// ScannedChannels Number of attempts (successful/failed) to probe channels so far
	ScannedChannels *int `json:"scannedChannels,omitempty"`

	// StartedAt Unix timestamp of when the current or last scan started
	StartedAt *int64           `json:"startedAt,omitempty"`
	State     *ScanStatusState `json:"state,omitempty"`

	// TotalChannels Total number of channels in the playlist
	TotalChannels *int `json:"totalChannels,omitempty"`

	// UpdatedCount Number of capabilities successfully updated in the store
	UpdatedCount *int `json:"updatedCount,omitempty"`
}

// ScanStatusState defines model for ScanStatus.State.
type ScanStatusState string

// SeriesRule defines model for SeriesRule.
type SeriesRule struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channelRef,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int  `json:"days,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Id      *string `json:"id,omitempty"`

	// Keyword Search term or regex for event title
	Keyword        *string     `json:"keyword,omitempty"`
	LastRunAt      *time.Time  `json:"lastRunAt,omitempty"`
	LastRunStatus  *string     `json:"lastRunStatus,omitempty"`
	LastRunSummary *RunSummary `json:"lastRunSummary,omitempty"`
	Priority       *int        `json:"priority,omitempty"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"startWindow,omitempty"`
}

// SeriesRuleRunReport defines model for SeriesRuleRunReport.
type SeriesRuleRunReport struct {
	Conflicts  *[]RunConflict             `json:"conflicts,omitempty"`
	Decisions  *[]RunDecision             `json:"decisions,omitempty"`
	DurationMs *int64                     `json:"durationMs,omitempty"`
	Errors     *[]RunError                `json:"errors,omitempty"`
	FinishedAt *time.Time                 `json:"finishedAt,omitempty"`
	RuleId     *string                    `json:"ruleId,omitempty"`
	RunId      *string                    `json:"runId,omitempty"`
	Snapshot   *RuleSnapshot              `json:"snapshot,omitempty"`
	StartedAt  *time.Time                 `json:"startedAt,omitempty"`
	Status     *SeriesRuleRunReportStatus `json:"status,omitempty"`
	Summary    *RunSummary                `json:"summary,omitempty"`
	Trigger    *string                    `json:"trigger,omitempty"`
	WindowFrom *int64                     `json:"windowFrom,omitempty"`
	WindowTo   *int64                     `json:"windowTo,omitempty"`
}

// SeriesRuleRunReportStatus defines model for SeriesRuleRunReport.Status.
type SeriesRuleRunReportStatus string

// SeriesRuleUpdate defines model for SeriesRuleUpdate.
type SeriesRuleUpdate struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channelRef,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int `json:"days,omitempty"`
	Enabled bool   `json:"enabled"`

	// Keyword Search term or regex for event title
	Keyword  string `json:"keyword"`
	Priority int    `json:"priority"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"startWindow,omitempty"`
}

// Service defines model for Service.
type Service struct {
	// Codec Video codec (e.g. h264)
	Codec   *string `json:"codec,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Group   *string `json:"group,omitempty"`
	Id      *string `json:"id,omitempty"`
	LogoUrl *string `json:"logoUrl,omitempty"`
	Name    *string `json:"name,omitempty"`
	Number  *string `json:"number,omitempty"`

	// Resolution Video resolution (e.g. 1920x1080)
	Resolution *string `json:"resolution,omitempty"`

	// ServiceRef Service reference for streaming (extracted from M3U URL)
	ServiceRef *string `json:"serviceRef,omitempty"`
}

// SessionRecord defines model for SessionRecord.
type SessionRecord struct {
	ContextData    *map[string]string      `json:"contextData,omitempty"`
	CorrelationId  *string                 `json:"correlationId,omitempty"`
	CreatedAtUnix  *int64                  `json:"createdAtUnix,omitempty"`
	LastAccessUnix *int64                  `json:"lastAccessUnix,omitempty"`
	Profile        *map[string]interface{} `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionRecordReason `json:"reason,omitempty"`
	ReasonDetail *string              `json:"reasonDetail,omitempty"`
	ServiceRef   *string              `json:"serviceRef,omitempty"`
	SessionId    *openapi_types.UUID  `json:"sessionId,omitempty"`

	// State Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
	// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
	State         *SessionRecordState `json:"state,omitempty"`
	TunerID       *string             `json:"tunerID,omitempty"`
	UpdatedAtUnix *int64              `json:"updatedAtUnix,omitempty"`
}

// SessionRecordReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionRecordReason string

// SessionRecordState Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
type SessionRecordState string

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	CorrelationId *string `json:"correlationId,omitempty"`

	// DurationSeconds DVR window length for live sessions, in seconds.
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// LiveEdgeSeconds Current live edge position in seconds (live only).
	LiveEdgeSeconds *float32 `json:"liveEdgeSeconds,omitempty"`

	// Mode Playback mode for the session.
	Mode *SessionResponseMode `json:"mode,omitempty"`

	// PlaybackUrl Playback URL for the HLS playlist.
	PlaybackUrl *string `json:"playbackUrl,omitempty"`
	Profile     *string `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionResponseReason `json:"reason,omitempty"`
	ReasonDetail *string                `json:"reasonDetail,omitempty"`

	// RequestId Request ID for debugging/tracing. Mandatory in P3-1.
	RequestId string `json:"requestId"`

	// SeekableEndSeconds Latest seekable position in seconds.
	SeekableEndSeconds *float32 `json:"seekableEndSeconds,omitempty"`

	// SeekableStartSeconds Earliest seekable position in seconds.
	SeekableStartSeconds *float32           `json:"seekableStartSeconds,omitempty"`
	ServiceRef           *string            `json:"serviceRef,omitempty"`
	SessionId            openapi_types.UUID `json:"sessionId"`

	// State Session lifecycle state. STARTING guarantees a session ticket is allocated.
	// READY/ACTIVE guarantees a playable HLS stream.
	State       SessionResponseState `json:"state"`
	UpdatedAtMs *int                 `json:"updatedAtMs,omitempty"`
}

// SessionResponseMode Playback mode for the session.
type SessionResponseMode string

// SessionResponseReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionResponseReason string

// SessionResponseState Session lifecycle state. STARTING guarantees a session ticket is allocated.
// READY/ACTIVE guarantees a playable HLS stream.
type SessionResponseState string

// StorageItem defines model for StorageItem.
type StorageItem struct {
	// Access Access level detected during probe.
	Access    StorageItemAccess `json:"access"`
	Capacity  *string           `json:"capacity,omitempty"`
	CheckedAt *time.Time        `json:"checkedAt,omitempty"`
	FsType    *string           `json:"fsType,omitempty"`

	// HealthStatus Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
	HealthStatus StorageItemHealthStatus `json:"healthStatus"`
	IsNas        bool                    `json:"isNas"`
	Model        *string                 `json:"model,omitempty"`
	Mount        *string                 `json:"mount,omitempty"`
	MountStatus  StorageItemMountStatus  `json:"mountStatus"`
}

// StorageItemAccess Access level detected during probe.
type StorageItemAccess string

// StorageItemHealthStatus Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
type StorageItemHealthStatus string

// StorageItemMountStatus defines model for StorageItem.MountStatus.
type StorageItemMountStatus string

// StreamSession defines model for StreamSession.
type StreamSession struct {
	ChannelName *string `json:"channelName,omitempty"`
	ClientIp    *string `json:"clientIp,omitempty"`

	// Id Internal database ID (deprecated).
	Id      *string `json:"id,omitempty"`
	Program *struct {
		BeginTimestamp *int64  `json:"beginTimestamp,omitempty"`
		Description    *string `json:"description,omitempty"`
		DurationSec    *int    `json:"durationSec,omitempty"`
		Title          *string `json:"title,omitempty"`
	} `json:"program,omitempty"`

	// RequestId Correlation ID for the trace. Mandatory in P3-1.
	RequestId string `json:"requestId"`

	// SessionId Mandatory stream lifecycle ID (domain truth).
	SessionId openapi_types.UUID `json:"sessionId"`
	StartedAt *time.Time         `json:"startedAt,omitempty"`
	State     StreamSessionState `json:"state"`
}

// StreamSessionState defines model for StreamSession.State.
type StreamSessionState string

// StreamingConfig Streaming delivery policy configuration (ADR-00X)
type StreamingConfig struct {
	// DeliveryPolicy Streaming delivery policy (only 'universal' is supported)
	DeliveryPolicy *StreamingConfigDeliveryPolicy `json:"deliveryPolicy,omitempty"`
}

// StreamingConfigDeliveryPolicy Streaming delivery policy (only 'universal' is supported)
type StreamingConfigDeliveryPolicy string

// SystemHealth defines model for SystemHealth.
type SystemHealth struct {
	Epg           *EPGStatus          `json:"epg,omitempty"`
	Receiver      *ComponentStatus    `json:"receiver,omitempty"`
	Status        *SystemHealthStatus `json:"status,omitempty"`
	UptimeSeconds *int64              `json:"uptimeSeconds,omitempty"`
	Version       *string             `json:"version,omitempty"`
}

// SystemHealthStatus defines model for SystemHealth.Status.
type SystemHealthStatus string

// SystemInfoData defines model for SystemInfoData.
type SystemInfoData struct {
	Hardware *struct {
		Boxtype            *string `json:"boxtype,omitempty"`
		Brand              *string `json:"brand,omitempty"`
		Chipset            *string `json:"chipset,omitempty"`
		ChipsetDescription *string `json:"chipsetDescription,omitempty"`
		Model              *string `json:"model,omitempty"`
	} `json:"hardware,omitempty"`
	Network *struct {
		Interfaces *[]struct {
			Dhcp  *bool   `json:"dhcp,omitempty"`
			Ip    *string `json:"ip,omitempty"`
			Ipv6  *string `json:"ipv6,omitempty"`
			Mac   *string `json:"mac,omitempty"`
			Name  *string `json:"name,omitempty"`
			Speed *string `json:"speed,omitempty"`
			Type  *string `json:"type,omitempty"`
		} `json:"interfaces,omitempty"`
	} `json:"network,omitempty"`
	Resource *struct {
		MemoryAvailable *string `json:"memoryAvailable,omitempty"`
		MemoryTotal     *string `json:"memoryTotal,omitempty"`
		MemoryUsed      *string `json:"memoryUsed,omitempty"`
	} `json:"resource,omitempty"`
	Runtime *struct {
		Uptime *string `json:"uptime,omitempty"`
	} `json:"runtime,omitempty"`
	Software *struct {
		DriverDate    *string `json:"driverDate,omitempty"`
		EnigmaVersion *string `json:"enigmaVersion,omitempty"`
		ImageDistro   *string `json:"imageDistro,omitempty"`
		ImageVersion  *string `json:"imageVersion,omitempty"`
		KernelVersion *string `json:"kernelVersion,omitempty"`
		OeVersion     *string `json:"oeVersion,omitempty"`
		WebifVersion  *string `json:"webifVersion,omitempty"`
	} `json:"software,omitempty"`
	Storage *struct {
		Devices   *[]StorageItem `json:"devices,omitempty"`
		Locations *[]StorageItem `json:"locations,omitempty"`
	} `json:"storage,omitempty"`
	Tuners *[]struct {
		Name   *string `json:"name,omitempty"`
		Status *string `json:"status,omitempty"`
		Type   *string `json:"type,omitempty"`
	} `json:"tuners,omitempty"`
}

// Timer defines model for Timer.
type Timer struct {
	Begin         int64                   `json:"begin"`
	CreatedAt     *time.Time              `json:"createdAt,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	End           int64                   `json:"end"`
	Name          string                  `json:"name"`
	ReceiverState *map[string]interface{} `json:"receiverState,omitempty"`
	ServiceName   *string                 `json:"serviceName,omitempty"`
	ServiceRef    string                  `json:"serviceRef"`
	State         TimerState              `json:"state"`
	TimerId       string                  `json:"timerId"`
	UpdatedAt     *time.Time              `json:"updatedAt,omitempty"`
}

// TimerState defines model for Timer.State.
type TimerState string

// TimerConflict defines model for TimerConflict.
type TimerConflict struct {
	BlockingTimer  Timer             `json:"blockingTimer"`
	Message        *string           `json:"message,omitempty"`
	OverlapSeconds *int              `json:"overlapSeconds,omitempty"`
	Type           TimerConflictType `json:"type"`
}

// TimerConflictType defines model for TimerConflict.Type.
type TimerConflictType string

// TimerConflictPreviewRequest defines model for TimerConflictPreviewRequest.
type TimerConflictPreviewRequest struct {
	Mode     *TimerConflictPreviewRequestMode `json:"mode,omitempty"`
	Proposed TimerCreateRequest               `json:"proposed"`
}

// TimerConflictPreviewRequestMode defines model for TimerConflictPreviewRequest.Mode.
type TimerConflictPreviewRequestMode string

// TimerConflictPreviewResponse defines model for TimerConflictPreviewResponse.
type TimerConflictPreviewResponse struct {
	CanSchedule bool            `json:"canSchedule"`
	Conflicts   []TimerConflict `json:"conflicts"`
	Suggestions *[]struct {
		Kind          *TimerConflictPreviewResponseSuggestionsKind `json:"kind,omitempty"`
		Note          *string                                      `json:"note,omitempty"`
		ProposedBegin *int64                                       `json:"proposedBegin,omitempty"`
		ProposedEnd   *int64                                       `json:"proposedEnd,omitempty"`
	} `json:"suggestions,omitempty"`
}

// TimerConflictPreviewResponseSuggestionsKind defines model for TimerConflictPreviewResponse.Suggestions.Kind.
type TimerConflictPreviewResponseSuggestionsKind string

// TimerCreateRequest defines model for TimerCreateRequest.
type TimerCreateRequest struct {
	AfterEvent       *TimerCreateRequestAfterEvent `json:"afterEvent,omitempty"`
	Begin            int64                         `json:"begin"`
	Description      *string                       `json:"description,omitempty"`
	Enabled          *bool                         `json:"enabled,omitempty"`
	End              int64                         `json:"end"`
	IdempotencyKey   *string                       `json:"idempotencyKey,omitempty"`
	JustPlay         *bool                         `json:"justPlay,omitempty"`
	Name             string                        `json:"name"`
	PaddingAfterSec  *int                          `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int                          `json:"paddingBeforeSec,omitempty"`
	ServiceRef       string                        `json:"serviceRef"`
}

// TimerCreateRequestAfterEvent defines model for TimerCreateRequest.AfterEvent.
type TimerCreateRequestAfterEvent string

// TimerList defines model for TimerList.
type TimerList struct {
	Items []Timer `json:"items"`
}

// TimerPatchRequest defines model for TimerPatchRequest.
type TimerPatchRequest struct {
	Begin            *int64  `json:"begin,omitempty"`
	Description      *string `json:"description,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty"`
	End              *int64  `json:"end,omitempty"`
	Name             *string `json:"name,omitempty"`
	PaddingAfterSec  *int    `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int    `json:"paddingBeforeSec,omitempty"`
}

// VerificationConfig defines model for VerificationConfig.
type VerificationConfig struct {
	Enabled *bool `json:"enabled,omitempty"`

	// Interval Drift verification interval (e.g. "1m")
	Interval *string `json:"interval,omitempty"`
}

// GetEpgParams defines parameters for GetEpg.
type GetEpgParams struct {
	// From Start timestamp (unix seconds)
	From *int `form:"from,omitempty" json:"from,omitempty"`

	// To End timestamp (unix seconds)
	To *int `form:"to,omitempty" json:"to,omitempty"`

	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`

	// Q Filter by search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// GetRecordingsParams defines parameters for GetRecordings.
type GetRecordingsParams struct {
	// Root Root location ID
	Root *string `form:"root,omitempty" json:"root,omitempty"`

	// Path Relative path
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// RunAllSeriesRulesParams defines parameters for RunAllSeriesRules.
type RunAllSeriesRulesParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// RunSeriesRuleParams defines parameters for RunSeriesRule.
type RunSeriesRuleParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`
}

// PostServicesIdToggleJSONBody defines parameters for PostServicesIdToggle.
type PostServicesIdToggleJSONBody struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Pagination limit (max 1000)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTimersParams defines parameters for GetTimers.
type GetTimersParams struct {
	State *string `form:"state,omitempty" json:"state,omitempty"`
	From  *int    `form:"from,omitempty" json:"from,omitempty"`
}

// CreateIntentJSONRequestBody defines body for CreateIntent for application/json ContentType.
type CreateIntentJSONRequestBody = IntentRequest

// PostLivePlaybackInfoJSONRequestBody defines body for PostLivePlaybackInfo for application/json ContentType.
type PostLivePlaybackInfoJSONRequestBody = LivePlaybackInfoRequest

// PostRecordingPlaybackInfoJSONRequestBody defines body for PostRecordingPlaybackInfo for application/json ContentType.
type PostRecordingPlaybackInfoJSONRequestBody = PlaybackCapabilities

// CreateSeriesRuleJSONRequestBody defines body for CreateSeriesRule for application/json ContentType.
type CreateSeriesRuleJSONRequestBody = SeriesRule

// UpdateSeriesRuleJSONRequestBody defines body for UpdateSeriesRule for application/json ContentType.
type UpdateSeriesRuleJSONRequestBody = SeriesRuleUpdate

// PostServicesNowNextJSONRequestBody defines body for PostServicesNowNext for application/json ContentType.
type PostServicesNowNextJSONRequestBody = NowNextRequest

// PostServicesIdToggleJSONRequestBody defines body for PostServicesIdToggle for application/json ContentType.
type PostServicesIdToggleJSONRequestBody PostServicesIdToggleJSONBody

// ReportPlaybackFeedbackJSONRequestBody defines body for ReportPlaybackFeedback for application/json ContentType.
type ReportPlaybackFeedbackJSONRequestBody = PlaybackFeedbackRequest

// PutSystemConfigJSONRequestBody defines body for PutSystemConfig for application/json ContentType.
type PutSystemConfigJSONRequestBody = ConfigUpdate

// AddTimerJSONRequestBody defines body for AddTimer for application/json ContentType.
type AddTimerJSONRequestBody = TimerCreateRequest

// PreviewConflictsJSONRequestBody defines body for PreviewConflicts for application/json ContentType.
type PreviewConflictsJSONRequestBody = TimerConflictPreviewRequest

// UpdateTimerJSONRequestBody defines body for UpdateTimer for application/json ContentType.
type UpdateTimerJSONRequestBody = TimerPatchRequest

// AsPlaybackOutputFile returns the union data inside the PlaybackOutput as a PlaybackOutputFile
func (t PlaybackOutput) AsPlaybackOutputFile() (PlaybackOutputFile, error) {
	var body PlaybackOutputFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackOutputFile overwrites any union data inside the PlaybackOutput as the provided PlaybackOutputFile
func (t *PlaybackOutput) FromPlaybackOutputFile(v PlaybackOutputFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackOutputFile performs a merge with any union data inside the PlaybackOutput, using the provided PlaybackOutputFile
func (t *PlaybackOutput) MergePlaybackOutputFile(v PlaybackOutputFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaybackOutputHls returns the union data inside the PlaybackOutput as a PlaybackOutputHls
func (t PlaybackOutput) AsPlaybackOutputHls() (PlaybackOutputHls, error) {
	var body PlaybackOutputHls
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackOutputHls overwrites any union data inside the PlaybackOutput as the provided PlaybackOutputHls
func (t *PlaybackOutput) FromPlaybackOutputHls(v PlaybackOutputHls) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackOutputHls performs a merge with any union data inside the PlaybackOutput, using the provided PlaybackOutputHls
func (t *PlaybackOutput) MergePlaybackOutputHls(v PlaybackOutputHls) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlaybackOutput) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlaybackOutput) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
