// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ComponentStatusStatus.
const (
	ComponentStatusStatusError ComponentStatusStatus = "error"
	ComponentStatusStatusOk    ComponentStatusStatus = "ok"
)

// Defines values for DvrCapabilitiesSeriesMode.
const (
	Delegated DvrCapabilitiesSeriesMode = "delegated"
	Managed   DvrCapabilitiesSeriesMode = "managed"
	None      DvrCapabilitiesSeriesMode = "none"
)

// Defines values for EPGConfigSource.
const (
	EPGConfigSourceBouquet    EPGConfigSource = "bouquet"
	EPGConfigSourcePerService EPGConfigSource = "per-service"
)

// Defines values for EPGStatusStatus.
const (
	EPGStatusStatusMissing EPGStatusStatus = "missing"
	EPGStatusStatusOk      EPGStatusStatus = "ok"
)

// Defines values for IntentRequestHwaccel.
const (
	Auto  IntentRequestHwaccel = "auto"
	Force IntentRequestHwaccel = "force"
	Off   IntentRequestHwaccel = "off"
)

// Defines values for IntentRequestType.
const (
	StreamStart IntentRequestType = "stream.start"
	StreamStop  IntentRequestType = "stream.stop"
)

// Defines values for LibraryItemStatus.
const (
	LibraryItemStatusOk         LibraryItemStatus = "ok"
	LibraryItemStatusUnreadable LibraryItemStatus = "unreadable"
)

// Defines values for LibraryRootLastScanStatus.
const (
	LibraryRootLastScanStatusDegraded LibraryRootLastScanStatus = "degraded"
	LibraryRootLastScanStatusFailed   LibraryRootLastScanStatus = "failed"
	LibraryRootLastScanStatusNever    LibraryRootLastScanStatus = "never"
	LibraryRootLastScanStatusOk       LibraryRootLastScanStatus = "ok"
	LibraryRootLastScanStatusRunning  LibraryRootLastScanStatus = "running"
)

// Defines values for LibraryRootType.
const (
	Local LibraryRootType = "local"
	Nfs   LibraryRootType = "nfs"
	Smb   LibraryRootType = "smb"
)

// Defines values for PlaybackFeedbackRequestEvent.
const (
	PlaybackFeedbackRequestEventError   PlaybackFeedbackRequestEvent = "error"
	PlaybackFeedbackRequestEventInfo    PlaybackFeedbackRequestEvent = "info"
	PlaybackFeedbackRequestEventWarning PlaybackFeedbackRequestEvent = "warning"
)

// Defines values for PlaybackInfoMode.
const (
	DirectMp4 PlaybackInfoMode = "direct_mp4"
	Hls       PlaybackInfoMode = "hls"
)

// Defines values for RecordingBuildStatusAttemptMode.
const (
	Fast   RecordingBuildStatusAttemptMode = "fast"
	Robust RecordingBuildStatusAttemptMode = "robust"
)

// Defines values for RecordingBuildStatusState.
const (
	RecordingBuildStatusStateFAILED  RecordingBuildStatusState = "FAILED"
	RecordingBuildStatusStateIDLE    RecordingBuildStatusState = "IDLE"
	RecordingBuildStatusStateREADY   RecordingBuildStatusState = "READY"
	RecordingBuildStatusStateRUNNING RecordingBuildStatusState = "RUNNING"
)

// Defines values for ScanStatusState.
const (
	ScanStatusStateCancelled ScanStatusState = "cancelled"
	ScanStatusStateComplete  ScanStatusState = "complete"
	ScanStatusStateFailed    ScanStatusState = "failed"
	ScanStatusStateIdle      ScanStatusState = "idle"
	ScanStatusStateRunning   ScanStatusState = "running"
)

// Defines values for SeriesRuleRunReportStatus.
const (
	SeriesRuleRunReportStatusFailed  SeriesRuleRunReportStatus = "failed"
	SeriesRuleRunReportStatusPartial SeriesRuleRunReportStatus = "partial"
	SeriesRuleRunReportStatusSuccess SeriesRuleRunReportStatus = "success"
)

// Defines values for SessionRecordReason.
const (
	SessionRecordReasonRBADREQUEST         SessionRecordReason = "R_BAD_REQUEST"
	SessionRecordReasonRCANCELLED          SessionRecordReason = "R_CANCELLED"
	SessionRecordReasonRCLIENTSTOP         SessionRecordReason = "R_CLIENT_STOP"
	SessionRecordReasonRFFMPEGSTARTFAILED  SessionRecordReason = "R_FFMPEG_START_FAILED"
	SessionRecordReasonRIDLETIMEOUT        SessionRecordReason = "R_IDLE_TIMEOUT"
	SessionRecordReasonRINVARIANTVIOLATION SessionRecordReason = "R_INVARIANT_VIOLATION"
	SessionRecordReasonRLEASEBUSY          SessionRecordReason = "R_LEASE_BUSY"
	SessionRecordReasonRLEASEEXPIRED       SessionRecordReason = "R_LEASE_EXPIRED"
	SessionRecordReasonRNONE               SessionRecordReason = "R_NONE"
	SessionRecordReasonRNOTFOUND           SessionRecordReason = "R_NOT_FOUND"
	SessionRecordReasonRPACKAGERFAILED     SessionRecordReason = "R_PACKAGER_FAILED"
	SessionRecordReasonRPROCESSENDED       SessionRecordReason = "R_PROCESS_ENDED"
	SessionRecordReasonRTUNEFAILED         SessionRecordReason = "R_TUNE_FAILED"
	SessionRecordReasonRTUNETIMEOUT        SessionRecordReason = "R_TUNE_TIMEOUT"
	SessionRecordReasonRUNKNOWN            SessionRecordReason = "R_UNKNOWN"
)

// Defines values for SessionRecordState.
const (
	SessionRecordStateCANCELLED SessionRecordState = "CANCELLED"
	SessionRecordStateDRAINING  SessionRecordState = "DRAINING"
	SessionRecordStateFAILED    SessionRecordState = "FAILED"
	SessionRecordStateNEW       SessionRecordState = "NEW"
	SessionRecordStatePRIMING   SessionRecordState = "PRIMING"
	SessionRecordStateREADY     SessionRecordState = "READY"
	SessionRecordStateSTARTING  SessionRecordState = "STARTING"
	SessionRecordStateSTOPPED   SessionRecordState = "STOPPED"
	SessionRecordStateSTOPPING  SessionRecordState = "STOPPING"
)

// Defines values for SessionResponseMode.
const (
	LIVE      SessionResponseMode = "LIVE"
	RECORDING SessionResponseMode = "RECORDING"
)

// Defines values for SessionResponseReason.
const (
	SessionResponseReasonRBADREQUEST         SessionResponseReason = "R_BAD_REQUEST"
	SessionResponseReasonRCANCELLED          SessionResponseReason = "R_CANCELLED"
	SessionResponseReasonRCLIENTSTOP         SessionResponseReason = "R_CLIENT_STOP"
	SessionResponseReasonRFFMPEGSTARTFAILED  SessionResponseReason = "R_FFMPEG_START_FAILED"
	SessionResponseReasonRIDLETIMEOUT        SessionResponseReason = "R_IDLE_TIMEOUT"
	SessionResponseReasonRINVARIANTVIOLATION SessionResponseReason = "R_INVARIANT_VIOLATION"
	SessionResponseReasonRLEASEBUSY          SessionResponseReason = "R_LEASE_BUSY"
	SessionResponseReasonRLEASEEXPIRED       SessionResponseReason = "R_LEASE_EXPIRED"
	SessionResponseReasonRNONE               SessionResponseReason = "R_NONE"
	SessionResponseReasonRNOTFOUND           SessionResponseReason = "R_NOT_FOUND"
	SessionResponseReasonRPACKAGERFAILED     SessionResponseReason = "R_PACKAGER_FAILED"
	SessionResponseReasonRPROCESSENDED       SessionResponseReason = "R_PROCESS_ENDED"
	SessionResponseReasonRTUNEFAILED         SessionResponseReason = "R_TUNE_FAILED"
	SessionResponseReasonRTUNETIMEOUT        SessionResponseReason = "R_TUNE_TIMEOUT"
	SessionResponseReasonRUNKNOWN            SessionResponseReason = "R_UNKNOWN"
)

// Defines values for SessionResponseState.
const (
	CANCELLED SessionResponseState = "CANCELLED"
	DRAINING  SessionResponseState = "DRAINING"
	FAILED    SessionResponseState = "FAILED"
	NEW       SessionResponseState = "NEW"
	PRIMING   SessionResponseState = "PRIMING"
	READY     SessionResponseState = "READY"
	STARTING  SessionResponseState = "STARTING"
	STOPPED   SessionResponseState = "STOPPED"
	STOPPING  SessionResponseState = "STOPPING"
)

// Defines values for StreamSessionState.
const (
	Active StreamSessionState = "active"
	Idle   StreamSessionState = "idle"
)

// Defines values for StreamingConfigDeliveryPolicy.
const (
	Universal StreamingConfigDeliveryPolicy = "universal"
)

// Defines values for SystemDiagnosticsDegradationSummaryStatus.
const (
	SystemDiagnosticsDegradationSummaryStatusDegraded    SystemDiagnosticsDegradationSummaryStatus = "degraded"
	SystemDiagnosticsDegradationSummaryStatusUnavailable SystemDiagnosticsDegradationSummaryStatus = "unavailable"
)

// Defines values for SystemDiagnosticsOverallStatus.
const (
	SystemDiagnosticsOverallStatusDegraded    SystemDiagnosticsOverallStatus = "degraded"
	SystemDiagnosticsOverallStatusOk          SystemDiagnosticsOverallStatus = "ok"
	SystemDiagnosticsOverallStatusUnavailable SystemDiagnosticsOverallStatus = "unavailable"
	SystemDiagnosticsOverallStatusUnknown     SystemDiagnosticsOverallStatus = "unknown"
)

// Defines values for SystemHealthStatus.
const (
	SystemHealthStatusDegraded SystemHealthStatus = "degraded"
	SystemHealthStatusError    SystemHealthStatus = "error"
	SystemHealthStatusOk       SystemHealthStatus = "ok"
)

// Defines values for TimerState.
const (
	TimerStateCompleted TimerState = "completed"
	TimerStateDisabled  TimerState = "disabled"
	TimerStateRecording TimerState = "recording"
	TimerStateScheduled TimerState = "scheduled"
	TimerStateUnknown   TimerState = "unknown"
)

// Defines values for TimerConflictType.
const (
	TimerConflictTypeDuplicate  TimerConflictType = "duplicate"
	TimerConflictTypeOverlap    TimerConflictType = "overlap"
	TimerConflictTypeTunerLimit TimerConflictType = "tuner_limit"
	TimerConflictTypeUnknown    TimerConflictType = "unknown"
)

// Defines values for TimerConflictPreviewRequestMode.
const (
	Conservative  TimerConflictPreviewRequestMode = "conservative"
	ReceiverAware TimerConflictPreviewRequestMode = "receiverAware"
)

// Defines values for TimerConflictPreviewResponseSuggestionsKind.
const (
	ReducePadding TimerConflictPreviewResponseSuggestionsKind = "reduce_padding"
	ShiftEnd      TimerConflictPreviewResponseSuggestionsKind = "shift_end"
	ShiftStart    TimerConflictPreviewResponseSuggestionsKind = "shift_start"
)

// Defines values for TimerCreateRequestAfterEvent.
const (
	Deepstandby TimerCreateRequestAfterEvent = "deepstandby"
	Default     TimerCreateRequestAfterEvent = "default"
	Nothing     TimerCreateRequestAfterEvent = "nothing"
	Standby     TimerCreateRequestAfterEvent = "standby"
)

// APIError defines model for APIError.
type APIError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Optional additional context
	Details *interface{} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Request ID for debugging
	RequestId string `json:"request_id"`
}

// AppConfig defines model for AppConfig.
type AppConfig struct {
	Bouquets     *[]string        `json:"bouquets,omitempty"`
	DataDir      *string          `json:"dataDir,omitempty"`
	Epg          *EPGConfig       `json:"epg,omitempty"`
	FeatureFlags *FeatureFlags    `json:"featureFlags,omitempty"`
	LogLevel     *string          `json:"logLevel,omitempty"`
	OpenWebIF    *OpenWebIFConfig `json:"openWebIF,omitempty"`
	Picons       *PiconsConfig    `json:"picons,omitempty"`
	Streaming    *StreamingConfig `json:"streaming,omitempty"`
	Version      *string          `json:"version,omitempty"`
}

// Bouquet defines model for Bouquet.
type Bouquet struct {
	Name     *string `json:"name,omitempty"`
	Services *int    `json:"services,omitempty"`
}

// Breadcrumb defines model for Breadcrumb.
type Breadcrumb struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// ComponentStatus defines model for ComponentStatus.
type ComponentStatus struct {
	LastCheck *time.Time             `json:"last_check,omitempty"`
	Status    *ComponentStatusStatus `json:"status,omitempty"`
}

// ComponentStatusStatus defines model for ComponentStatus.Status.
type ComponentStatusStatus string

// ConfigUpdate defines model for ConfigUpdate.
type ConfigUpdate struct {
	Bouquets     *[]string        `json:"bouquets,omitempty"`
	Epg          *EPGConfig       `json:"epg,omitempty"`
	FeatureFlags *FeatureFlags    `json:"featureFlags,omitempty"`
	OpenWebIF    *OpenWebIFConfig `json:"openWebIF,omitempty"`
	Picons       *PiconsConfig    `json:"picons,omitempty"`
}

// CurrentServiceInfo Current live service and EPG information from receiver
type CurrentServiceInfo struct {
	// Channel Channel name (e.g. "zdf_neo HD")
	Channel *string `json:"channel,omitempty"`

	// Description Short program description
	Description *string `json:"description,omitempty"`

	// EndTime Program end time (Unix timestamp)
	EndTime *int64 `json:"end_time,omitempty"`

	// NextProgram Next program title
	NextProgram *string `json:"next_program,omitempty"`

	// Program Current program title
	Program *string `json:"program,omitempty"`

	// StartTime Program start time (Unix timestamp)
	StartTime *int64 `json:"start_time,omitempty"`
}

// DirectoryItem defines model for DirectoryItem.
type DirectoryItem struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// DvrCapabilities defines model for DvrCapabilities.
type DvrCapabilities struct {
	Conflicts struct {
		Preview       *bool `json:"preview,omitempty"`
		ReceiverAware *bool `json:"receiverAware,omitempty"`
	} `json:"conflicts"`
	Series struct {
		DelegatedProvider *string                    `json:"delegatedProvider,omitempty"`
		Mode              *DvrCapabilitiesSeriesMode `json:"mode,omitempty"`
		Supported         *bool                      `json:"supported,omitempty"`
	} `json:"series"`
	Timers struct {
		Delete         *bool `json:"delete,omitempty"`
		Edit           *bool `json:"edit,omitempty"`
		ReadBackVerify *bool `json:"readBackVerify,omitempty"`
	} `json:"timers"`
}

// DvrCapabilitiesSeriesMode defines model for DvrCapabilities.Series.Mode.
type DvrCapabilitiesSeriesMode string

// EPGConfig defines model for EPGConfig.
type EPGConfig struct {
	Days    *int             `json:"days,omitempty"`
	Enabled *bool            `json:"enabled,omitempty"`
	Source  *EPGConfigSource `json:"source,omitempty"`
}

// EPGConfigSource defines model for EPGConfig.Source.
type EPGConfigSource string

// EPGStatus defines model for EPGStatus.
type EPGStatus struct {
	MissingChannels *int             `json:"missing_channels,omitempty"`
	Status          *EPGStatusStatus `json:"status,omitempty"`
}

// EPGStatusStatus defines model for EPGStatus.Status.
type EPGStatusStatus string

// FeatureFlags defines model for FeatureFlags.
type FeatureFlags struct {
	InstantTune *bool `json:"instantTune,omitempty"`
}

// IntentRequest defines model for IntentRequest.
type IntentRequest struct {
	// CorrelationId Optional correlation ID for end-to-end tracing
	CorrelationId *string `json:"correlationId,omitempty"`

	// Hwaccel Hardware acceleration override (v3.1+).
	// - auto: Server decides based on GPU availability
	// - force: Force GPU encoding (fails if no GPU)
	// - off: Force CPU encoding
	Hwaccel *IntentRequestHwaccel `json:"hwaccel,omitempty"`

	// IdempotencyKey Optional idempotency key for at-most-once semantics
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`

	// Params Additional parameters
	Params *map[string]string `json:"params,omitempty"`

	// ServiceRef Required for stream.start. Enigma2 service reference (live playback only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// SessionId Required for stream.stop intent
	SessionId *openapi_types.UUID `json:"sessionId,omitempty"`
	Type      *IntentRequestType  `json:"type,omitempty"`
}

// IntentRequestHwaccel Hardware acceleration override (v3.1+).
// - auto: Server decides based on GPU availability
// - force: Force GPU encoding (fails if no GPU)
// - off: Force CPU encoding
type IntentRequestHwaccel string

// IntentRequestType defines model for IntentRequest.Type.
type IntentRequestType string

// LibraryItem defines model for LibraryItem.
type LibraryItem struct {
	Filename  string             `json:"filename"`
	ModTime   time.Time          `json:"mod_time"`
	RelPath   string             `json:"rel_path"`
	RootId    string             `json:"root_id"`
	ScanTime  *time.Time         `json:"scan_time,omitempty"`
	SizeBytes int64              `json:"size_bytes"`
	Status    *LibraryItemStatus `json:"status,omitempty"`
}

// LibraryItemStatus defines model for LibraryItem.Status.
type LibraryItemStatus string

// LibraryItemsResponse defines model for LibraryItemsResponse.
type LibraryItemsResponse struct {
	Items  []LibraryItem `json:"items"`
	Limit  int           `json:"limit"`
	Offset int           `json:"offset"`
	Total  int           `json:"total"`
}

// LibraryRoot defines model for LibraryRoot.
type LibraryRoot struct {
	Id             string                    `json:"id"`
	LastScanStatus LibraryRootLastScanStatus `json:"last_scan_status"`
	LastScanTime   *time.Time                `json:"last_scan_time,omitempty"`
	TotalItems     *int                      `json:"total_items,omitempty"`
	Type           LibraryRootType           `json:"type"`
}

// LibraryRootLastScanStatus defines model for LibraryRoot.LastScanStatus.
type LibraryRootLastScanStatus string

// LibraryRootType defines model for LibraryRoot.Type.
type LibraryRootType string

// LogEntry defines model for LogEntry.
type LogEntry struct {
	Fields  *map[string]interface{} `json:"fields,omitempty"`
	Level   *string                 `json:"level,omitempty"`
	Message *string                 `json:"message,omitempty"`
	Time    *time.Time              `json:"time,omitempty"`
}

// NowNextEntry defines model for NowNextEntry.
type NowNextEntry struct {
	// End Unix timestamp (seconds)
	End int `json:"end"`

	// Start Unix timestamp (seconds)
	Start int    `json:"start"`
	Title string `json:"title"`
}

// NowNextItem defines model for NowNextItem.
type NowNextItem struct {
	Next       *NowNextEntry `json:"next,omitempty"`
	Now        *NowNextEntry `json:"now,omitempty"`
	ServiceRef string        `json:"service_ref"`
}

// NowNextRequest defines model for NowNextRequest.
type NowNextRequest struct {
	Services []string `json:"services"`
}

// NowNextResponse defines model for NowNextResponse.
type NowNextResponse struct {
	Items []NowNextItem `json:"items"`
}

// OpenWebIFConfig defines model for OpenWebIFConfig.
type OpenWebIFConfig struct {
	BaseUrl    *string `json:"baseUrl,omitempty"`
	Password   *string `json:"password,omitempty"`
	StreamPort *int    `json:"streamPort,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// PiconsConfig defines model for PiconsConfig.
type PiconsConfig struct {
	BaseUrl *string `json:"baseUrl,omitempty"`
}

// PlaybackFeedbackRequest defines model for PlaybackFeedbackRequest.
type PlaybackFeedbackRequest struct {
	// Code MediaError code if applicable
	Code    *int                         `json:"code,omitempty"`
	Details *map[string]interface{}      `json:"details,omitempty"`
	Event   PlaybackFeedbackRequestEvent `json:"event"`
	Message *string                      `json:"message,omitempty"`
}

// PlaybackFeedbackRequestEvent defines model for PlaybackFeedbackRequest.Event.
type PlaybackFeedbackRequestEvent string

// PlaybackInfo defines model for PlaybackInfo.
type PlaybackInfo struct {
	Mode     PlaybackInfoMode `json:"mode"`
	Reason   *string          `json:"reason,omitempty"`
	Seekable *bool            `json:"seekable,omitempty"`
	Url      string           `json:"url"`
}

// PlaybackInfoMode defines model for PlaybackInfo.Mode.
type PlaybackInfoMode string

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	Conflicts *[]TimerConflict        `json:"conflicts,omitempty"`
	Detail    *string                 `json:"detail,omitempty"`
	Fields    *map[string]interface{} `json:"fields,omitempty"`
	Instance  *string                 `json:"instance,omitempty"`
	Status    int                     `json:"status"`
	Title     string                  `json:"title"`
	Type      string                  `json:"type"`
}

// RecordingBuildStatus defines model for RecordingBuildStatus.
type RecordingBuildStatus struct {
	AttemptMode  *RecordingBuildStatusAttemptMode `json:"attempt_mode,omitempty"`
	Error        *string                          `json:"error,omitempty"`
	LastProgress *time.Time                       `json:"last_progress,omitempty"`

	// ProgressiveReady True if a progressive (timeshift) playlist is playable.
	ProgressiveReady *bool                     `json:"progressive_ready,omitempty"`
	SegmentCount     *int                      `json:"segment_count,omitempty"`
	StartedAt        *time.Time                `json:"started_at,omitempty"`
	State            RecordingBuildStatusState `json:"state"`
}

// RecordingBuildStatusAttemptMode defines model for RecordingBuildStatus.AttemptMode.
type RecordingBuildStatusAttemptMode string

// RecordingBuildStatusState defines model for RecordingBuildStatus.State.
type RecordingBuildStatusState string

// RecordingItem defines model for RecordingItem.
type RecordingItem struct {
	// BeginUnixSeconds Recording start time as UNIX seconds.
	BeginUnixSeconds *int64  `json:"begin_unix_seconds,omitempty"`
	Description      *string `json:"description,omitempty"`

	// DurationSeconds Recording duration in seconds, if known.
	DurationSeconds *int64  `json:"duration_seconds,omitempty"`
	Filename        *string `json:"filename,omitempty"`

	// Length Human-readable duration string for display only.
	Length *string `json:"length,omitempty"`

	// RecordingId Base64url-encoded recording ID (RFC 4648, unpadded) to use for /recordings/{recordingId}.
	RecordingId *string        `json:"recording_id,omitempty"`
	Resume      *ResumeSummary `json:"resume,omitempty"`

	// ServiceRef Legacy receiver service reference (read-only).
	ServiceRef *string `json:"service_ref,omitempty"`
	Title      *string `json:"title,omitempty"`
}

// RecordingResponse defines model for RecordingResponse.
type RecordingResponse struct {
	Breadcrumbs *[]Breadcrumb    `json:"breadcrumbs,omitempty"`
	CurrentPath *string          `json:"current_path,omitempty"`
	CurrentRoot *string          `json:"current_root,omitempty"`
	Directories *[]DirectoryItem `json:"directories,omitempty"`
	Recordings  *[]RecordingItem `json:"recordings,omitempty"`
	Roots       *[]RecordingRoot `json:"roots,omitempty"`
}

// RecordingRoot defines model for RecordingRoot.
type RecordingRoot struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// RecordingStatus defines model for RecordingStatus.
type RecordingStatus struct {
	IsRecording bool    `json:"isRecording"`
	ServiceName *string `json:"serviceName,omitempty"`
}

// ResumeSummary defines model for ResumeSummary.
type ResumeSummary struct {
	DurationSeconds *int64     `json:"duration_seconds,omitempty"`
	Finished        *bool      `json:"finished,omitempty"`
	PosSeconds      *int64     `json:"pos_seconds,omitempty"`
	UpdatedAt       *time.Time `json:"updated_at,omitempty"`
}

// RuleSnapshot defines model for RuleSnapshot.
type RuleSnapshot struct {
	ChannelRef  *string `json:"channelRef,omitempty"`
	Days        *[]int  `json:"days,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Id          *string `json:"id,omitempty"`
	Keyword     *string `json:"keyword,omitempty"`
	Priority    *int    `json:"priority,omitempty"`
	StartWindow *string `json:"startWindow,omitempty"`
}

// RunConflict defines model for RunConflict.
type RunConflict struct {
	Begin           *int64  `json:"begin,omitempty"`
	BlockingTimerId *string `json:"blockingTimerId,omitempty"`
	End             *int64  `json:"end,omitempty"`
	Message         *string `json:"message,omitempty"`
	OverlapSeconds  *int64  `json:"overlapSeconds,omitempty"`
	ServiceRef      *string `json:"serviceRef,omitempty"`
	Title           *string `json:"title,omitempty"`
}

// RunDecision defines model for RunDecision.
type RunDecision struct {
	Action      *string   `json:"action,omitempty"`
	Begin       *int64    `json:"begin,omitempty"`
	Details     *string   `json:"details,omitempty"`
	End         *int64    `json:"end,omitempty"`
	MatchReason *[]string `json:"matchReason,omitempty"`
	Reason      *string   `json:"reason,omitempty"`
	ServiceRef  *string   `json:"serviceRef,omitempty"`
	TimerId     *string   `json:"timerId,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// RunError defines model for RunError.
type RunError struct {
	At        *time.Time `json:"at,omitempty"`
	Message   *string    `json:"message,omitempty"`
	Retryable *bool      `json:"retryable,omitempty"`
	Type      *string    `json:"type,omitempty"`
}

// RunSummary defines model for RunSummary.
type RunSummary struct {
	EpgItemsMatched             *int  `json:"epgItemsMatched,omitempty"`
	EpgItemsScanned             *int  `json:"epgItemsScanned,omitempty"`
	MaxMatchesScannedPerRuleHit *bool `json:"maxMatchesScannedPerRuleHit,omitempty"`
	MaxTimersGlobalPerRunHit    *bool `json:"maxTimersGlobalPerRunHit,omitempty"`
	ReceiverUnreachable         *bool `json:"receiverUnreachable,omitempty"`
	TimersAttempted             *int  `json:"timersAttempted,omitempty"`
	TimersConflicted            *int  `json:"timersConflicted,omitempty"`
	TimersCreated               *int  `json:"timersCreated,omitempty"`
	TimersErrored               *int  `json:"timersErrored,omitempty"`
	TimersSkipped               *int  `json:"timersSkipped,omitempty"`
}

// ScanStatus defines model for ScanStatus.
type ScanStatus struct {
	// FinishedAt Unix timestamp of when the last scan completed
	FinishedAt *int64  `json:"finished_at,omitempty"`
	LastError  *string `json:"last_error,omitempty"`

	// ScannedChannels Number of attempts (successful/failed) to probe channels so far
	ScannedChannels *int `json:"scanned_channels,omitempty"`

	// StartedAt Unix timestamp of when the current or last scan started
	StartedAt *int64           `json:"started_at,omitempty"`
	State     *ScanStatusState `json:"state,omitempty"`

	// TotalChannels Total number of channels in the playlist
	TotalChannels *int `json:"total_channels,omitempty"`

	// UpdatedCount Number of capabilities successfully updated in the store
	UpdatedCount *int `json:"updated_count,omitempty"`
}

// ScanStatusState defines model for ScanStatus.State.
type ScanStatusState string

// SeriesRule defines model for SeriesRule.
type SeriesRule struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channel_ref,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int  `json:"days,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Id      *string `json:"id,omitempty"`

	// Keyword Search term or regex for event title
	Keyword        *string     `json:"keyword,omitempty"`
	LastRunAt      *time.Time  `json:"lastRunAt,omitempty"`
	LastRunStatus  *string     `json:"lastRunStatus,omitempty"`
	LastRunSummary *RunSummary `json:"lastRunSummary,omitempty"`
	Priority       *int        `json:"priority,omitempty"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"start_window,omitempty"`
}

// SeriesRuleRunReport defines model for SeriesRuleRunReport.
type SeriesRuleRunReport struct {
	Conflicts  *[]RunConflict             `json:"conflicts,omitempty"`
	Decisions  *[]RunDecision             `json:"decisions,omitempty"`
	DurationMs *int64                     `json:"durationMs,omitempty"`
	Errors     *[]RunError                `json:"errors,omitempty"`
	FinishedAt *time.Time                 `json:"finishedAt,omitempty"`
	RuleId     *string                    `json:"ruleId,omitempty"`
	RunId      *string                    `json:"runId,omitempty"`
	Snapshot   *RuleSnapshot              `json:"snapshot,omitempty"`
	StartedAt  *time.Time                 `json:"startedAt,omitempty"`
	Status     *SeriesRuleRunReportStatus `json:"status,omitempty"`
	Summary    *RunSummary                `json:"summary,omitempty"`
	Trigger    *string                    `json:"trigger,omitempty"`
	WindowFrom *int64                     `json:"windowFrom,omitempty"`
	WindowTo   *int64                     `json:"windowTo,omitempty"`
}

// SeriesRuleRunReportStatus defines model for SeriesRuleRunReport.Status.
type SeriesRuleRunReportStatus string

// SeriesRuleUpdate defines model for SeriesRuleUpdate.
type SeriesRuleUpdate struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channel_ref,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int `json:"days,omitempty"`
	Enabled bool   `json:"enabled"`

	// Keyword Search term or regex for event title
	Keyword  string `json:"keyword"`
	Priority int    `json:"priority"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"start_window,omitempty"`
}

// Service defines model for Service.
type Service struct {
	// Enabled Whether service is enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Id Service identifier
	Id *string `json:"id,omitempty"`

	// Name Service/channel name
	Name *string `json:"name,omitempty"`

	// Ref Enigma2 service reference
	Ref *string `json:"ref,omitempty"`
}

// SessionRecord defines model for SessionRecord.
type SessionRecord struct {
	ContextData    *map[string]string      `json:"contextData,omitempty"`
	CorrelationId  *string                 `json:"correlationId,omitempty"`
	CreatedAtUnix  *int64                  `json:"createdAtUnix,omitempty"`
	LastAccessUnix *int64                  `json:"lastAccessUnix,omitempty"`
	Profile        *map[string]interface{} `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionRecordReason `json:"reason,omitempty"`
	ReasonDetail *string              `json:"reasonDetail,omitempty"`
	ServiceRef   *string              `json:"serviceRef,omitempty"`
	SessionId    *openapi_types.UUID  `json:"sessionId,omitempty"`

	// State Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
	// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
	State         *SessionRecordState `json:"state,omitempty"`
	TunerID       *string             `json:"tunerID,omitempty"`
	UpdatedAtUnix *int64              `json:"updatedAtUnix,omitempty"`
}

// SessionRecordReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionRecordReason string

// SessionRecordState Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
type SessionRecordState string

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	CorrelationId *string `json:"correlationId,omitempty"`

	// DurationSeconds DVR window length for live sessions, in seconds.
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// LiveEdgeSeconds Current live edge position in seconds (live only).
	LiveEdgeSeconds *float32 `json:"liveEdgeSeconds,omitempty"`

	// Mode Playback mode for the session.
	Mode *SessionResponseMode `json:"mode,omitempty"`

	// PlaybackUrl Playback URL for the HLS playlist.
	PlaybackUrl *string `json:"playbackUrl,omitempty"`
	Profile     *string `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionResponseReason `json:"reason,omitempty"`
	ReasonDetail *string                `json:"reasonDetail,omitempty"`

	// SeekableEndSeconds Latest seekable position in seconds.
	SeekableEndSeconds *float32 `json:"seekableEndSeconds,omitempty"`

	// SeekableStartSeconds Earliest seekable position in seconds.
	SeekableStartSeconds *float32           `json:"seekableStartSeconds,omitempty"`
	ServiceRef           *string            `json:"serviceRef,omitempty"`
	SessionId            openapi_types.UUID `json:"sessionId"`

	// State Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
	// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
	State       SessionResponseState `json:"state"`
	UpdatedAtMs *int                 `json:"updatedAtMs,omitempty"`
}

// SessionResponseMode Playback mode for the session.
type SessionResponseMode string

// SessionResponseReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionResponseReason string

// SessionResponseState Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
type SessionResponseState string

// StreamSession defines model for StreamSession.
type StreamSession struct {
	ChannelName *string             `json:"channel_name,omitempty"`
	ClientIp    *string             `json:"client_ip,omitempty"`
	Id          *string             `json:"id,omitempty"`
	StartedAt   *time.Time          `json:"started_at,omitempty"`
	State       *StreamSessionState `json:"state,omitempty"`
}

// StreamSessionState defines model for StreamSession.State.
type StreamSessionState string

// StreamingConfig defines model for StreamingConfig.
type StreamingConfig struct {
	// DeliveryPolicy Strict delivery policy (v3.1+)
	DeliveryPolicy *StreamingConfigDeliveryPolicy `json:"delivery_policy,omitempty"`
}

// StreamingConfigDeliveryPolicy Strict delivery policy (v3.1+)
type StreamingConfigDeliveryPolicy string

// SystemDiagnostics System-wide diagnostics per ADR-SRE-002
type SystemDiagnostics struct {
	// DegradationSummary Actionable degradation items for failed subsystems
	DegradationSummary *[]struct {
		ErrorCode        *string                                    `json:"error_code,omitempty"`
		Since            *time.Time                                 `json:"since,omitempty"`
		Status           *SystemDiagnosticsDegradationSummaryStatus `json:"status,omitempty"`
		Subsystem        *string                                    `json:"subsystem,omitempty"`
		SuggestedActions *[]string                                  `json:"suggested_actions,omitempty"`
	} `json:"degradation_summary,omitempty"`

	// DerivedAt When overall status was computed
	DerivedAt time.Time `json:"derived_at"`

	// MeasuredAt When subsystems were last probed
	MeasuredAt time.Time `json:"measured_at"`

	// OverallStatus Overall system health (per P0-A critical subsystem logic)
	OverallStatus SystemDiagnosticsOverallStatus `json:"overall_status"`

	// Subsystems Health status per subsystem
	Subsystems map[string]interface{} `json:"subsystems"`
}

// SystemDiagnosticsDegradationSummaryStatus defines model for SystemDiagnostics.DegradationSummary.Status.
type SystemDiagnosticsDegradationSummaryStatus string

// SystemDiagnosticsOverallStatus Overall system health (per P0-A critical subsystem logic)
type SystemDiagnosticsOverallStatus string

// SystemHealth defines model for SystemHealth.
type SystemHealth struct {
	Epg           *EPGStatus          `json:"epg,omitempty"`
	Receiver      *ComponentStatus    `json:"receiver,omitempty"`
	Status        *SystemHealthStatus `json:"status,omitempty"`
	UptimeSeconds *int64              `json:"uptime_seconds,omitempty"`
	Version       *string             `json:"version,omitempty"`
}

// SystemHealthStatus defines model for SystemHealth.Status.
type SystemHealthStatus string

// Timer defines model for Timer.
type Timer struct {
	Begin         int64                   `json:"begin"`
	CreatedAt     *time.Time              `json:"createdAt,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	End           int64                   `json:"end"`
	Name          string                  `json:"name"`
	ReceiverState *map[string]interface{} `json:"receiverState,omitempty"`
	ServiceName   *string                 `json:"serviceName,omitempty"`
	ServiceRef    string                  `json:"serviceRef"`
	State         TimerState              `json:"state"`
	TimerId       string                  `json:"timerId"`
	UpdatedAt     *time.Time              `json:"updatedAt,omitempty"`
}

// TimerState defines model for Timer.State.
type TimerState string

// TimerConflict defines model for TimerConflict.
type TimerConflict struct {
	BlockingTimer  Timer             `json:"blockingTimer"`
	Message        *string           `json:"message,omitempty"`
	OverlapSeconds *int              `json:"overlapSeconds,omitempty"`
	Type           TimerConflictType `json:"type"`
}

// TimerConflictType defines model for TimerConflict.Type.
type TimerConflictType string

// TimerConflictPreviewRequest defines model for TimerConflictPreviewRequest.
type TimerConflictPreviewRequest struct {
	Mode     *TimerConflictPreviewRequestMode `json:"mode,omitempty"`
	Proposed TimerCreateRequest               `json:"proposed"`
}

// TimerConflictPreviewRequestMode defines model for TimerConflictPreviewRequest.Mode.
type TimerConflictPreviewRequestMode string

// TimerConflictPreviewResponse defines model for TimerConflictPreviewResponse.
type TimerConflictPreviewResponse struct {
	CanSchedule bool            `json:"canSchedule"`
	Conflicts   []TimerConflict `json:"conflicts"`
	Suggestions *[]struct {
		Kind          *TimerConflictPreviewResponseSuggestionsKind `json:"kind,omitempty"`
		Note          *string                                      `json:"note,omitempty"`
		ProposedBegin *int64                                       `json:"proposedBegin,omitempty"`
		ProposedEnd   *int64                                       `json:"proposedEnd,omitempty"`
	} `json:"suggestions,omitempty"`
}

// TimerConflictPreviewResponseSuggestionsKind defines model for TimerConflictPreviewResponse.Suggestions.Kind.
type TimerConflictPreviewResponseSuggestionsKind string

// TimerCreateRequest defines model for TimerCreateRequest.
type TimerCreateRequest struct {
	AfterEvent       *TimerCreateRequestAfterEvent `json:"afterEvent,omitempty"`
	Begin            int64                         `json:"begin"`
	Description      *string                       `json:"description,omitempty"`
	Enabled          *bool                         `json:"enabled,omitempty"`
	End              int64                         `json:"end"`
	IdempotencyKey   *string                       `json:"idempotencyKey,omitempty"`
	JustPlay         *bool                         `json:"justPlay,omitempty"`
	Name             string                        `json:"name"`
	PaddingAfterSec  *int                          `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int                          `json:"paddingBeforeSec,omitempty"`
	ServiceRef       string                        `json:"serviceRef"`
}

// TimerCreateRequestAfterEvent defines model for TimerCreateRequest.AfterEvent.
type TimerCreateRequestAfterEvent string

// TimerList defines model for TimerList.
type TimerList struct {
	Items []Timer `json:"items"`
}

// TimerPatchRequest defines model for TimerPatchRequest.
type TimerPatchRequest struct {
	Begin            *int64  `json:"begin,omitempty"`
	Description      *string `json:"description,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty"`
	End              *int64  `json:"end,omitempty"`
	Name             *string `json:"name,omitempty"`
	PaddingAfterSec  *int    `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int    `json:"paddingBeforeSec,omitempty"`
}

// GetEpgParams defines parameters for GetEpg.
type GetEpgParams struct {
	// From Start timestamp (unix seconds)
	From *int `form:"from,omitempty" json:"from,omitempty"`

	// To End timestamp (unix seconds)
	To *int `form:"to,omitempty" json:"to,omitempty"`

	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`

	// Q Filter by search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// GetLibraryRootItemsParams defines parameters for GetLibraryRootItems.
type GetLibraryRootItemsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetRecordingsParams defines parameters for GetRecordings.
type GetRecordingsParams struct {
	// Root Root location ID
	Root *string `form:"root,omitempty" json:"root,omitempty"`

	// Path Relative path
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// RunAllSeriesRulesParams defines parameters for RunAllSeriesRules.
type RunAllSeriesRulesParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// RunSeriesRuleParams defines parameters for RunSeriesRule.
type RunSeriesRuleParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`
}

// PostServicesIdToggleJSONBody defines parameters for PostServicesIdToggle.
type PostServicesIdToggleJSONBody struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Pagination limit (max 1000)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTimersParams defines parameters for GetTimers.
type GetTimersParams struct {
	State *string `form:"state,omitempty" json:"state,omitempty"`
	From  *int    `form:"from,omitempty" json:"from,omitempty"`
}

// CreateIntentJSONRequestBody defines body for CreateIntent for application/json ContentType.
type CreateIntentJSONRequestBody = IntentRequest

// CreateSeriesRuleJSONRequestBody defines body for CreateSeriesRule for application/json ContentType.
type CreateSeriesRuleJSONRequestBody = SeriesRule

// UpdateSeriesRuleJSONRequestBody defines body for UpdateSeriesRule for application/json ContentType.
type UpdateSeriesRuleJSONRequestBody = SeriesRuleUpdate

// PostServicesNowNextJSONRequestBody defines body for PostServicesNowNext for application/json ContentType.
type PostServicesNowNextJSONRequestBody = NowNextRequest

// PostServicesIdToggleJSONRequestBody defines body for PostServicesIdToggle for application/json ContentType.
type PostServicesIdToggleJSONRequestBody PostServicesIdToggleJSONBody

// ReportPlaybackFeedbackJSONRequestBody defines body for ReportPlaybackFeedback for application/json ContentType.
type ReportPlaybackFeedbackJSONRequestBody = PlaybackFeedbackRequest

// PutSystemConfigJSONRequestBody defines body for PutSystemConfig for application/json ContentType.
type PutSystemConfigJSONRequestBody = ConfigUpdate

// AddTimerJSONRequestBody defines body for AddTimer for application/json ContentType.
type AddTimerJSONRequestBody = TimerCreateRequest

// PreviewConflictsJSONRequestBody defines body for PreviewConflicts for application/json ContentType.
type PreviewConflictsJSONRequestBody = TimerConflictPreviewRequest

// UpdateTimerJSONRequestBody defines body for UpdateTimer for application/json ContentType.
type UpdateTimerJSONRequestBody = TimerPatchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create session cookie
	// (POST /auth/session)
	CreateSession(w http.ResponseWriter, r *http.Request)
	// Get DVR capabilities
	// (GET /dvr/capabilities)
	GetDvrCapabilities(w http.ResponseWriter, r *http.Request)
	// Get DVR recording status
	// (GET /dvr/status)
	GetDvrStatus(w http.ResponseWriter, r *http.Request)
	// Get EPG data
	// (GET /epg)
	GetEpg(w http.ResponseWriter, r *http.Request, params GetEpgParams)
	// Create stream intent (start or stop session)
	// (POST /intents)
	CreateIntent(w http.ResponseWriter, r *http.Request)
	// List library roots
	// (GET /library/roots)
	GetLibraryRoots(w http.ResponseWriter, r *http.Request)
	// List items in library root
	// (GET /library/roots/{root_id}/items)
	GetLibraryRootItems(w http.ResponseWriter, r *http.Request, rootId string, params GetLibraryRootItemsParams)
	// Get recent logs
	// (GET /logs)
	GetLogs(w http.ResponseWriter, r *http.Request)
	// Get current service and EPG
	// (GET /receiver/current)
	GetReceiverCurrent(w http.ResponseWriter, r *http.Request)
	// Browse recordings
	// (GET /recordings)
	GetRecordings(w http.ResponseWriter, r *http.Request, params GetRecordingsParams)
	// Delete a recording
	// (DELETE /recordings/{recordingId})
	DeleteRecording(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get VOD HLS playlist for a recording
	// (GET /recordings/{recordingId}/playlist.m3u8)
	GetRecordingHLSPlaylist(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get VOD HLS playlist metadata (Safari compatibility)
	// (HEAD /recordings/{recordingId}/playlist.m3u8)
	GetRecordingHLSPlaylistHead(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get recording build status
	// (GET /recordings/{recordingId}/status)
	GetRecordingsRecordingIdStatus(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get playback strategy for a recording
	// (GET /recordings/{recordingId}/stream-info)
	GetRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request, recordingId string)
	// Stream recording as MP4 (Direct VOD)
	// (GET /recordings/{recordingId}/stream.mp4)
	StreamRecordingDirect(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get timeshift HLS playlist for a recording
	// (GET /recordings/{recordingId}/timeshift.m3u8)
	GetRecordingHLSTimeshift(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get timeshift HLS playlist metadata (Safari compatibility)
	// (HEAD /recordings/{recordingId}/timeshift.m3u8)
	GetRecordingHLSTimeshiftHead(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get HLS segment for a recording
	// (GET /recordings/{recordingId}/{segment})
	GetRecordingHLSCustomSegment(w http.ResponseWriter, r *http.Request, recordingId string, segment string)
	// Get HLS segment metadata (Safari compatibility)
	// (HEAD /recordings/{recordingId}/{segment})
	GetRecordingHLSCustomSegmentHead(w http.ResponseWriter, r *http.Request, recordingId string, segment string)
	// List all series recording rules
	// (GET /series-rules)
	GetSeriesRules(w http.ResponseWriter, r *http.Request)
	// Create a new series rule
	// (POST /series-rules)
	CreateSeriesRule(w http.ResponseWriter, r *http.Request)
	// Run all enabled series rules immediately
	// (POST /series-rules/run)
	RunAllSeriesRules(w http.ResponseWriter, r *http.Request, params RunAllSeriesRulesParams)
	// Delete a series rule
	// (DELETE /series-rules/{id})
	DeleteSeriesRule(w http.ResponseWriter, r *http.Request, id string)
	// Update an existing series rule
	// (PUT /series-rules/{id})
	UpdateSeriesRule(w http.ResponseWriter, r *http.Request, id string)
	// Run a specific series rule immediately
	// (POST /series-rules/{id}/run)
	RunSeriesRule(w http.ResponseWriter, r *http.Request, id string, params RunSeriesRuleParams)
	// List all services (channels)
	// (GET /services)
	GetServices(w http.ResponseWriter, r *http.Request, params GetServicesParams)
	// List all bouquets
	// (GET /services/bouquets)
	GetServicesBouquets(w http.ResponseWriter, r *http.Request)
	// Get now/next EPG for a list of services
	// (POST /services/now-next)
	PostServicesNowNext(w http.ResponseWriter, r *http.Request)
	// Toggle service enabled state
	// (POST /services/{id}/toggle)
	PostServicesIdToggle(w http.ResponseWriter, r *http.Request, id string)
	// List all sessions (admin only)
	// (GET /sessions)
	ListSessions(w http.ResponseWriter, r *http.Request, params ListSessionsParams)
	// Get session state
	// (GET /sessions/{sessionID})
	GetSessionState(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID)
	// Serve HLS playlist or segment
	// (GET /sessions/{sessionID}/hls/{filename})
	ServeHLS(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string)
	// Get HLS content metadata (Safari compatibility)
	// (HEAD /sessions/{sessionID}/hls/{filename})
	ServeHLSHead(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string)
	// Report playback feedback (e.g. valid errors)
	// (POST /sessions/{sessionId}/feedback)
	ReportPlaybackFeedback(w http.ResponseWriter, r *http.Request, sessionId openapi_types.UUID)
	// List active streams
	// (GET /streams)
	GetStreams(w http.ResponseWriter, r *http.Request)
	// Terminate a stream session
	// (DELETE /streams/{id})
	DeleteStreamsId(w http.ResponseWriter, r *http.Request, id string)
	// Get system configuration
	// (GET /system/config)
	GetSystemConfig(w http.ResponseWriter, r *http.Request)
	// Update system configuration
	// (PUT /system/config)
	PutSystemConfig(w http.ResponseWriter, r *http.Request)
	// Get system diagnostics
	// (GET /system/diagnostics)
	GetSystemDiagnostics(w http.ResponseWriter, r *http.Request)
	// Get system health
	// (GET /system/health)
	GetSystemHealth(w http.ResponseWriter, r *http.Request)
	// Get minimal system health
	// (GET /system/healthz)
	GetSystemHealthz(w http.ResponseWriter, r *http.Request)
	// Trigger data refresh (EPG/Channels)
	// (POST /system/refresh)
	PostSystemRefresh(w http.ResponseWriter, r *http.Request)
	// Get status of the capability scan
	// (GET /system/scan)
	GetSystemScanStatus(w http.ResponseWriter, r *http.Request)
	// Trigger a background scan of all channels for capabilities
	// (POST /system/scan)
	TriggerSystemScan(w http.ResponseWriter, r *http.Request)
	// List all timers
	// (GET /timers)
	GetTimers(w http.ResponseWriter, r *http.Request, params GetTimersParams)
	// Create a timer
	// (POST /timers)
	AddTimer(w http.ResponseWriter, r *http.Request)
	// Preview conflicts
	// (POST /timers/conflicts:preview)
	PreviewConflicts(w http.ResponseWriter, r *http.Request)
	// Delete timer
	// (DELETE /timers/{timerId})
	DeleteTimer(w http.ResponseWriter, r *http.Request, timerId string)
	// Get timer
	// (GET /timers/{timerId})
	GetTimer(w http.ResponseWriter, r *http.Request, timerId string)
	// Edit timer
	// (PATCH /timers/{timerId})
	UpdateTimer(w http.ResponseWriter, r *http.Request, timerId string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Create session cookie
// (POST /auth/session)
func (_ Unimplemented) CreateSession(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get DVR capabilities
// (GET /dvr/capabilities)
func (_ Unimplemented) GetDvrCapabilities(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get DVR recording status
// (GET /dvr/status)
func (_ Unimplemented) GetDvrStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get EPG data
// (GET /epg)
func (_ Unimplemented) GetEpg(w http.ResponseWriter, r *http.Request, params GetEpgParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create stream intent (start or stop session)
// (POST /intents)
func (_ Unimplemented) CreateIntent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List library roots
// (GET /library/roots)
func (_ Unimplemented) GetLibraryRoots(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List items in library root
// (GET /library/roots/{root_id}/items)
func (_ Unimplemented) GetLibraryRootItems(w http.ResponseWriter, r *http.Request, rootId string, params GetLibraryRootItemsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get recent logs
// (GET /logs)
func (_ Unimplemented) GetLogs(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current service and EPG
// (GET /receiver/current)
func (_ Unimplemented) GetReceiverCurrent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Browse recordings
// (GET /recordings)
func (_ Unimplemented) GetRecordings(w http.ResponseWriter, r *http.Request, params GetRecordingsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a recording
// (DELETE /recordings/{recordingId})
func (_ Unimplemented) DeleteRecording(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get VOD HLS playlist for a recording
// (GET /recordings/{recordingId}/playlist.m3u8)
func (_ Unimplemented) GetRecordingHLSPlaylist(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get VOD HLS playlist metadata (Safari compatibility)
// (HEAD /recordings/{recordingId}/playlist.m3u8)
func (_ Unimplemented) GetRecordingHLSPlaylistHead(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get recording build status
// (GET /recordings/{recordingId}/status)
func (_ Unimplemented) GetRecordingsRecordingIdStatus(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get playback strategy for a recording
// (GET /recordings/{recordingId}/stream-info)
func (_ Unimplemented) GetRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stream recording as MP4 (Direct VOD)
// (GET /recordings/{recordingId}/stream.mp4)
func (_ Unimplemented) StreamRecordingDirect(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get timeshift HLS playlist for a recording
// (GET /recordings/{recordingId}/timeshift.m3u8)
func (_ Unimplemented) GetRecordingHLSTimeshift(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get timeshift HLS playlist metadata (Safari compatibility)
// (HEAD /recordings/{recordingId}/timeshift.m3u8)
func (_ Unimplemented) GetRecordingHLSTimeshiftHead(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get HLS segment for a recording
// (GET /recordings/{recordingId}/{segment})
func (_ Unimplemented) GetRecordingHLSCustomSegment(w http.ResponseWriter, r *http.Request, recordingId string, segment string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get HLS segment metadata (Safari compatibility)
// (HEAD /recordings/{recordingId}/{segment})
func (_ Unimplemented) GetRecordingHLSCustomSegmentHead(w http.ResponseWriter, r *http.Request, recordingId string, segment string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all series recording rules
// (GET /series-rules)
func (_ Unimplemented) GetSeriesRules(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new series rule
// (POST /series-rules)
func (_ Unimplemented) CreateSeriesRule(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Run all enabled series rules immediately
// (POST /series-rules/run)
func (_ Unimplemented) RunAllSeriesRules(w http.ResponseWriter, r *http.Request, params RunAllSeriesRulesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a series rule
// (DELETE /series-rules/{id})
func (_ Unimplemented) DeleteSeriesRule(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update an existing series rule
// (PUT /series-rules/{id})
func (_ Unimplemented) UpdateSeriesRule(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Run a specific series rule immediately
// (POST /series-rules/{id}/run)
func (_ Unimplemented) RunSeriesRule(w http.ResponseWriter, r *http.Request, id string, params RunSeriesRuleParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all services (channels)
// (GET /services)
func (_ Unimplemented) GetServices(w http.ResponseWriter, r *http.Request, params GetServicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all bouquets
// (GET /services/bouquets)
func (_ Unimplemented) GetServicesBouquets(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get now/next EPG for a list of services
// (POST /services/now-next)
func (_ Unimplemented) PostServicesNowNext(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Toggle service enabled state
// (POST /services/{id}/toggle)
func (_ Unimplemented) PostServicesIdToggle(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all sessions (admin only)
// (GET /sessions)
func (_ Unimplemented) ListSessions(w http.ResponseWriter, r *http.Request, params ListSessionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get session state
// (GET /sessions/{sessionID})
func (_ Unimplemented) GetSessionState(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Serve HLS playlist or segment
// (GET /sessions/{sessionID}/hls/{filename})
func (_ Unimplemented) ServeHLS(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get HLS content metadata (Safari compatibility)
// (HEAD /sessions/{sessionID}/hls/{filename})
func (_ Unimplemented) ServeHLSHead(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Report playback feedback (e.g. valid errors)
// (POST /sessions/{sessionId}/feedback)
func (_ Unimplemented) ReportPlaybackFeedback(w http.ResponseWriter, r *http.Request, sessionId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List active streams
// (GET /streams)
func (_ Unimplemented) GetStreams(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Terminate a stream session
// (DELETE /streams/{id})
func (_ Unimplemented) DeleteStreamsId(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get system configuration
// (GET /system/config)
func (_ Unimplemented) GetSystemConfig(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update system configuration
// (PUT /system/config)
func (_ Unimplemented) PutSystemConfig(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get system diagnostics
// (GET /system/diagnostics)
func (_ Unimplemented) GetSystemDiagnostics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get system health
// (GET /system/health)
func (_ Unimplemented) GetSystemHealth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get minimal system health
// (GET /system/healthz)
func (_ Unimplemented) GetSystemHealthz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Trigger data refresh (EPG/Channels)
// (POST /system/refresh)
func (_ Unimplemented) PostSystemRefresh(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get status of the capability scan
// (GET /system/scan)
func (_ Unimplemented) GetSystemScanStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Trigger a background scan of all channels for capabilities
// (POST /system/scan)
func (_ Unimplemented) TriggerSystemScan(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all timers
// (GET /timers)
func (_ Unimplemented) GetTimers(w http.ResponseWriter, r *http.Request, params GetTimersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a timer
// (POST /timers)
func (_ Unimplemented) AddTimer(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Preview conflicts
// (POST /timers/conflicts:preview)
func (_ Unimplemented) PreviewConflicts(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete timer
// (DELETE /timers/{timerId})
func (_ Unimplemented) DeleteTimer(w http.ResponseWriter, r *http.Request, timerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get timer
// (GET /timers/{timerId})
func (_ Unimplemented) GetTimer(w http.ResponseWriter, r *http.Request, timerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Edit timer
// (PATCH /timers/{timerId})
func (_ Unimplemented) UpdateTimer(w http.ResponseWriter, r *http.Request, timerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateSession operation middleware
func (siw *ServerInterfaceWrapper) CreateSession(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSession(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDvrCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetDvrCapabilities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDvrCapabilities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetDvrStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDvrStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDvrStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetEpg operation middleware
func (siw *ServerInterfaceWrapper) GetEpg(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEpgParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "bouquet" -------------

	err = runtime.BindQueryParameter("form", true, false, "bouquet", r.URL.Query(), &params.Bouquet)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bouquet", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEpg(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateIntent operation middleware
func (siw *ServerInterfaceWrapper) CreateIntent(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateIntent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLibraryRoots operation middleware
func (siw *ServerInterfaceWrapper) GetLibraryRoots(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLibraryRoots(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLibraryRootItems operation middleware
func (siw *ServerInterfaceWrapper) GetLibraryRootItems(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "root_id" -------------
	var rootId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "root_id", runtime.ParamLocationPath, chi.URLParam(r, "root_id"), &rootId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "root_id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLibraryRootItemsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLibraryRootItems(w, r, rootId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLogs operation middleware
func (siw *ServerInterfaceWrapper) GetLogs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:admin"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLogs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetReceiverCurrent operation middleware
func (siw *ServerInterfaceWrapper) GetReceiverCurrent(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetReceiverCurrent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordings operation middleware
func (siw *ServerInterfaceWrapper) GetRecordings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordingsParams

	// ------------- Optional query parameter "root" -------------

	err = runtime.BindQueryParameter("form", true, false, "root", r.URL.Query(), &params.Root)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "root", Err: err})
		return
	}

	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordings(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteRecording operation middleware
func (siw *ServerInterfaceWrapper) DeleteRecording(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRecording(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingHLSPlaylist operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSPlaylist(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSPlaylist(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingHLSPlaylistHead operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSPlaylistHead(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSPlaylistHead(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingsRecordingIdStatus operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingsRecordingIdStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingsRecordingIdStatus(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingPlaybackInfo operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingPlaybackInfo(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// StreamRecordingDirect operation middleware
func (siw *ServerInterfaceWrapper) StreamRecordingDirect(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StreamRecordingDirect(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingHLSTimeshift operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSTimeshift(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSTimeshift(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingHLSTimeshiftHead operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSTimeshiftHead(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSTimeshiftHead(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingHLSCustomSegment operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSCustomSegment(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	// ------------- Path parameter "segment" -------------
	var segment string

	err = runtime.BindStyledParameterWithLocation("simple", false, "segment", runtime.ParamLocationPath, chi.URLParam(r, "segment"), &segment)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "segment", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSCustomSegment(w, r, recordingId, segment)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetRecordingHLSCustomSegmentHead operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSCustomSegmentHead(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recordingId", runtime.ParamLocationPath, chi.URLParam(r, "recordingId"), &recordingId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	// ------------- Path parameter "segment" -------------
	var segment string

	err = runtime.BindStyledParameterWithLocation("simple", false, "segment", runtime.ParamLocationPath, chi.URLParam(r, "segment"), &segment)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "segment", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSCustomSegmentHead(w, r, recordingId, segment)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSeriesRules operation middleware
func (siw *ServerInterfaceWrapper) GetSeriesRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSeriesRules(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) CreateSeriesRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSeriesRule(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RunAllSeriesRules operation middleware
func (siw *ServerInterfaceWrapper) RunAllSeriesRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunAllSeriesRulesParams

	// ------------- Optional query parameter "trigger" -------------

	err = runtime.BindQueryParameter("form", true, false, "trigger", r.URL.Query(), &params.Trigger)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "trigger", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunAllSeriesRules(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) DeleteSeriesRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSeriesRule(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) UpdateSeriesRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateSeriesRule(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// RunSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) RunSeriesRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunSeriesRuleParams

	// ------------- Optional query parameter "trigger" -------------

	err = runtime.BindQueryParameter("form", true, false, "trigger", r.URL.Query(), &params.Trigger)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "trigger", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunSeriesRule(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetServices operation middleware
func (siw *ServerInterfaceWrapper) GetServices(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServicesParams

	// ------------- Optional query parameter "bouquet" -------------

	err = runtime.BindQueryParameter("form", true, false, "bouquet", r.URL.Query(), &params.Bouquet)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bouquet", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetServicesBouquets operation middleware
func (siw *ServerInterfaceWrapper) GetServicesBouquets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServicesBouquets(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostServicesNowNext operation middleware
func (siw *ServerInterfaceWrapper) PostServicesNowNext(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostServicesNowNext(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostServicesIdToggle operation middleware
func (siw *ServerInterfaceWrapper) PostServicesIdToggle(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostServicesIdToggle(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSessions operation middleware
func (siw *ServerInterfaceWrapper) ListSessions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSessionsParams

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSessions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSessionState operation middleware
func (siw *ServerInterfaceWrapper) GetSessionState(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSessionState(w, r, sessionID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ServeHLS operation middleware
func (siw *ServerInterfaceWrapper) ServeHLS(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithLocation("simple", false, "filename", runtime.ParamLocationPath, chi.URLParam(r, "filename"), &filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServeHLS(w, r, sessionID, filename)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ServeHLSHead operation middleware
func (siw *ServerInterfaceWrapper) ServeHLSHead(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionID", runtime.ParamLocationPath, chi.URLParam(r, "sessionID"), &sessionID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithLocation("simple", false, "filename", runtime.ParamLocationPath, chi.URLParam(r, "filename"), &filename)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServeHLSHead(w, r, sessionID, filename)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ReportPlaybackFeedback operation middleware
func (siw *ServerInterfaceWrapper) ReportPlaybackFeedback(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "sessionId", runtime.ParamLocationPath, chi.URLParam(r, "sessionId"), &sessionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReportPlaybackFeedback(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetStreams operation middleware
func (siw *ServerInterfaceWrapper) GetStreams(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:admin"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStreams(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteStreamsId operation middleware
func (siw *ServerInterfaceWrapper) DeleteStreamsId(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteStreamsId(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSystemConfig operation middleware
func (siw *ServerInterfaceWrapper) GetSystemConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:admin"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutSystemConfig operation middleware
func (siw *ServerInterfaceWrapper) PutSystemConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:admin"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutSystemConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSystemDiagnostics operation middleware
func (siw *ServerInterfaceWrapper) GetSystemDiagnostics(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemDiagnostics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSystemHealth operation middleware
func (siw *ServerInterfaceWrapper) GetSystemHealth(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSystemHealthz operation middleware
func (siw *ServerInterfaceWrapper) GetSystemHealthz(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemHealthz(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PostSystemRefresh operation middleware
func (siw *ServerInterfaceWrapper) PostSystemRefresh(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSystemRefresh(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSystemScanStatus operation middleware
func (siw *ServerInterfaceWrapper) GetSystemScanStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemScanStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// TriggerSystemScan operation middleware
func (siw *ServerInterfaceWrapper) TriggerSystemScan(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TriggerSystemScan(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTimers operation middleware
func (siw *ServerInterfaceWrapper) GetTimers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTimersParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTimers(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddTimer operation middleware
func (siw *ServerInterfaceWrapper) AddTimer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimer(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PreviewConflicts operation middleware
func (siw *ServerInterfaceWrapper) PreviewConflicts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PreviewConflicts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteTimer operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "timerId" -------------
	var timerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "timerId", runtime.ParamLocationPath, chi.URLParam(r, "timerId"), &timerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timerId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimer(w, r, timerId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetTimer operation middleware
func (siw *ServerInterfaceWrapper) GetTimer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "timerId" -------------
	var timerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "timerId", runtime.ParamLocationPath, chi.URLParam(r, "timerId"), &timerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timerId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:read"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTimer(w, r, timerId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateTimer operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "timerId" -------------
	var timerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "timerId", runtime.ParamLocationPath, chi.URLParam(r, "timerId"), &timerId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timerId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{"v3:write"})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimer(w, r, timerId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/session", wrapper.CreateSession)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dvr/capabilities", wrapper.GetDvrCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dvr/status", wrapper.GetDvrStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/epg", wrapper.GetEpg)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/intents", wrapper.CreateIntent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/library/roots", wrapper.GetLibraryRoots)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/library/roots/{root_id}/items", wrapper.GetLibraryRootItems)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/logs", wrapper.GetLogs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/receiver/current", wrapper.GetReceiverCurrent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings", wrapper.GetRecordings)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/recordings/{recordingId}", wrapper.DeleteRecording)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/playlist.m3u8", wrapper.GetRecordingHLSPlaylist)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/playlist.m3u8", wrapper.GetRecordingHLSPlaylistHead)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/status", wrapper.GetRecordingsRecordingIdStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/stream-info", wrapper.GetRecordingPlaybackInfo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/stream.mp4", wrapper.StreamRecordingDirect)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/timeshift.m3u8", wrapper.GetRecordingHLSTimeshift)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/timeshift.m3u8", wrapper.GetRecordingHLSTimeshiftHead)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/{segment}", wrapper.GetRecordingHLSCustomSegment)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/{segment}", wrapper.GetRecordingHLSCustomSegmentHead)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/series-rules", wrapper.GetSeriesRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/series-rules", wrapper.CreateSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/series-rules/run", wrapper.RunAllSeriesRules)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/series-rules/{id}", wrapper.DeleteSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/series-rules/{id}", wrapper.UpdateSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/series-rules/{id}/run", wrapper.RunSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/services", wrapper.GetServices)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/services/bouquets", wrapper.GetServicesBouquets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/services/now-next", wrapper.PostServicesNowNext)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/services/{id}/toggle", wrapper.PostServicesIdToggle)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sessions", wrapper.ListSessions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sessions/{sessionID}", wrapper.GetSessionState)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sessions/{sessionID}/hls/{filename}", wrapper.ServeHLS)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/sessions/{sessionID}/hls/{filename}", wrapper.ServeHLSHead)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sessions/{sessionId}/feedback", wrapper.ReportPlaybackFeedback)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/streams", wrapper.GetStreams)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/streams/{id}", wrapper.DeleteStreamsId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/config", wrapper.GetSystemConfig)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/system/config", wrapper.PutSystemConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/diagnostics", wrapper.GetSystemDiagnostics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/health", wrapper.GetSystemHealth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/healthz", wrapper.GetSystemHealthz)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/system/refresh", wrapper.PostSystemRefresh)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/scan", wrapper.GetSystemScanStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/system/scan", wrapper.TriggerSystemScan)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/timers", wrapper.GetTimers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/timers", wrapper.AddTimer)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/timers/conflicts:preview", wrapper.PreviewConflicts)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/timers/{timerId}", wrapper.DeleteTimer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/timers/{timerId}", wrapper.GetTimer)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/timers/{timerId}", wrapper.UpdateTimer)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
