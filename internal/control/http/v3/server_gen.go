// Package v3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v3

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ComponentStatusStatus.
const (
	ComponentStatusStatusError ComponentStatusStatus = "error"
	ComponentStatusStatusOk    ComponentStatusStatus = "ok"
)

// Defines values for CurrentServiceInfoStatus.
const (
	CurrentServiceInfoStatusOk          CurrentServiceInfoStatus = "ok"
	CurrentServiceInfoStatusUnavailable CurrentServiceInfoStatus = "unavailable"
)

// Defines values for DvrCapabilitiesSeriesMode.
const (
	DvrCapabilitiesSeriesModeDelegated DvrCapabilitiesSeriesMode = "delegated"
	DvrCapabilitiesSeriesModeManaged   DvrCapabilitiesSeriesMode = "managed"
	DvrCapabilitiesSeriesModeNone      DvrCapabilitiesSeriesMode = "none"
)

// Defines values for EPGConfigSource.
const (
	EPGConfigSourceBouquet    EPGConfigSource = "bouquet"
	EPGConfigSourcePerService EPGConfigSource = "per-service"
)

// Defines values for EPGStatusStatus.
const (
	EPGStatusStatusMissing EPGStatusStatus = "missing"
	EPGStatusStatusOk      EPGStatusStatus = "ok"
)

// Defines values for IntentRequestHwaccel.
const (
	Auto  IntentRequestHwaccel = "auto"
	Force IntentRequestHwaccel = "force"
	Off   IntentRequestHwaccel = "off"
)

// Defines values for IntentRequestType.
const (
	StreamStart IntentRequestType = "stream.start"
	StreamStop  IntentRequestType = "stream.stop"
)

// Defines values for PlaybackDecisionMode.
const (
	PlaybackDecisionModeDeny         PlaybackDecisionMode = "deny"
	PlaybackDecisionModeDirectPlay   PlaybackDecisionMode = "direct_play"
	PlaybackDecisionModeDirectStream PlaybackDecisionMode = "direct_stream"
	PlaybackDecisionModeTranscode    PlaybackDecisionMode = "transcode"
)

// Defines values for PlaybackDecisionSelectedOutputKind.
const (
	PlaybackDecisionSelectedOutputKindFile PlaybackDecisionSelectedOutputKind = "file"
	PlaybackDecisionSelectedOutputKindHls  PlaybackDecisionSelectedOutputKind = "hls"
)

// Defines values for PlaybackFeedbackRequestEvent.
const (
	PlaybackFeedbackRequestEventError   PlaybackFeedbackRequestEvent = "error"
	PlaybackFeedbackRequestEventInfo    PlaybackFeedbackRequestEvent = "info"
	PlaybackFeedbackRequestEventWarning PlaybackFeedbackRequestEvent = "warning"
)

// Defines values for PlaybackInfoDurationSource.
const (
	Cache PlaybackInfoDurationSource = "cache"
	Probe PlaybackInfoDurationSource = "probe"
	Store PlaybackInfoDurationSource = "store"
)

// Defines values for PlaybackInfoMode.
const (
	PlaybackInfoModeDeny      PlaybackInfoMode = "deny"
	PlaybackInfoModeDirectMp4 PlaybackInfoMode = "direct_mp4"
	PlaybackInfoModeHls       PlaybackInfoMode = "hls"
)

// Defines values for PlaybackInfoReason.
const (
	PlaybackInfoReasonContainerMismatch PlaybackInfoReason = "container_mismatch"
	PlaybackInfoReasonDirectplayMatch   PlaybackInfoReason = "directplay_match"
	PlaybackInfoReasonTranscodeAll      PlaybackInfoReason = "transcode_all"
	PlaybackInfoReasonTranscodeAudio    PlaybackInfoReason = "transcode_audio"
	PlaybackInfoReasonTranscodeVideo    PlaybackInfoReason = "transcode_video"
	PlaybackInfoReasonUnknown           PlaybackInfoReason = "unknown"
)

// Defines values for PlaybackOutputFileKind.
const (
	PlaybackOutputFileKindFile PlaybackOutputFileKind = "file"
)

// Defines values for PlaybackOutputHlsKind.
const (
	Hls PlaybackOutputHlsKind = "hls"
)

// Defines values for ProblemCapabilitiesInvalidCode.
const (
	CapabilitiesInvalid ProblemCapabilitiesInvalidCode = "capabilities_invalid"
)

// Defines values for ProblemCapabilitiesMissingCode.
const (
	CapabilitiesMissing ProblemCapabilitiesMissingCode = "capabilities_missing"
)

// Defines values for ProblemDecisionAmbiguousCode.
const (
	DecisionAmbiguous ProblemDecisionAmbiguousCode = "decision_ambiguous"
)

// Defines values for RecordingBuildStatusAttemptMode.
const (
	Fast   RecordingBuildStatusAttemptMode = "fast"
	Robust RecordingBuildStatusAttemptMode = "robust"
)

// Defines values for RecordingBuildStatusState.
const (
	RecordingBuildStatusStateFAILED  RecordingBuildStatusState = "FAILED"
	RecordingBuildStatusStateIDLE    RecordingBuildStatusState = "IDLE"
	RecordingBuildStatusStateREADY   RecordingBuildStatusState = "READY"
	RecordingBuildStatusStateRUNNING RecordingBuildStatusState = "RUNNING"
)

// Defines values for RecordingItemStatus.
const (
	RecordingItemStatusCompleted RecordingItemStatus = "completed"
	RecordingItemStatusDeleting  RecordingItemStatus = "deleting"
	RecordingItemStatusFailed    RecordingItemStatus = "failed"
	RecordingItemStatusPending   RecordingItemStatus = "pending"
	RecordingItemStatusRecording RecordingItemStatus = "recording"
)

// Defines values for ScanStatusState.
const (
	ScanStatusStateCancelled ScanStatusState = "cancelled"
	ScanStatusStateComplete  ScanStatusState = "complete"
	ScanStatusStateFailed    ScanStatusState = "failed"
	ScanStatusStateIdle      ScanStatusState = "idle"
	ScanStatusStateRunning   ScanStatusState = "running"
)

// Defines values for SeriesRuleRunReportStatus.
const (
	Failed  SeriesRuleRunReportStatus = "failed"
	Partial SeriesRuleRunReportStatus = "partial"
	Success SeriesRuleRunReportStatus = "success"
)

// Defines values for SessionRecordReason.
const (
	SessionRecordReasonRBADREQUEST         SessionRecordReason = "R_BAD_REQUEST"
	SessionRecordReasonRCANCELLED          SessionRecordReason = "R_CANCELLED"
	SessionRecordReasonRCLIENTSTOP         SessionRecordReason = "R_CLIENT_STOP"
	SessionRecordReasonRFFMPEGSTARTFAILED  SessionRecordReason = "R_FFMPEG_START_FAILED"
	SessionRecordReasonRIDLETIMEOUT        SessionRecordReason = "R_IDLE_TIMEOUT"
	SessionRecordReasonRINVARIANTVIOLATION SessionRecordReason = "R_INVARIANT_VIOLATION"
	SessionRecordReasonRLEASEBUSY          SessionRecordReason = "R_LEASE_BUSY"
	SessionRecordReasonRLEASEEXPIRED       SessionRecordReason = "R_LEASE_EXPIRED"
	SessionRecordReasonRNONE               SessionRecordReason = "R_NONE"
	SessionRecordReasonRNOTFOUND           SessionRecordReason = "R_NOT_FOUND"
	SessionRecordReasonRPACKAGERFAILED     SessionRecordReason = "R_PACKAGER_FAILED"
	SessionRecordReasonRPROCESSENDED       SessionRecordReason = "R_PROCESS_ENDED"
	SessionRecordReasonRTUNEFAILED         SessionRecordReason = "R_TUNE_FAILED"
	SessionRecordReasonRTUNETIMEOUT        SessionRecordReason = "R_TUNE_TIMEOUT"
	SessionRecordReasonRUNKNOWN            SessionRecordReason = "R_UNKNOWN"
)

// Defines values for SessionRecordState.
const (
	SessionRecordStateCANCELLED SessionRecordState = "CANCELLED"
	SessionRecordStateDRAINING  SessionRecordState = "DRAINING"
	SessionRecordStateFAILED    SessionRecordState = "FAILED"
	SessionRecordStateNEW       SessionRecordState = "NEW"
	SessionRecordStatePRIMING   SessionRecordState = "PRIMING"
	SessionRecordStateREADY     SessionRecordState = "READY"
	SessionRecordStateSTARTING  SessionRecordState = "STARTING"
	SessionRecordStateSTOPPED   SessionRecordState = "STOPPED"
	SessionRecordStateSTOPPING  SessionRecordState = "STOPPING"
)

// Defines values for SessionResponseMode.
const (
	LIVE      SessionResponseMode = "LIVE"
	RECORDING SessionResponseMode = "RECORDING"
)

// Defines values for SessionResponseReason.
const (
	SessionResponseReasonRBADREQUEST         SessionResponseReason = "R_BAD_REQUEST"
	SessionResponseReasonRCANCELLED          SessionResponseReason = "R_CANCELLED"
	SessionResponseReasonRCLIENTSTOP         SessionResponseReason = "R_CLIENT_STOP"
	SessionResponseReasonRFFMPEGSTARTFAILED  SessionResponseReason = "R_FFMPEG_START_FAILED"
	SessionResponseReasonRIDLETIMEOUT        SessionResponseReason = "R_IDLE_TIMEOUT"
	SessionResponseReasonRINVARIANTVIOLATION SessionResponseReason = "R_INVARIANT_VIOLATION"
	SessionResponseReasonRLEASEBUSY          SessionResponseReason = "R_LEASE_BUSY"
	SessionResponseReasonRLEASEEXPIRED       SessionResponseReason = "R_LEASE_EXPIRED"
	SessionResponseReasonRNONE               SessionResponseReason = "R_NONE"
	SessionResponseReasonRNOTFOUND           SessionResponseReason = "R_NOT_FOUND"
	SessionResponseReasonRPACKAGERFAILED     SessionResponseReason = "R_PACKAGER_FAILED"
	SessionResponseReasonRPROCESSENDED       SessionResponseReason = "R_PROCESS_ENDED"
	SessionResponseReasonRTUNEFAILED         SessionResponseReason = "R_TUNE_FAILED"
	SessionResponseReasonRTUNETIMEOUT        SessionResponseReason = "R_TUNE_TIMEOUT"
	SessionResponseReasonRUNKNOWN            SessionResponseReason = "R_UNKNOWN"
)

// Defines values for SessionResponseState.
const (
	ACTIVE    SessionResponseState = "ACTIVE"
	BUFFERING SessionResponseState = "BUFFERING"
	CANCELLED SessionResponseState = "CANCELLED"
	DRAINING  SessionResponseState = "DRAINING"
	ENDING    SessionResponseState = "ENDING"
	ERROR     SessionResponseState = "ERROR"
	FAILED    SessionResponseState = "FAILED"
	IDLE      SessionResponseState = "IDLE"
	NEW       SessionResponseState = "NEW"
	PRIMING   SessionResponseState = "PRIMING"
	READY     SessionResponseState = "READY"
	STALLED   SessionResponseState = "STALLED"
	STARTING  SessionResponseState = "STARTING"
	STOPPED   SessionResponseState = "STOPPED"
	STOPPING  SessionResponseState = "STOPPING"
)

// Defines values for StorageItemAccess.
const (
	StorageItemAccessNone StorageItemAccess = "none"
	StorageItemAccessRo   StorageItemAccess = "ro"
	StorageItemAccessRw   StorageItemAccess = "rw"
)

// Defines values for StorageItemHealthStatus.
const (
	StorageItemHealthStatusError   StorageItemHealthStatus = "error"
	StorageItemHealthStatusOk      StorageItemHealthStatus = "ok"
	StorageItemHealthStatusSkipped StorageItemHealthStatus = "skipped"
	StorageItemHealthStatusTimeout StorageItemHealthStatus = "timeout"
	StorageItemHealthStatusUnknown StorageItemHealthStatus = "unknown"
)

// Defines values for StorageItemMountStatus.
const (
	StorageItemMountStatusMounted   StorageItemMountStatus = "mounted"
	StorageItemMountStatusUnknown   StorageItemMountStatus = "unknown"
	StorageItemMountStatusUnmounted StorageItemMountStatus = "unmounted"
)

// Defines values for StreamSessionState.
const (
	StreamSessionStateActive    StreamSessionState = "active"
	StreamSessionStateBuffering StreamSessionState = "buffering"
	StreamSessionStateEnding    StreamSessionState = "ending"
	StreamSessionStateError     StreamSessionState = "error"
	StreamSessionStateIdle      StreamSessionState = "idle"
	StreamSessionStateStalled   StreamSessionState = "stalled"
	StreamSessionStateStarting  StreamSessionState = "starting"
)

// Defines values for StreamingConfigDeliveryPolicy.
const (
	Universal StreamingConfigDeliveryPolicy = "universal"
)

// Defines values for SystemHealthStatus.
const (
	Degraded SystemHealthStatus = "degraded"
	Error    SystemHealthStatus = "error"
	Ok       SystemHealthStatus = "ok"
)

// Defines values for TimerState.
const (
	TimerStateCompleted TimerState = "completed"
	TimerStateDisabled  TimerState = "disabled"
	TimerStateRecording TimerState = "recording"
	TimerStateScheduled TimerState = "scheduled"
	TimerStateUnknown   TimerState = "unknown"
)

// Defines values for TimerConflictType.
const (
	TimerConflictTypeDuplicate  TimerConflictType = "duplicate"
	TimerConflictTypeOverlap    TimerConflictType = "overlap"
	TimerConflictTypeTunerLimit TimerConflictType = "tuner_limit"
	TimerConflictTypeUnknown    TimerConflictType = "unknown"
)

// Defines values for TimerConflictPreviewRequestMode.
const (
	Conservative  TimerConflictPreviewRequestMode = "conservative"
	ReceiverAware TimerConflictPreviewRequestMode = "receiverAware"
)

// Defines values for TimerConflictPreviewResponseSuggestionsKind.
const (
	ReducePadding TimerConflictPreviewResponseSuggestionsKind = "reduce_padding"
	ShiftEnd      TimerConflictPreviewResponseSuggestionsKind = "shift_end"
	ShiftStart    TimerConflictPreviewResponseSuggestionsKind = "shift_start"
)

// Defines values for TimerCreateRequestAfterEvent.
const (
	Deepstandby TimerCreateRequestAfterEvent = "deepstandby"
	Default     TimerCreateRequestAfterEvent = "default"
	Nothing     TimerCreateRequestAfterEvent = "nothing"
	Standby     TimerCreateRequestAfterEvent = "standby"
)

// APIError defines model for APIError.
type APIError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Optional additional context
	Details interface{} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Request ID for debugging
	RequestId string `json:"requestId"`
}

// AppConfig defines model for AppConfig.
type AppConfig struct {
	Bouquets  *[]string        `json:"bouquets,omitempty"`
	DataDir   *string          `json:"dataDir,omitempty"`
	Epg       *EPGConfig       `json:"epg,omitempty"`
	LogLevel  *string          `json:"logLevel,omitempty"`
	OpenWebIF *OpenWebIFConfig `json:"openWebIF,omitempty"`
	Picons    *PiconsConfig    `json:"picons,omitempty"`

	// Streaming Streaming delivery policy configuration (ADR-00X)
	Streaming    *StreamingConfig    `json:"streaming,omitempty"`
	Verification *VerificationConfig `json:"verification,omitempty"`
	Version      *string             `json:"version,omitempty"`
}

// Bouquet defines model for Bouquet.
type Bouquet struct {
	Name     *string `json:"name,omitempty"`
	Services *int    `json:"services,omitempty"`
}

// Breadcrumb defines model for Breadcrumb.
type Breadcrumb struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// ComponentStatus defines model for ComponentStatus.
type ComponentStatus struct {
	LastCheck *time.Time             `json:"lastCheck,omitempty"`
	Status    *ComponentStatusStatus `json:"status,omitempty"`
}

// ComponentStatusStatus defines model for ComponentStatus.Status.
type ComponentStatusStatus string

// ConfigUpdate defines model for ConfigUpdate.
type ConfigUpdate struct {
	Bouquets *[]string  `json:"bouquets,omitempty"`
	Epg      *EPGConfig `json:"epg,omitempty"`

	// LogLevel Log level to set (debug, info, warn, error)
	LogLevel     *string             `json:"logLevel,omitempty"`
	OpenWebIF    *OpenWebIFConfig    `json:"openWebIF,omitempty"`
	Picons       *PiconsConfig       `json:"picons,omitempty"`
	Verification *VerificationConfig `json:"verification,omitempty"`
}

// CurrentServiceInfo Current live service and EPG information from receiver
type CurrentServiceInfo struct {
	Channel *struct {
		Name *string `json:"name,omitempty"`
		Ref  *string `json:"ref,omitempty"`
	} `json:"channel,omitempty"`
	Next *struct {
		Title *string `json:"title,omitempty"`
	} `json:"next,omitempty"`
	Now *struct {
		BeginTimestamp *int64  `json:"beginTimestamp,omitempty"`
		Description    *string `json:"description,omitempty"`
		DurationSec    *int    `json:"durationSec,omitempty"`
		Title          *string `json:"title,omitempty"`
	} `json:"now,omitempty"`
	Status *CurrentServiceInfoStatus `json:"status,omitempty"`
}

// CurrentServiceInfoStatus defines model for CurrentServiceInfo.Status.
type CurrentServiceInfoStatus string

// DirectoryItem defines model for DirectoryItem.
type DirectoryItem struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// DvrCapabilities defines model for DvrCapabilities.
type DvrCapabilities struct {
	Conflicts struct {
		Preview       *bool `json:"preview,omitempty"`
		ReceiverAware *bool `json:"receiverAware,omitempty"`
	} `json:"conflicts"`
	Series struct {
		DelegatedProvider *string                    `json:"delegatedProvider,omitempty"`
		Mode              *DvrCapabilitiesSeriesMode `json:"mode,omitempty"`
		Supported         *bool                      `json:"supported,omitempty"`
	} `json:"series"`
	Timers struct {
		Delete         *bool `json:"delete,omitempty"`
		Edit           *bool `json:"edit,omitempty"`
		ReadBackVerify *bool `json:"readBackVerify,omitempty"`
	} `json:"timers"`
}

// DvrCapabilitiesSeriesMode defines model for DvrCapabilities.Series.Mode.
type DvrCapabilitiesSeriesMode string

// EPGConfig defines model for EPGConfig.
type EPGConfig struct {
	Days    *int             `json:"days,omitempty"`
	Enabled *bool            `json:"enabled,omitempty"`
	Source  *EPGConfigSource `json:"source,omitempty"`
}

// EPGConfigSource defines model for EPGConfig.Source.
type EPGConfigSource string

// EPGStatus defines model for EPGStatus.
type EPGStatus struct {
	MissingChannels *int             `json:"missingChannels,omitempty"`
	Status          *EPGStatusStatus `json:"status,omitempty"`
}

// EPGStatusStatus defines model for EPGStatus.Status.
type EPGStatusStatus string

// IntentRequest defines model for IntentRequest.
type IntentRequest struct {
	// CorrelationId Optional correlation ID for end-to-end tracing
	CorrelationId *string `json:"correlationId,omitempty"`

	// Hwaccel Hardware acceleration override (v3.1+).
	// - auto: Server decides based on GPU availability
	// - force: Force GPU encoding (fails if no GPU)
	// - off: Force CPU encoding
	Hwaccel *IntentRequestHwaccel `json:"hwaccel,omitempty"`

	// IdempotencyKey Optional idempotency key for at-most-once semantics
	IdempotencyKey *string `json:"idempotencyKey,omitempty"`

	// Params Additional parameters
	Params *map[string]string `json:"params,omitempty"`

	// ServiceRef Required for stream.start. Enigma2 service reference (live playback only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// SessionId Required for stream.stop intent
	SessionId *openapi_types.UUID `json:"sessionId,omitempty"`
	Type      *IntentRequestType  `json:"type,omitempty"`
}

// IntentRequestHwaccel Hardware acceleration override (v3.1+).
// - auto: Server decides based on GPU availability
// - force: Force GPU encoding (fails if no GPU)
// - off: Force CPU encoding
type IntentRequestHwaccel string

// IntentRequestType defines model for IntentRequest.Type.
type IntentRequestType string

// LogEntry defines model for LogEntry.
type LogEntry struct {
	Fields  *map[string]interface{} `json:"fields,omitempty"`
	Level   *string                 `json:"level,omitempty"`
	Message *string                 `json:"message,omitempty"`
	Time    *time.Time              `json:"time,omitempty"`
}

// NowNextEntry defines model for NowNextEntry.
type NowNextEntry struct {
	// End Unix timestamp (seconds)
	End int `json:"end"`

	// Start Unix timestamp (seconds)
	Start int    `json:"start"`
	Title string `json:"title"`
}

// NowNextItem defines model for NowNextItem.
type NowNextItem struct {
	Next       *NowNextEntry `json:"next,omitempty"`
	Now        *NowNextEntry `json:"now,omitempty"`
	ServiceRef string        `json:"serviceRef"`
}

// NowNextRequest defines model for NowNextRequest.
type NowNextRequest struct {
	Services []string `json:"services"`
}

// NowNextResponse defines model for NowNextResponse.
type NowNextResponse struct {
	Items []NowNextItem `json:"items"`
}

// OpenWebIFConfig defines model for OpenWebIFConfig.
type OpenWebIFConfig struct {
	BaseUrl    *string `json:"baseUrl,omitempty"`
	Password   *string `json:"password,omitempty"`
	StreamPort *int    `json:"streamPort,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// PiconsConfig defines model for PiconsConfig.
type PiconsConfig struct {
	BaseUrl *string `json:"baseUrl,omitempty"`
}

// PlaybackCapabilities Client capabilities for playback decision (P4-1)
type PlaybackCapabilities struct {
	// AllowTranscode Whether client allows transcoding (force bypass)
	AllowTranscode *bool `json:"allowTranscode,omitempty"`

	// AudioCodecs Supported audio codecs
	AudioCodecs []string `json:"audioCodecs"`

	// CapabilitiesVersion Capabilities contract version (current: 1)
	CapabilitiesVersion int `json:"capabilitiesVersion"`

	// Container Supported container formats
	Container []string `json:"container"`

	// DeviceType Client device category for policy decisions
	DeviceType *string `json:"deviceType,omitempty"`

	// MaxVideo Optional resolution/FPS constraints
	MaxVideo *struct {
		Fps    *int `json:"fps,omitempty"`
		Height *int `json:"height,omitempty"`
		Width  *int `json:"width,omitempty"`
	} `json:"maxVideo,omitempty"`

	// SupportsHls Whether client supports HLS playlists
	SupportsHls *bool `json:"supportsHls,omitempty"`

	// SupportsRange Whether client supports HTTP range requests
	SupportsRange *bool `json:"supportsRange,omitempty"`

	// VideoCodecs Supported video codecs
	VideoCodecs []string `json:"videoCodecs"`
}

// PlaybackDecision Complete playback decision from backend (P4-1)
type PlaybackDecision struct {
	// Constraints Applied constraints (e.g., downscale_required)
	Constraints []string `json:"constraints"`

	// Mode Playback mode decision
	Mode PlaybackDecisionMode `json:"mode"`

	// Outputs Available output URLs/playlists
	Outputs []PlaybackOutput `json:"outputs"`

	// Reasons Machine-readable decision reason codes
	Reasons []string `json:"reasons"`

	// Selected Selected output format
	Selected struct {
		AudioCodec string `json:"audioCodec"`
		Container  string `json:"container"`
		VideoCodec string `json:"videoCodec"`
	} `json:"selected"`

	// SelectedOutputKind The explicitly selected playback kind.
	SelectedOutputKind PlaybackDecisionSelectedOutputKind `json:"selectedOutputKind"`

	// SelectedOutputUrl The explicitly selected playback URL (backend-driven).
	SelectedOutputUrl string `json:"selectedOutputUrl"`

	// Trace Traceability information
	Trace PlaybackTrace `json:"trace"`
}

// PlaybackDecisionMode Playback mode decision
type PlaybackDecisionMode string

// PlaybackDecisionSelectedOutputKind The explicitly selected playback kind.
type PlaybackDecisionSelectedOutputKind string

// PlaybackFeedbackRequest defines model for PlaybackFeedbackRequest.
type PlaybackFeedbackRequest struct {
	// Code MediaError code if applicable
	Code    *int                         `json:"code,omitempty"`
	Details *map[string]interface{}      `json:"details,omitempty"`
	Event   PlaybackFeedbackRequestEvent `json:"event"`
	Message *string                      `json:"message,omitempty"`
}

// PlaybackFeedbackRequestEvent defines model for PlaybackFeedbackRequest.Event.
type PlaybackFeedbackRequestEvent string

// PlaybackInfo defines model for PlaybackInfo.
type PlaybackInfo struct {
	// AudioCodec Truthful audio codec if known (e.g., aac, ac3, mp2).
	AudioCodec *string `json:"audioCodec,omitempty"`

	// Container Truthful container name if known (e.g., ts, mp4, mkv).
	Container *string `json:"container,omitempty"`

	// Decision Complete playback decision from backend (P4-1)
	Decision *PlaybackDecision `json:"decision,omitempty"`

	// DurationSeconds Duration in seconds. Omitted if unknown or preparing.
	DurationSeconds *int64 `json:"durationSeconds,omitempty"`

	// DurationSource Source of the reported duration, when durationSeconds is present.
	DurationSource *PlaybackInfoDurationSource `json:"durationSource,omitempty"`

	// DvrWindowSeconds Absolute DVR window length in seconds. Becomes required in P3-4.
	DvrWindowSeconds *int64 `json:"dvrWindowSeconds,omitempty"`

	// IsSeekable Authoritative flag if the stream is seekable. Becomes required in P3-4.
	IsSeekable *bool `json:"isSeekable,omitempty"`

	// LiveEdgeUnix wall-clock timestamp (UNIX) of the latest segment. Becomes required in P3-4.
	LiveEdgeUnix *int64 `json:"liveEdgeUnix,omitempty"`

	// Mode Selected playback strategy output mode.
	Mode PlaybackInfoMode `json:"mode"`

	// Reason Reason for the playback decision.
	Reason *PlaybackInfoReason `json:"reason,omitempty"`

	// RequestId Correlation ID for the request. Mandatory in P3-1.
	RequestId string         `json:"requestId"`
	Resume    *ResumeSummary `json:"resume,omitempty"`

	// Seekable Whether the stream is seekable. Omitted if unknown. Deprecated in favor of isSeekable.
	Seekable *bool `json:"seekable,omitempty"`

	// SessionId Unique ID for the stream session. Mandatory in P3-1.
	SessionId string `json:"sessionId"`

	// StartUnix wall-clock timestamp (UNIX) of the earliest segment in window. Becomes required in P3-4.
	StartUnix *int64 `json:"startUnix,omitempty"`

	// Url Relative URL for the selected playback strategy. Optional for deny or decision-led cases.
	Url *string `json:"url,omitempty"`

	// VideoCodec Truthful video codec if known (e.g., h264, hevc, mpeg2).
	VideoCodec *string `json:"videoCodec,omitempty"`
}

// PlaybackInfoDurationSource Source of the reported duration, when durationSeconds is present.
type PlaybackInfoDurationSource string

// PlaybackInfoMode Selected playback strategy output mode.
type PlaybackInfoMode string

// PlaybackInfoReason Reason for the playback decision.
type PlaybackInfoReason string

// PlaybackOutput Output URL for client playback
type PlaybackOutput struct {
	union json.RawMessage
}

// PlaybackOutputFile defines model for PlaybackOutputFile.
type PlaybackOutputFile struct {
	// Kind Static file output
	Kind PlaybackOutputFileKind `json:"kind"`

	// Url Direct playback URL
	Url string `json:"url"`
}

// PlaybackOutputFileKind Static file output
type PlaybackOutputFileKind string

// PlaybackOutputHls defines model for PlaybackOutputHls.
type PlaybackOutputHls struct {
	// Kind HLS stream output
	Kind PlaybackOutputHlsKind `json:"kind"`

	// PlaylistUrl Canonical HLS playlist URL (.m3u8)
	PlaylistUrl string `json:"playlistUrl"`

	// Url Alternate playback URL (optional)
	Url *string `json:"url,omitempty"`
}

// PlaybackOutputHlsKind HLS stream output
type PlaybackOutputHlsKind string

// PlaybackTrace Traceability information
type PlaybackTrace struct {
	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string  `json:"requestId"`
	SessionId *string `json:"sessionId"`
}

// ProblemCapabilitiesInvalid defines model for ProblemCapabilitiesInvalid.
type ProblemCapabilitiesInvalid struct {
	Code      *ProblemCapabilitiesInvalidCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict                `json:"conflicts,omitempty"`
	Detail    *string                         `json:"detail,omitempty"`
	Fields    *map[string]interface{}         `json:"fields,omitempty"`
	Instance  *string                         `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemCapabilitiesInvalidCode defines model for ProblemCapabilitiesInvalid.Code.
type ProblemCapabilitiesInvalidCode string

// ProblemCapabilitiesMissing defines model for ProblemCapabilitiesMissing.
type ProblemCapabilitiesMissing struct {
	Code      *ProblemCapabilitiesMissingCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict                `json:"conflicts,omitempty"`
	Detail    *string                         `json:"detail,omitempty"`
	Fields    *map[string]interface{}         `json:"fields,omitempty"`
	Instance  *string                         `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemCapabilitiesMissingCode defines model for ProblemCapabilitiesMissing.Code.
type ProblemCapabilitiesMissingCode string

// ProblemDecisionAmbiguous defines model for ProblemDecisionAmbiguous.
type ProblemDecisionAmbiguous struct {
	Code      *ProblemDecisionAmbiguousCode `json:"code,omitempty"`
	Conflicts *[]TimerConflict              `json:"conflicts,omitempty"`
	Detail    *string                       `json:"detail,omitempty"`
	Fields    *map[string]interface{}       `json:"fields,omitempty"`
	Instance  *string                       `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// ProblemDecisionAmbiguousCode defines model for ProblemDecisionAmbiguous.Code.
type ProblemDecisionAmbiguousCode string

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	// Code Stable machine-readable short code (e.g. "NOT_FOUND")
	Code      *string                 `json:"code,omitempty"`
	Conflicts *[]TimerConflict        `json:"conflicts,omitempty"`
	Detail    *string                 `json:"detail,omitempty"`
	Fields    *map[string]interface{} `json:"fields,omitempty"`
	Instance  *string                 `json:"instance,omitempty"`

	// RequestId Correlation ID (UUID or prefixed string like req_abc123)
	RequestId string `json:"requestId"`
	Status    int    `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
}

// RecordingBuildStatus defines model for RecordingBuildStatus.
type RecordingBuildStatus struct {
	AttemptMode  *RecordingBuildStatusAttemptMode `json:"attemptMode,omitempty"`
	Error        *string                          `json:"error,omitempty"`
	LastProgress *time.Time                       `json:"lastProgress,omitempty"`

	// ProgressiveReady True if a progressive (timeshift) playlist is playable.
	ProgressiveReady *bool `json:"progressiveReady,omitempty"`

	// RequestId Correlation ID for the request.
	RequestId    string                    `json:"requestId"`
	SegmentCount *int                      `json:"segmentCount,omitempty"`
	StartedAt    *time.Time                `json:"startedAt,omitempty"`
	State        RecordingBuildStatusState `json:"state"`
}

// RecordingBuildStatusAttemptMode defines model for RecordingBuildStatus.AttemptMode.
type RecordingBuildStatusAttemptMode string

// RecordingBuildStatusState defines model for RecordingBuildStatus.State.
type RecordingBuildStatusState string

// RecordingItem defines model for RecordingItem.
type RecordingItem struct {
	// BeginUnixSeconds Recording start time as UNIX seconds.
	BeginUnixSeconds *int64  `json:"beginUnixSeconds,omitempty"`
	Description      *string `json:"description,omitempty"`

	// DurationSeconds Recording duration in seconds, if known.
	DurationSeconds *int64  `json:"durationSeconds,omitempty"`
	Filename        *string `json:"filename,omitempty"`

	// Length Human-readable duration string for display only.
	Length *string `json:"length,omitempty"`

	// RecordingId Base64url-encoded recording ID (RFC 4648, unpadded) to use for /recordings/{recordingId}.
	RecordingId *string        `json:"recordingId,omitempty"`
	Resume      *ResumeSummary `json:"resume,omitempty"`

	// ServiceRef Legacy receiver service reference (read-only).
	ServiceRef *string `json:"serviceRef,omitempty"`

	// Status Consolidated recording status. Becomes required in P3-3.
	Status *RecordingItemStatus `json:"status,omitempty"`
	Title  *string              `json:"title,omitempty"`
}

// RecordingItemStatus Consolidated recording status. Becomes required in P3-3.
type RecordingItemStatus string

// RecordingResponse defines model for RecordingResponse.
type RecordingResponse struct {
	Breadcrumbs *[]Breadcrumb    `json:"breadcrumbs,omitempty"`
	CurrentPath *string          `json:"currentPath,omitempty"`
	CurrentRoot *string          `json:"currentRoot,omitempty"`
	Directories *[]DirectoryItem `json:"directories,omitempty"`
	Recordings  *[]RecordingItem `json:"recordings,omitempty"`

	// RequestId Correlation ID for the request.
	RequestId string           `json:"requestId"`
	Roots     *[]RecordingRoot `json:"roots,omitempty"`
}

// RecordingRoot defines model for RecordingRoot.
type RecordingRoot struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// RecordingStatus defines model for RecordingStatus.
type RecordingStatus struct {
	IsRecording bool    `json:"isRecording"`
	ServiceName *string `json:"serviceName,omitempty"`
}

// ResumeSummary defines model for ResumeSummary.
type ResumeSummary struct {
	DurationSeconds *int64     `json:"durationSeconds,omitempty"`
	Finished        *bool      `json:"finished,omitempty"`
	PosSeconds      int64      `json:"posSeconds"`
	UpdatedAt       *time.Time `json:"updatedAt,omitempty"`
}

// RuleSnapshot defines model for RuleSnapshot.
type RuleSnapshot struct {
	ChannelRef  *string `json:"channelRef,omitempty"`
	Days        *[]int  `json:"days,omitempty"`
	Enabled     *bool   `json:"enabled,omitempty"`
	Id          *string `json:"id,omitempty"`
	Keyword     *string `json:"keyword,omitempty"`
	Priority    *int    `json:"priority,omitempty"`
	StartWindow *string `json:"startWindow,omitempty"`
}

// RunConflict defines model for RunConflict.
type RunConflict struct {
	Begin           *int64  `json:"begin,omitempty"`
	BlockingTimerId *string `json:"blockingTimerId,omitempty"`
	End             *int64  `json:"end,omitempty"`
	Message         *string `json:"message,omitempty"`
	OverlapSeconds  *int64  `json:"overlapSeconds,omitempty"`
	ServiceRef      *string `json:"serviceRef,omitempty"`
	Title           *string `json:"title,omitempty"`
}

// RunDecision defines model for RunDecision.
type RunDecision struct {
	Action      *string   `json:"action,omitempty"`
	Begin       *int64    `json:"begin,omitempty"`
	Details     *string   `json:"details,omitempty"`
	End         *int64    `json:"end,omitempty"`
	MatchReason *[]string `json:"matchReason,omitempty"`
	Reason      *string   `json:"reason,omitempty"`
	ServiceRef  *string   `json:"serviceRef,omitempty"`
	TimerId     *string   `json:"timerId,omitempty"`
	Title       *string   `json:"title,omitempty"`
}

// RunError defines model for RunError.
type RunError struct {
	At        *time.Time `json:"at,omitempty"`
	Message   *string    `json:"message,omitempty"`
	Retryable *bool      `json:"retryable,omitempty"`
	Type      *string    `json:"type,omitempty"`
}

// RunSummary defines model for RunSummary.
type RunSummary struct {
	EpgItemsMatched             *int  `json:"epgItemsMatched,omitempty"`
	EpgItemsScanned             *int  `json:"epgItemsScanned,omitempty"`
	MaxMatchesScannedPerRuleHit *bool `json:"maxMatchesScannedPerRuleHit,omitempty"`
	MaxTimersGlobalPerRunHit    *bool `json:"maxTimersGlobalPerRunHit,omitempty"`
	ReceiverUnreachable         *bool `json:"receiverUnreachable,omitempty"`
	TimersAttempted             *int  `json:"timersAttempted,omitempty"`
	TimersConflicted            *int  `json:"timersConflicted,omitempty"`
	TimersCreated               *int  `json:"timersCreated,omitempty"`
	TimersErrored               *int  `json:"timersErrored,omitempty"`
	TimersSkipped               *int  `json:"timersSkipped,omitempty"`
}

// ScanStatus defines model for ScanStatus.
type ScanStatus struct {
	// FinishedAt Unix timestamp of when the last scan completed
	FinishedAt *int64  `json:"finishedAt,omitempty"`
	LastError  *string `json:"lastError,omitempty"`

	// ScannedChannels Number of attempts (successful/failed) to probe channels so far
	ScannedChannels *int `json:"scannedChannels,omitempty"`

	// StartedAt Unix timestamp of when the current or last scan started
	StartedAt *int64           `json:"startedAt,omitempty"`
	State     *ScanStatusState `json:"state,omitempty"`

	// TotalChannels Total number of channels in the playlist
	TotalChannels *int `json:"totalChannels,omitempty"`

	// UpdatedCount Number of capabilities successfully updated in the store
	UpdatedCount *int `json:"updatedCount,omitempty"`
}

// ScanStatusState defines model for ScanStatus.State.
type ScanStatusState string

// SeriesRule defines model for SeriesRule.
type SeriesRule struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channelRef,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int  `json:"days,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Id      *string `json:"id,omitempty"`

	// Keyword Search term or regex for event title
	Keyword        *string     `json:"keyword,omitempty"`
	LastRunAt      *time.Time  `json:"lastRunAt,omitempty"`
	LastRunStatus  *string     `json:"lastRunStatus,omitempty"`
	LastRunSummary *RunSummary `json:"lastRunSummary,omitempty"`
	Priority       *int        `json:"priority,omitempty"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"startWindow,omitempty"`
}

// SeriesRuleRunReport defines model for SeriesRuleRunReport.
type SeriesRuleRunReport struct {
	Conflicts  *[]RunConflict             `json:"conflicts,omitempty"`
	Decisions  *[]RunDecision             `json:"decisions,omitempty"`
	DurationMs *int64                     `json:"durationMs,omitempty"`
	Errors     *[]RunError                `json:"errors,omitempty"`
	FinishedAt *time.Time                 `json:"finishedAt,omitempty"`
	RuleId     *string                    `json:"ruleId,omitempty"`
	RunId      *string                    `json:"runId,omitempty"`
	Snapshot   *RuleSnapshot              `json:"snapshot,omitempty"`
	StartedAt  *time.Time                 `json:"startedAt,omitempty"`
	Status     *SeriesRuleRunReportStatus `json:"status,omitempty"`
	Summary    *RunSummary                `json:"summary,omitempty"`
	Trigger    *string                    `json:"trigger,omitempty"`
	WindowFrom *int64                     `json:"windowFrom,omitempty"`
	WindowTo   *int64                     `json:"windowTo,omitempty"`
}

// SeriesRuleRunReportStatus defines model for SeriesRuleRunReport.Status.
type SeriesRuleRunReportStatus string

// SeriesRuleUpdate defines model for SeriesRuleUpdate.
type SeriesRuleUpdate struct {
	// ChannelRef Optional service reference to restrict rule
	ChannelRef *string `json:"channelRef,omitempty"`

	// Days Days of week (0=Sunday)
	Days    *[]int `json:"days,omitempty"`
	Enabled bool   `json:"enabled"`

	// Keyword Search term or regex for event title
	Keyword  string `json:"keyword"`
	Priority int    `json:"priority"`

	// StartWindow Time window HHMM-HHMM
	StartWindow *string `json:"startWindow,omitempty"`
}

// Service defines model for Service.
type Service struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Group   *string `json:"group,omitempty"`
	Id      *string `json:"id,omitempty"`
	LogoUrl *string `json:"logoUrl,omitempty"`
	Name    *string `json:"name,omitempty"`
	Number  *string `json:"number,omitempty"`

	// ServiceRef Service reference for streaming (extracted from M3U URL)
	ServiceRef *string `json:"serviceRef,omitempty"`
}

// SessionRecord defines model for SessionRecord.
type SessionRecord struct {
	ContextData    *map[string]string      `json:"contextData,omitempty"`
	CorrelationId  *string                 `json:"correlationId,omitempty"`
	CreatedAtUnix  *int64                  `json:"createdAtUnix,omitempty"`
	LastAccessUnix *int64                  `json:"lastAccessUnix,omitempty"`
	Profile        *map[string]interface{} `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionRecordReason `json:"reason,omitempty"`
	ReasonDetail *string              `json:"reasonDetail,omitempty"`
	ServiceRef   *string              `json:"serviceRef,omitempty"`
	SessionId    *openapi_types.UUID  `json:"sessionId,omitempty"`

	// State Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
	// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
	State         *SessionRecordState `json:"state,omitempty"`
	TunerID       *string             `json:"tunerID,omitempty"`
	UpdatedAtUnix *int64              `json:"updatedAtUnix,omitempty"`
}

// SessionRecordReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionRecordReason string

// SessionRecordState Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
// atomically published). PRIMING means FFmpeg is running but content is not yet playable.
type SessionRecordState string

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	CorrelationId *string `json:"correlationId,omitempty"`

	// DurationSeconds DVR window length for live sessions, in seconds.
	DurationSeconds *float32 `json:"durationSeconds,omitempty"`

	// LiveEdgeSeconds Current live edge position in seconds (live only).
	LiveEdgeSeconds *float32 `json:"liveEdgeSeconds,omitempty"`

	// Mode Playback mode for the session.
	Mode *SessionResponseMode `json:"mode,omitempty"`

	// PlaybackUrl Playback URL for the HLS playlist.
	PlaybackUrl *string `json:"playbackUrl,omitempty"`
	Profile     *string `json:"profile,omitempty"`

	// Reason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
	Reason       *SessionResponseReason `json:"reason,omitempty"`
	ReasonDetail *string                `json:"reasonDetail,omitempty"`

	// RequestId Request ID for debugging/tracing. Mandatory in P3-1.
	RequestId string `json:"requestId"`

	// SeekableEndSeconds Latest seekable position in seconds.
	SeekableEndSeconds *float32 `json:"seekableEndSeconds,omitempty"`

	// SeekableStartSeconds Earliest seekable position in seconds.
	SeekableStartSeconds *float32           `json:"seekableStartSeconds,omitempty"`
	ServiceRef           *string            `json:"serviceRef,omitempty"`
	SessionId            openapi_types.UUID `json:"sessionId"`

	// State Session lifecycle state. STARTING guarantees a session ticket is allocated.
	// READY/ACTIVE guarantees a playable HLS stream.
	State       SessionResponseState `json:"state"`
	UpdatedAtMs *int                 `json:"updatedAtMs,omitempty"`
}

// SessionResponseMode Playback mode for the session.
type SessionResponseMode string

// SessionResponseReason Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
type SessionResponseReason string

// SessionResponseState Session lifecycle state. STARTING guarantees a session ticket is allocated.
// READY/ACTIVE guarantees a playable HLS stream.
type SessionResponseState string

// StorageItem defines model for StorageItem.
type StorageItem struct {
	// Access Access level detected during probe.
	Access    StorageItemAccess `json:"access"`
	Capacity  *string           `json:"capacity,omitempty"`
	CheckedAt *time.Time        `json:"checkedAt,omitempty"`
	FsType    *string           `json:"fsType,omitempty"`

	// HealthStatus Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
	HealthStatus StorageItemHealthStatus `json:"healthStatus"`
	IsNas        bool                    `json:"isNas"`
	Model        *string                 `json:"model,omitempty"`
	Mount        *string                 `json:"mount,omitempty"`
	MountStatus  StorageItemMountStatus  `json:"mountStatus"`
}

// StorageItemAccess Access level detected during probe.
type StorageItemAccess string

// StorageItemHealthStatus Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
type StorageItemHealthStatus string

// StorageItemMountStatus defines model for StorageItem.MountStatus.
type StorageItemMountStatus string

// StreamSession defines model for StreamSession.
type StreamSession struct {
	ChannelName *string `json:"channelName,omitempty"`
	ClientIp    *string `json:"clientIp,omitempty"`

	// Id Internal database ID (deprecated).
	Id      *string `json:"id,omitempty"`
	Program *struct {
		BeginTimestamp *int64  `json:"beginTimestamp,omitempty"`
		Description    *string `json:"description,omitempty"`
		DurationSec    *int    `json:"durationSec,omitempty"`
		Title          *string `json:"title,omitempty"`
	} `json:"program,omitempty"`

	// RequestId Correlation ID for the trace. Mandatory in P3-1.
	RequestId string `json:"requestId"`

	// SessionId Mandatory stream lifecycle ID (domain truth).
	SessionId openapi_types.UUID `json:"sessionId"`
	StartedAt *time.Time         `json:"startedAt,omitempty"`
	State     StreamSessionState `json:"state"`
}

// StreamSessionState defines model for StreamSession.State.
type StreamSessionState string

// StreamingConfig Streaming delivery policy configuration (ADR-00X)
type StreamingConfig struct {
	// DeliveryPolicy Streaming delivery policy (only 'universal' is supported)
	DeliveryPolicy *StreamingConfigDeliveryPolicy `json:"deliveryPolicy,omitempty"`
}

// StreamingConfigDeliveryPolicy Streaming delivery policy (only 'universal' is supported)
type StreamingConfigDeliveryPolicy string

// SystemHealth defines model for SystemHealth.
type SystemHealth struct {
	Epg           *EPGStatus          `json:"epg,omitempty"`
	Receiver      *ComponentStatus    `json:"receiver,omitempty"`
	Status        *SystemHealthStatus `json:"status,omitempty"`
	UptimeSeconds *int64              `json:"uptimeSeconds,omitempty"`
	Version       *string             `json:"version,omitempty"`
}

// SystemHealthStatus defines model for SystemHealth.Status.
type SystemHealthStatus string

// SystemInfoData defines model for SystemInfoData.
type SystemInfoData struct {
	Hardware *struct {
		Boxtype            *string `json:"boxtype,omitempty"`
		Brand              *string `json:"brand,omitempty"`
		Chipset            *string `json:"chipset,omitempty"`
		ChipsetDescription *string `json:"chipsetDescription,omitempty"`
		Model              *string `json:"model,omitempty"`
	} `json:"hardware,omitempty"`
	Network *struct {
		Interfaces *[]struct {
			Dhcp  *bool   `json:"dhcp,omitempty"`
			Ip    *string `json:"ip,omitempty"`
			Ipv6  *string `json:"ipv6,omitempty"`
			Mac   *string `json:"mac,omitempty"`
			Name  *string `json:"name,omitempty"`
			Speed *string `json:"speed,omitempty"`
			Type  *string `json:"type,omitempty"`
		} `json:"interfaces,omitempty"`
	} `json:"network,omitempty"`
	Resource *struct {
		MemoryAvailable *string `json:"memoryAvailable,omitempty"`
		MemoryTotal     *string `json:"memoryTotal,omitempty"`
		MemoryUsed      *string `json:"memoryUsed,omitempty"`
	} `json:"resource,omitempty"`
	Runtime *struct {
		Uptime *string `json:"uptime,omitempty"`
	} `json:"runtime,omitempty"`
	Software *struct {
		DriverDate    *string `json:"driverDate,omitempty"`
		EnigmaVersion *string `json:"enigmaVersion,omitempty"`
		ImageDistro   *string `json:"imageDistro,omitempty"`
		ImageVersion  *string `json:"imageVersion,omitempty"`
		KernelVersion *string `json:"kernelVersion,omitempty"`
		OeVersion     *string `json:"oeVersion,omitempty"`
		WebifVersion  *string `json:"webifVersion,omitempty"`
	} `json:"software,omitempty"`
	Storage *struct {
		Devices   *[]StorageItem `json:"devices,omitempty"`
		Locations *[]StorageItem `json:"locations,omitempty"`
	} `json:"storage,omitempty"`
	Tuners *[]struct {
		Name   *string `json:"name,omitempty"`
		Status *string `json:"status,omitempty"`
		Type   *string `json:"type,omitempty"`
	} `json:"tuners,omitempty"`
}

// Timer defines model for Timer.
type Timer struct {
	Begin         int64                   `json:"begin"`
	CreatedAt     *time.Time              `json:"createdAt,omitempty"`
	Description   *string                 `json:"description,omitempty"`
	End           int64                   `json:"end"`
	Name          string                  `json:"name"`
	ReceiverState *map[string]interface{} `json:"receiverState,omitempty"`
	ServiceName   *string                 `json:"serviceName,omitempty"`
	ServiceRef    string                  `json:"serviceRef"`
	State         TimerState              `json:"state"`
	TimerId       string                  `json:"timerId"`
	UpdatedAt     *time.Time              `json:"updatedAt,omitempty"`
}

// TimerState defines model for Timer.State.
type TimerState string

// TimerConflict defines model for TimerConflict.
type TimerConflict struct {
	BlockingTimer  Timer             `json:"blockingTimer"`
	Message        *string           `json:"message,omitempty"`
	OverlapSeconds *int              `json:"overlapSeconds,omitempty"`
	Type           TimerConflictType `json:"type"`
}

// TimerConflictType defines model for TimerConflict.Type.
type TimerConflictType string

// TimerConflictPreviewRequest defines model for TimerConflictPreviewRequest.
type TimerConflictPreviewRequest struct {
	Mode     *TimerConflictPreviewRequestMode `json:"mode,omitempty"`
	Proposed TimerCreateRequest               `json:"proposed"`
}

// TimerConflictPreviewRequestMode defines model for TimerConflictPreviewRequest.Mode.
type TimerConflictPreviewRequestMode string

// TimerConflictPreviewResponse defines model for TimerConflictPreviewResponse.
type TimerConflictPreviewResponse struct {
	CanSchedule bool            `json:"canSchedule"`
	Conflicts   []TimerConflict `json:"conflicts"`
	Suggestions *[]struct {
		Kind          *TimerConflictPreviewResponseSuggestionsKind `json:"kind,omitempty"`
		Note          *string                                      `json:"note,omitempty"`
		ProposedBegin *int64                                       `json:"proposedBegin,omitempty"`
		ProposedEnd   *int64                                       `json:"proposedEnd,omitempty"`
	} `json:"suggestions,omitempty"`
}

// TimerConflictPreviewResponseSuggestionsKind defines model for TimerConflictPreviewResponse.Suggestions.Kind.
type TimerConflictPreviewResponseSuggestionsKind string

// TimerCreateRequest defines model for TimerCreateRequest.
type TimerCreateRequest struct {
	AfterEvent       *TimerCreateRequestAfterEvent `json:"afterEvent,omitempty"`
	Begin            int64                         `json:"begin"`
	Description      *string                       `json:"description,omitempty"`
	Enabled          *bool                         `json:"enabled,omitempty"`
	End              int64                         `json:"end"`
	IdempotencyKey   *string                       `json:"idempotencyKey,omitempty"`
	JustPlay         *bool                         `json:"justPlay,omitempty"`
	Name             string                        `json:"name"`
	PaddingAfterSec  *int                          `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int                          `json:"paddingBeforeSec,omitempty"`
	ServiceRef       string                        `json:"serviceRef"`
}

// TimerCreateRequestAfterEvent defines model for TimerCreateRequest.AfterEvent.
type TimerCreateRequestAfterEvent string

// TimerList defines model for TimerList.
type TimerList struct {
	Items []Timer `json:"items"`
}

// TimerPatchRequest defines model for TimerPatchRequest.
type TimerPatchRequest struct {
	Begin            *int64  `json:"begin,omitempty"`
	Description      *string `json:"description,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty"`
	End              *int64  `json:"end,omitempty"`
	Name             *string `json:"name,omitempty"`
	PaddingAfterSec  *int    `json:"paddingAfterSec,omitempty"`
	PaddingBeforeSec *int    `json:"paddingBeforeSec,omitempty"`
}

// VerificationConfig defines model for VerificationConfig.
type VerificationConfig struct {
	Enabled *bool `json:"enabled,omitempty"`

	// Interval Drift verification interval (e.g. "1m")
	Interval *string `json:"interval,omitempty"`
}

// GetEpgParams defines parameters for GetEpg.
type GetEpgParams struct {
	// From Start timestamp (unix seconds)
	From *int `form:"from,omitempty" json:"from,omitempty"`

	// To End timestamp (unix seconds)
	To *int `form:"to,omitempty" json:"to,omitempty"`

	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`

	// Q Filter by search query
	Q *string `form:"q,omitempty" json:"q,omitempty"`
}

// GetRecordingsParams defines parameters for GetRecordings.
type GetRecordingsParams struct {
	// Root Root location ID
	Root *string `form:"root,omitempty" json:"root,omitempty"`

	// Path Relative path
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// RunAllSeriesRulesParams defines parameters for RunAllSeriesRules.
type RunAllSeriesRulesParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// RunSeriesRuleParams defines parameters for RunSeriesRule.
type RunSeriesRuleParams struct {
	Trigger *string `form:"trigger,omitempty" json:"trigger,omitempty"`
}

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// Bouquet Filter by bouquet name
	Bouquet *string `form:"bouquet,omitempty" json:"bouquet,omitempty"`
}

// PostServicesIdToggleJSONBody defines parameters for PostServicesIdToggle.
type PostServicesIdToggleJSONBody struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Pagination limit (max 1000)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTimersParams defines parameters for GetTimers.
type GetTimersParams struct {
	State *string `form:"state,omitempty" json:"state,omitempty"`
	From  *int    `form:"from,omitempty" json:"from,omitempty"`
}

// CreateIntentJSONRequestBody defines body for CreateIntent for application/json ContentType.
type CreateIntentJSONRequestBody = IntentRequest

// PostRecordingPlaybackInfoJSONRequestBody defines body for PostRecordingPlaybackInfo for application/json ContentType.
type PostRecordingPlaybackInfoJSONRequestBody = PlaybackCapabilities

// CreateSeriesRuleJSONRequestBody defines body for CreateSeriesRule for application/json ContentType.
type CreateSeriesRuleJSONRequestBody = SeriesRule

// UpdateSeriesRuleJSONRequestBody defines body for UpdateSeriesRule for application/json ContentType.
type UpdateSeriesRuleJSONRequestBody = SeriesRuleUpdate

// PostServicesNowNextJSONRequestBody defines body for PostServicesNowNext for application/json ContentType.
type PostServicesNowNextJSONRequestBody = NowNextRequest

// PostServicesIdToggleJSONRequestBody defines body for PostServicesIdToggle for application/json ContentType.
type PostServicesIdToggleJSONRequestBody PostServicesIdToggleJSONBody

// ReportPlaybackFeedbackJSONRequestBody defines body for ReportPlaybackFeedback for application/json ContentType.
type ReportPlaybackFeedbackJSONRequestBody = PlaybackFeedbackRequest

// PutSystemConfigJSONRequestBody defines body for PutSystemConfig for application/json ContentType.
type PutSystemConfigJSONRequestBody = ConfigUpdate

// AddTimerJSONRequestBody defines body for AddTimer for application/json ContentType.
type AddTimerJSONRequestBody = TimerCreateRequest

// PreviewConflictsJSONRequestBody defines body for PreviewConflicts for application/json ContentType.
type PreviewConflictsJSONRequestBody = TimerConflictPreviewRequest

// UpdateTimerJSONRequestBody defines body for UpdateTimer for application/json ContentType.
type UpdateTimerJSONRequestBody = TimerPatchRequest

// AsPlaybackOutputFile returns the union data inside the PlaybackOutput as a PlaybackOutputFile
func (t PlaybackOutput) AsPlaybackOutputFile() (PlaybackOutputFile, error) {
	var body PlaybackOutputFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackOutputFile overwrites any union data inside the PlaybackOutput as the provided PlaybackOutputFile
func (t *PlaybackOutput) FromPlaybackOutputFile(v PlaybackOutputFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackOutputFile performs a merge with any union data inside the PlaybackOutput, using the provided PlaybackOutputFile
func (t *PlaybackOutput) MergePlaybackOutputFile(v PlaybackOutputFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaybackOutputHls returns the union data inside the PlaybackOutput as a PlaybackOutputHls
func (t PlaybackOutput) AsPlaybackOutputHls() (PlaybackOutputHls, error) {
	var body PlaybackOutputHls
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackOutputHls overwrites any union data inside the PlaybackOutput as the provided PlaybackOutputHls
func (t *PlaybackOutput) FromPlaybackOutputHls(v PlaybackOutputHls) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackOutputHls performs a merge with any union data inside the PlaybackOutput, using the provided PlaybackOutputHls
func (t *PlaybackOutput) MergePlaybackOutputHls(v PlaybackOutputHls) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlaybackOutput) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlaybackOutput) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create session cookie
	// (POST /auth/session)
	CreateSession(w http.ResponseWriter, r *http.Request)
	// Get DVR capabilities
	// (GET /dvr/capabilities)
	GetDvrCapabilities(w http.ResponseWriter, r *http.Request)
	// Get DVR recording status
	// (GET /dvr/status)
	GetDvrStatus(w http.ResponseWriter, r *http.Request)
	// Get EPG data
	// (GET /epg)
	GetEpg(w http.ResponseWriter, r *http.Request, params GetEpgParams)
	// Create stream intent (start or stop session)
	// (POST /intents)
	CreateIntent(w http.ResponseWriter, r *http.Request)
	// Get recent logs
	// (GET /logs)
	GetLogs(w http.ResponseWriter, r *http.Request)
	// Get current service and EPG
	// (GET /receiver/current)
	GetReceiverCurrent(w http.ResponseWriter, r *http.Request)
	// Browse recordings
	// (GET /recordings)
	GetRecordings(w http.ResponseWriter, r *http.Request, params GetRecordingsParams)
	// Delete a recording
	// (DELETE /recordings/{recordingId})
	DeleteRecording(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get VOD HLS playlist for a recording
	// (GET /recordings/{recordingId}/playlist.m3u8)
	GetRecordingHLSPlaylist(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get VOD HLS playlist metadata (Safari compatibility)
	// (HEAD /recordings/{recordingId}/playlist.m3u8)
	GetRecordingHLSPlaylistHead(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get recording build status
	// (GET /recordings/{recordingId}/status)
	GetRecordingsRecordingIdStatus(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get playback strategy for a recording (Legacy/Anonymous)
	// (GET /recordings/{recordingId}/stream-info)
	GetRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get playback decision with client capabilities (v3.1)
	// (POST /recordings/{recordingId}/stream-info)
	PostRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request, recordingId string)
	// Stream recording as MP4 (Direct VOD)
	// (GET /recordings/{recordingId}/stream.mp4)
	StreamRecordingDirect(w http.ResponseWriter, r *http.Request, recordingId string)
	// Probe recording availability (Direct VOD)
	// (HEAD /recordings/{recordingId}/stream.mp4)
	ProbeRecordingMp4(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get timeshift HLS playlist for a recording
	// (GET /recordings/{recordingId}/timeshift.m3u8)
	GetRecordingHLSTimeshift(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get timeshift HLS playlist metadata (Safari compatibility)
	// (HEAD /recordings/{recordingId}/timeshift.m3u8)
	GetRecordingHLSTimeshiftHead(w http.ResponseWriter, r *http.Request, recordingId string)
	// Get HLS segment for a recording
	// (GET /recordings/{recordingId}/{segment})
	GetRecordingHLSCustomSegment(w http.ResponseWriter, r *http.Request, recordingId string, segment string)
	// Get HLS segment metadata (Safari compatibility)
	// (HEAD /recordings/{recordingId}/{segment})
	GetRecordingHLSCustomSegmentHead(w http.ResponseWriter, r *http.Request, recordingId string, segment string)
	// List all series recording rules
	// (GET /series-rules)
	GetSeriesRules(w http.ResponseWriter, r *http.Request)
	// Create a new series rule
	// (POST /series-rules)
	CreateSeriesRule(w http.ResponseWriter, r *http.Request)
	// Run all enabled series rules immediately
	// (POST /series-rules/run)
	RunAllSeriesRules(w http.ResponseWriter, r *http.Request, params RunAllSeriesRulesParams)
	// Delete a series rule
	// (DELETE /series-rules/{id})
	DeleteSeriesRule(w http.ResponseWriter, r *http.Request, id string)
	// Update an existing series rule
	// (PUT /series-rules/{id})
	UpdateSeriesRule(w http.ResponseWriter, r *http.Request, id string)
	// Run a specific series rule immediately
	// (POST /series-rules/{id}/run)
	RunSeriesRule(w http.ResponseWriter, r *http.Request, id string, params RunSeriesRuleParams)
	// List all services (channels)
	// (GET /services)
	GetServices(w http.ResponseWriter, r *http.Request, params GetServicesParams)
	// List all bouquets
	// (GET /services/bouquets)
	GetServicesBouquets(w http.ResponseWriter, r *http.Request)
	// Get now/next EPG for a list of services
	// (POST /services/now-next)
	PostServicesNowNext(w http.ResponseWriter, r *http.Request)
	// Toggle service enabled state
	// (POST /services/{id}/toggle)
	PostServicesIdToggle(w http.ResponseWriter, r *http.Request, id string)
	// List all sessions (admin only)
	// (GET /sessions)
	ListSessions(w http.ResponseWriter, r *http.Request, params ListSessionsParams)
	// Get session state
	// (GET /sessions/{sessionID})
	GetSessionState(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID)
	// Serve HLS playlist or segment
	// (GET /sessions/{sessionID}/hls/{filename})
	ServeHLS(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string)
	// Get HLS content metadata (Safari compatibility)
	// (HEAD /sessions/{sessionID}/hls/{filename})
	ServeHLSHead(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string)
	// Report playback feedback (e.g. valid errors)
	// (POST /sessions/{sessionId}/feedback)
	ReportPlaybackFeedback(w http.ResponseWriter, r *http.Request, sessionId openapi_types.UUID)
	// List active streams
	// (GET /streams)
	GetStreams(w http.ResponseWriter, r *http.Request)
	// Terminate a stream session
	// (DELETE /streams/{id})
	DeleteStreamsId(w http.ResponseWriter, r *http.Request, id string)
	// Get system configuration
	// (GET /system/config)
	GetSystemConfig(w http.ResponseWriter, r *http.Request)
	// Update system configuration
	// (PUT /system/config)
	PutSystemConfig(w http.ResponseWriter, r *http.Request)
	// Get system health
	// (GET /system/health)
	GetSystemHealth(w http.ResponseWriter, r *http.Request)
	// Get minimal system health
	// (GET /system/healthz)
	GetSystemHealthz(w http.ResponseWriter, r *http.Request)
	// Get comprehensive system information
	// (GET /system/info)
	GetSystemInfo(w http.ResponseWriter, r *http.Request)
	// Trigger data refresh (EPG/Channels)
	// (POST /system/refresh)
	PostSystemRefresh(w http.ResponseWriter, r *http.Request)
	// Get status of the capability scan
	// (GET /system/scan)
	GetSystemScanStatus(w http.ResponseWriter, r *http.Request)
	// Trigger a background scan of all channels for capabilities
	// (POST /system/scan)
	TriggerSystemScan(w http.ResponseWriter, r *http.Request)
	// List all timers
	// (GET /timers)
	GetTimers(w http.ResponseWriter, r *http.Request, params GetTimersParams)
	// Create a timer
	// (POST /timers)
	AddTimer(w http.ResponseWriter, r *http.Request)
	// Preview conflicts
	// (POST /timers/conflicts:preview)
	PreviewConflicts(w http.ResponseWriter, r *http.Request)
	// Delete timer
	// (DELETE /timers/{timerId})
	DeleteTimer(w http.ResponseWriter, r *http.Request, timerId string)
	// Get timer
	// (GET /timers/{timerId})
	GetTimer(w http.ResponseWriter, r *http.Request, timerId string)
	// Edit timer
	// (PATCH /timers/{timerId})
	UpdateTimer(w http.ResponseWriter, r *http.Request, timerId string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Create session cookie
// (POST /auth/session)
func (_ Unimplemented) CreateSession(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get DVR capabilities
// (GET /dvr/capabilities)
func (_ Unimplemented) GetDvrCapabilities(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get DVR recording status
// (GET /dvr/status)
func (_ Unimplemented) GetDvrStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get EPG data
// (GET /epg)
func (_ Unimplemented) GetEpg(w http.ResponseWriter, r *http.Request, params GetEpgParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create stream intent (start or stop session)
// (POST /intents)
func (_ Unimplemented) CreateIntent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get recent logs
// (GET /logs)
func (_ Unimplemented) GetLogs(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get current service and EPG
// (GET /receiver/current)
func (_ Unimplemented) GetReceiverCurrent(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Browse recordings
// (GET /recordings)
func (_ Unimplemented) GetRecordings(w http.ResponseWriter, r *http.Request, params GetRecordingsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a recording
// (DELETE /recordings/{recordingId})
func (_ Unimplemented) DeleteRecording(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get VOD HLS playlist for a recording
// (GET /recordings/{recordingId}/playlist.m3u8)
func (_ Unimplemented) GetRecordingHLSPlaylist(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get VOD HLS playlist metadata (Safari compatibility)
// (HEAD /recordings/{recordingId}/playlist.m3u8)
func (_ Unimplemented) GetRecordingHLSPlaylistHead(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get recording build status
// (GET /recordings/{recordingId}/status)
func (_ Unimplemented) GetRecordingsRecordingIdStatus(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get playback strategy for a recording (Legacy/Anonymous)
// (GET /recordings/{recordingId}/stream-info)
func (_ Unimplemented) GetRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get playback decision with client capabilities (v3.1)
// (POST /recordings/{recordingId}/stream-info)
func (_ Unimplemented) PostRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stream recording as MP4 (Direct VOD)
// (GET /recordings/{recordingId}/stream.mp4)
func (_ Unimplemented) StreamRecordingDirect(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Probe recording availability (Direct VOD)
// (HEAD /recordings/{recordingId}/stream.mp4)
func (_ Unimplemented) ProbeRecordingMp4(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get timeshift HLS playlist for a recording
// (GET /recordings/{recordingId}/timeshift.m3u8)
func (_ Unimplemented) GetRecordingHLSTimeshift(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get timeshift HLS playlist metadata (Safari compatibility)
// (HEAD /recordings/{recordingId}/timeshift.m3u8)
func (_ Unimplemented) GetRecordingHLSTimeshiftHead(w http.ResponseWriter, r *http.Request, recordingId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get HLS segment for a recording
// (GET /recordings/{recordingId}/{segment})
func (_ Unimplemented) GetRecordingHLSCustomSegment(w http.ResponseWriter, r *http.Request, recordingId string, segment string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get HLS segment metadata (Safari compatibility)
// (HEAD /recordings/{recordingId}/{segment})
func (_ Unimplemented) GetRecordingHLSCustomSegmentHead(w http.ResponseWriter, r *http.Request, recordingId string, segment string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all series recording rules
// (GET /series-rules)
func (_ Unimplemented) GetSeriesRules(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new series rule
// (POST /series-rules)
func (_ Unimplemented) CreateSeriesRule(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Run all enabled series rules immediately
// (POST /series-rules/run)
func (_ Unimplemented) RunAllSeriesRules(w http.ResponseWriter, r *http.Request, params RunAllSeriesRulesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a series rule
// (DELETE /series-rules/{id})
func (_ Unimplemented) DeleteSeriesRule(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update an existing series rule
// (PUT /series-rules/{id})
func (_ Unimplemented) UpdateSeriesRule(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Run a specific series rule immediately
// (POST /series-rules/{id}/run)
func (_ Unimplemented) RunSeriesRule(w http.ResponseWriter, r *http.Request, id string, params RunSeriesRuleParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all services (channels)
// (GET /services)
func (_ Unimplemented) GetServices(w http.ResponseWriter, r *http.Request, params GetServicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all bouquets
// (GET /services/bouquets)
func (_ Unimplemented) GetServicesBouquets(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get now/next EPG for a list of services
// (POST /services/now-next)
func (_ Unimplemented) PostServicesNowNext(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Toggle service enabled state
// (POST /services/{id}/toggle)
func (_ Unimplemented) PostServicesIdToggle(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all sessions (admin only)
// (GET /sessions)
func (_ Unimplemented) ListSessions(w http.ResponseWriter, r *http.Request, params ListSessionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get session state
// (GET /sessions/{sessionID})
func (_ Unimplemented) GetSessionState(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Serve HLS playlist or segment
// (GET /sessions/{sessionID}/hls/{filename})
func (_ Unimplemented) ServeHLS(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get HLS content metadata (Safari compatibility)
// (HEAD /sessions/{sessionID}/hls/{filename})
func (_ Unimplemented) ServeHLSHead(w http.ResponseWriter, r *http.Request, sessionID openapi_types.UUID, filename string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Report playback feedback (e.g. valid errors)
// (POST /sessions/{sessionId}/feedback)
func (_ Unimplemented) ReportPlaybackFeedback(w http.ResponseWriter, r *http.Request, sessionId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List active streams
// (GET /streams)
func (_ Unimplemented) GetStreams(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Terminate a stream session
// (DELETE /streams/{id})
func (_ Unimplemented) DeleteStreamsId(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get system configuration
// (GET /system/config)
func (_ Unimplemented) GetSystemConfig(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update system configuration
// (PUT /system/config)
func (_ Unimplemented) PutSystemConfig(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get system health
// (GET /system/health)
func (_ Unimplemented) GetSystemHealth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get minimal system health
// (GET /system/healthz)
func (_ Unimplemented) GetSystemHealthz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get comprehensive system information
// (GET /system/info)
func (_ Unimplemented) GetSystemInfo(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Trigger data refresh (EPG/Channels)
// (POST /system/refresh)
func (_ Unimplemented) PostSystemRefresh(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get status of the capability scan
// (GET /system/scan)
func (_ Unimplemented) GetSystemScanStatus(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Trigger a background scan of all channels for capabilities
// (POST /system/scan)
func (_ Unimplemented) TriggerSystemScan(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all timers
// (GET /timers)
func (_ Unimplemented) GetTimers(w http.ResponseWriter, r *http.Request, params GetTimersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a timer
// (POST /timers)
func (_ Unimplemented) AddTimer(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Preview conflicts
// (POST /timers/conflicts:preview)
func (_ Unimplemented) PreviewConflicts(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete timer
// (DELETE /timers/{timerId})
func (_ Unimplemented) DeleteTimer(w http.ResponseWriter, r *http.Request, timerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get timer
// (GET /timers/{timerId})
func (_ Unimplemented) GetTimer(w http.ResponseWriter, r *http.Request, timerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Edit timer
// (PATCH /timers/{timerId})
func (_ Unimplemented) UpdateTimer(w http.ResponseWriter, r *http.Request, timerId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CreateSession operation middleware
func (siw *ServerInterfaceWrapper) CreateSession(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSession(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDvrCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetDvrCapabilities(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDvrCapabilities(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDvrStatus operation middleware
func (siw *ServerInterfaceWrapper) GetDvrStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDvrStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEpg operation middleware
func (siw *ServerInterfaceWrapper) GetEpg(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEpgParams

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------

	err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	// ------------- Optional query parameter "bouquet" -------------

	err = runtime.BindQueryParameter("form", true, false, "bouquet", r.URL.Query(), &params.Bouquet)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bouquet", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEpg(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateIntent operation middleware
func (siw *ServerInterfaceWrapper) CreateIntent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateIntent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetLogs operation middleware
func (siw *ServerInterfaceWrapper) GetLogs(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLogs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetReceiverCurrent operation middleware
func (siw *ServerInterfaceWrapper) GetReceiverCurrent(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetReceiverCurrent(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordings operation middleware
func (siw *ServerInterfaceWrapper) GetRecordings(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordingsParams

	// ------------- Optional query parameter "root" -------------

	err = runtime.BindQueryParameter("form", true, false, "root", r.URL.Query(), &params.Root)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "root", Err: err})
		return
	}

	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordings(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRecording operation middleware
func (siw *ServerInterfaceWrapper) DeleteRecording(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRecording(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingHLSPlaylist operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSPlaylist(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSPlaylist(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingHLSPlaylistHead operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSPlaylistHead(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSPlaylistHead(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingsRecordingIdStatus operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingsRecordingIdStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingsRecordingIdStatus(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingPlaybackInfo operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingPlaybackInfo(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostRecordingPlaybackInfo operation middleware
func (siw *ServerInterfaceWrapper) PostRecordingPlaybackInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostRecordingPlaybackInfo(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StreamRecordingDirect operation middleware
func (siw *ServerInterfaceWrapper) StreamRecordingDirect(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StreamRecordingDirect(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProbeRecordingMp4 operation middleware
func (siw *ServerInterfaceWrapper) ProbeRecordingMp4(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProbeRecordingMp4(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingHLSTimeshift operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSTimeshift(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSTimeshift(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingHLSTimeshiftHead operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSTimeshiftHead(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSTimeshiftHead(w, r, recordingId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingHLSCustomSegment operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSCustomSegment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	// ------------- Path parameter "segment" -------------
	var segment string

	err = runtime.BindStyledParameterWithOptions("simple", "segment", chi.URLParam(r, "segment"), &segment, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "segment", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSCustomSegment(w, r, recordingId, segment)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetRecordingHLSCustomSegmentHead operation middleware
func (siw *ServerInterfaceWrapper) GetRecordingHLSCustomSegmentHead(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recordingId" -------------
	var recordingId string

	err = runtime.BindStyledParameterWithOptions("simple", "recordingId", chi.URLParam(r, "recordingId"), &recordingId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recordingId", Err: err})
		return
	}

	// ------------- Path parameter "segment" -------------
	var segment string

	err = runtime.BindStyledParameterWithOptions("simple", "segment", chi.URLParam(r, "segment"), &segment, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "segment", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRecordingHLSCustomSegmentHead(w, r, recordingId, segment)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSeriesRules operation middleware
func (siw *ServerInterfaceWrapper) GetSeriesRules(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSeriesRules(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) CreateSeriesRule(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSeriesRule(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RunAllSeriesRules operation middleware
func (siw *ServerInterfaceWrapper) RunAllSeriesRules(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params RunAllSeriesRulesParams

	// ------------- Optional query parameter "trigger" -------------

	err = runtime.BindQueryParameter("form", true, false, "trigger", r.URL.Query(), &params.Trigger)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "trigger", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunAllSeriesRules(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) DeleteSeriesRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSeriesRule(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) UpdateSeriesRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateSeriesRule(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RunSeriesRule operation middleware
func (siw *ServerInterfaceWrapper) RunSeriesRule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RunSeriesRuleParams

	// ------------- Optional query parameter "trigger" -------------

	err = runtime.BindQueryParameter("form", true, false, "trigger", r.URL.Query(), &params.Trigger)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "trigger", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunSeriesRule(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetServices operation middleware
func (siw *ServerInterfaceWrapper) GetServices(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetServicesParams

	// ------------- Optional query parameter "bouquet" -------------

	err = runtime.BindQueryParameter("form", true, false, "bouquet", r.URL.Query(), &params.Bouquet)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "bouquet", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetServicesBouquets operation middleware
func (siw *ServerInterfaceWrapper) GetServicesBouquets(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServicesBouquets(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostServicesNowNext operation middleware
func (siw *ServerInterfaceWrapper) PostServicesNowNext(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostServicesNowNext(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostServicesIdToggle operation middleware
func (siw *ServerInterfaceWrapper) PostServicesIdToggle(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostServicesIdToggle(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSessions operation middleware
func (siw *ServerInterfaceWrapper) ListSessions(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSessionsParams

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSessions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSessionState operation middleware
func (siw *ServerInterfaceWrapper) GetSessionState(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sessionID", chi.URLParam(r, "sessionID"), &sessionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSessionState(w, r, sessionID)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ServeHLS operation middleware
func (siw *ServerInterfaceWrapper) ServeHLS(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sessionID", chi.URLParam(r, "sessionID"), &sessionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", chi.URLParam(r, "filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServeHLS(w, r, sessionID, filename)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ServeHLSHead operation middleware
func (siw *ServerInterfaceWrapper) ServeHLSHead(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionID" -------------
	var sessionID openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sessionID", chi.URLParam(r, "sessionID"), &sessionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionID", Err: err})
		return
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", chi.URLParam(r, "filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filename", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServeHLSHead(w, r, sessionID, filename)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReportPlaybackFeedback operation middleware
func (siw *ServerInterfaceWrapper) ReportPlaybackFeedback(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "sessionId" -------------
	var sessionId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", chi.URLParam(r, "sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sessionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReportPlaybackFeedback(w, r, sessionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetStreams operation middleware
func (siw *ServerInterfaceWrapper) GetStreams(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStreams(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteStreamsId operation middleware
func (siw *ServerInterfaceWrapper) DeleteStreamsId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteStreamsId(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSystemConfig operation middleware
func (siw *ServerInterfaceWrapper) GetSystemConfig(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PutSystemConfig operation middleware
func (siw *ServerInterfaceWrapper) PutSystemConfig(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutSystemConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSystemHealth operation middleware
func (siw *ServerInterfaceWrapper) GetSystemHealth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSystemHealthz operation middleware
func (siw *ServerInterfaceWrapper) GetSystemHealthz(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemHealthz(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSystemInfo operation middleware
func (siw *ServerInterfaceWrapper) GetSystemInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostSystemRefresh operation middleware
func (siw *ServerInterfaceWrapper) PostSystemRefresh(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostSystemRefresh(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSystemScanStatus operation middleware
func (siw *ServerInterfaceWrapper) GetSystemScanStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSystemScanStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TriggerSystemScan operation middleware
func (siw *ServerInterfaceWrapper) TriggerSystemScan(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TriggerSystemScan(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTimers operation middleware
func (siw *ServerInterfaceWrapper) GetTimers(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTimersParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------

	err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTimers(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AddTimer operation middleware
func (siw *ServerInterfaceWrapper) AddTimer(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimer(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PreviewConflicts operation middleware
func (siw *ServerInterfaceWrapper) PreviewConflicts(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PreviewConflicts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteTimer operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "timerId" -------------
	var timerId string

	err = runtime.BindStyledParameterWithOptions("simple", "timerId", chi.URLParam(r, "timerId"), &timerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimer(w, r, timerId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTimer operation middleware
func (siw *ServerInterfaceWrapper) GetTimer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "timerId" -------------
	var timerId string

	err = runtime.BindStyledParameterWithOptions("simple", "timerId", chi.URLParam(r, "timerId"), &timerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTimer(w, r, timerId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateTimer operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "timerId" -------------
	var timerId string

	err = runtime.BindStyledParameterWithOptions("simple", "timerId", chi.URLParam(r, "timerId"), &timerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "timerId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimer(w, r, timerId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/session", wrapper.CreateSession)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dvr/capabilities", wrapper.GetDvrCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dvr/status", wrapper.GetDvrStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/epg", wrapper.GetEpg)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/intents", wrapper.CreateIntent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/logs", wrapper.GetLogs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/receiver/current", wrapper.GetReceiverCurrent)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings", wrapper.GetRecordings)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/recordings/{recordingId}", wrapper.DeleteRecording)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/playlist.m3u8", wrapper.GetRecordingHLSPlaylist)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/playlist.m3u8", wrapper.GetRecordingHLSPlaylistHead)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/status", wrapper.GetRecordingsRecordingIdStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/stream-info", wrapper.GetRecordingPlaybackInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/recordings/{recordingId}/stream-info", wrapper.PostRecordingPlaybackInfo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/stream.mp4", wrapper.StreamRecordingDirect)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/stream.mp4", wrapper.ProbeRecordingMp4)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/timeshift.m3u8", wrapper.GetRecordingHLSTimeshift)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/timeshift.m3u8", wrapper.GetRecordingHLSTimeshiftHead)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recordings/{recordingId}/{segment}", wrapper.GetRecordingHLSCustomSegment)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/recordings/{recordingId}/{segment}", wrapper.GetRecordingHLSCustomSegmentHead)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/series-rules", wrapper.GetSeriesRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/series-rules", wrapper.CreateSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/series-rules/run", wrapper.RunAllSeriesRules)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/series-rules/{id}", wrapper.DeleteSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/series-rules/{id}", wrapper.UpdateSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/series-rules/{id}/run", wrapper.RunSeriesRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/services", wrapper.GetServices)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/services/bouquets", wrapper.GetServicesBouquets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/services/now-next", wrapper.PostServicesNowNext)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/services/{id}/toggle", wrapper.PostServicesIdToggle)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sessions", wrapper.ListSessions)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sessions/{sessionID}", wrapper.GetSessionState)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/sessions/{sessionID}/hls/{filename}", wrapper.ServeHLS)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/sessions/{sessionID}/hls/{filename}", wrapper.ServeHLSHead)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sessions/{sessionId}/feedback", wrapper.ReportPlaybackFeedback)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/streams", wrapper.GetStreams)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/streams/{id}", wrapper.DeleteStreamsId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/config", wrapper.GetSystemConfig)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/system/config", wrapper.PutSystemConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/health", wrapper.GetSystemHealth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/healthz", wrapper.GetSystemHealthz)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/info", wrapper.GetSystemInfo)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/system/refresh", wrapper.PostSystemRefresh)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/system/scan", wrapper.GetSystemScanStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/system/scan", wrapper.TriggerSystemScan)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/timers", wrapper.GetTimers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/timers", wrapper.AddTimer)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/timers/conflicts:preview", wrapper.PreviewConflicts)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/timers/{timerId}", wrapper.DeleteTimer)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/timers/{timerId}", wrapper.GetTimer)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/timers/{timerId}", wrapper.UpdateTimer)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
