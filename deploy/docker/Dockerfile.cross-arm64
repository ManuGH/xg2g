# syntax=docker/dockerfile:1.7
# =============================================================================
# ARM64 Cross-Compilation Dockerfile (OPTION 2 - PREPARED, NOT ACTIVE)
# =============================================================================
# Purpose: Build ARM64 images WITHOUT QEMU emulation for 10-20x faster builds
# Strategy: All expensive operations run on amd64 builder, runtime only copies
# Performance: 5-10 min (vs 60-90 min QEMU)
# Status: PREPARED - Enable when ARM64 usage increases
#
# To activate:
# 1. Uncomment build-arm64-cross job in .github/workflows/docker-multi-cpu.yml
# 2. Update create-manifests job to include cross-built ARM64 images
# 3. Test with: docker buildx build -f Dockerfile.cross-arm64 --platform linux/arm64 .

# =============================================================================
# Stage 1: Build Rust Library for ARM64 (on AMD64 host, no QEMU)
# =============================================================================
FROM --platform=linux/amd64 rust:1.91-alpine@sha256:fbcca3e30e26f79986809d5dbfcdbeaaf8d3f8a4475b7a19a973363b45c74d97 AS rust-builder

WORKDIR /build

# Install cross-compilation tools
RUN apk add --no-cache \
    musl-dev \
    pkgconfig \
    ffmpeg-dev \
    clang-dev \
    llvm-dev \
    gcc \
    && rustup target add aarch64-unknown-linux-musl

# Install cargo-zigbuild for easier cross-compilation
RUN cargo install cargo-zigbuild --locked

# Set Cargo environment for caching
ENV CARGO_HOME=/usr/local/cargo \
    CARGO_TARGET_DIR=/build/target

# Copy Rust source
COPY transcoder/Cargo.toml ./
COPY transcoder/src ./src

# Cross-compile Rust library for ARM64
# Note: Uses Zig's cross-compilation toolchain for seamless musl targeting
# Note: Builds cdylib for FFI, statically linked against musl
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/usr/local/cargo/git \
    --mount=type=cache,target=/build/target \
    mkdir -p /output && \
    cargo zigbuild --release --target aarch64-unknown-linux-musl && \
    cp target/aarch64-unknown-linux-musl/release/libxg2g_transcoder.so /output/ && \
    file /output/libxg2g_transcoder.so

# =============================================================================
# Stage 2: Build Go Binary for ARM64 (on AMD64 host, no QEMU)
# =============================================================================
FROM --platform=linux/amd64 golang:1.25-alpine@sha256:d3f0cf7723f3429e3f9ed846243970b20a2de7bae6a5b66fc5914e228d831bbb AS go-builder

# Install build dependencies
RUN apk add --no-cache git

WORKDIR /src

# Copy Go source
COPY go.mod go.sum ./
RUN go mod download

COPY . .

# Cross-compile Go binary for ARM64
# Note: CGO_ENABLED=0 for pure static binary (no Rust FFI in cross-build)
# Note: This builds the nogpu variant - GPU transcoding requires CGO
ARG GIT_REF
ARG VERSION

RUN set -eux; \
    BUILD_REF="${GIT_REF:-${VERSION:-dev}}"; \
    export CGO_ENABLED=0 GOOS=linux GOARCH=arm64; \
    go build -tags=nogpu -buildvcs=false -trimpath \
        -ldflags="-s -w -X 'main.Version=${BUILD_REF}'" \
        -o /out/xg2g ./cmd/daemon && \
    file /out/xg2g

# =============================================================================
# Stage 3: Runtime Image for ARM64 (no RUN commands, only COPY)
# =============================================================================
FROM --platform=linux/arm64 alpine:3.22.2@sha256:4b7ce07002c69e8f3d704a9c5d6fd3053be500b7f1c69fc0d80990c2ad8dd412

# Install runtime dependencies (pre-built ARM64 packages from Alpine)
# Note: No RUN commands means no QEMU execution required
RUN apk add --no-cache \
    ca-certificates \
    tzdata \
    wget \
    ffmpeg-libs \
    libgcc

# Create user and directories
RUN addgroup -g 65532 -S xg2g && \
    adduser -u 65532 -S -G xg2g -h /app -s /bin/false xg2g && \
    mkdir -p /data /app/lib && \
    chown -R xg2g:xg2g /data /app

WORKDIR /app

# Copy Go daemon (cross-compiled on amd64)
COPY --from=go-builder /out/xg2g .

# Copy Rust library (cross-compiled on amd64)
COPY --from=rust-builder /output/libxg2g_transcoder.so ./lib/

# Set library path
ENV LD_LIBRARY_PATH=/app/lib

RUN chmod +x /app/xg2g && \
    chown -R xg2g:xg2g /app

VOLUME ["/data"]

# Expose ports
EXPOSE 8080 18000

HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
  CMD wget -qO- http://localhost:8080/api/status || exit 1

# Default configuration
ENV XG2G_DATA=/data \
    XG2G_LISTEN=:8080 \
    XG2G_OWI_BASE=http://192.168.1.100 \
    XG2G_BOUQUET=Favourites \
    XG2G_FUZZY_MAX=2

USER xg2g:xg2g
ENTRYPOINT ["/app/xg2g"]

# =============================================================================
# Build Instructions
# =============================================================================
# Local build (test):
#   docker buildx build -f Dockerfile.cross-arm64 --platform linux/arm64 -t xg2g:arm64-cross .
#
# CI build (when enabled):
#   See .github/workflows/docker-multi-cpu.yml build-arm64-cross job
#
# Performance comparison:
#   QEMU (current):      60-90 min
#   Cross-compile (this): 5-10 min
#   Speedup:             6-18x faster
#
# Limitations:
#   - CGO disabled (no Rust FFI) - requires separate approach for audio transcoding
#   - GPU transcoding not supported in cross-build
#   - For full feature parity, use QEMU build (slower but complete)
