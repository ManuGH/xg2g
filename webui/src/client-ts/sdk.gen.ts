// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { AddTimerData, AddTimerErrors, AddTimerResponses, CreateIntentData, CreateIntentErrors, CreateIntentResponses, CreateSeriesRuleData, CreateSeriesRuleResponses, CreateSessionData, CreateSessionErrors, CreateSessionResponses, DeleteRecordingData, DeleteRecordingErrors, DeleteRecordingResponses, DeleteSeriesRuleData, DeleteSeriesRuleErrors, DeleteSeriesRuleResponses, DeleteStreamsIdData, DeleteStreamsIdErrors, DeleteStreamsIdResponses, DeleteTimerData, DeleteTimerErrors, DeleteTimerResponses, GetDvrCapabilitiesData, GetDvrCapabilitiesResponses, GetDvrStatusData, GetDvrStatusResponses, GetEpgData, GetEpgResponses, GetLogsData, GetLogsResponses, GetRecordingHlsCustomSegmentData, GetRecordingHlsCustomSegmentErrors, GetRecordingHlsCustomSegmentHeadData, GetRecordingHlsCustomSegmentHeadErrors, GetRecordingHlsCustomSegmentHeadResponses, GetRecordingHlsCustomSegmentResponses, GetRecordingHlsPlaylistData, GetRecordingHlsPlaylistErrors, GetRecordingHlsPlaylistHeadData, GetRecordingHlsPlaylistHeadErrors, GetRecordingHlsPlaylistHeadResponses, GetRecordingHlsPlaylistResponses, GetRecordingHlsTimeshiftData, GetRecordingHlsTimeshiftErrors, GetRecordingHlsTimeshiftHeadData, GetRecordingHlsTimeshiftHeadErrors, GetRecordingHlsTimeshiftHeadResponses, GetRecordingHlsTimeshiftResponses, GetRecordingPlaybackInfoData, GetRecordingPlaybackInfoErrors, GetRecordingPlaybackInfoResponses, GetRecordingsByRecordingIdStatusData, GetRecordingsByRecordingIdStatusErrors, GetRecordingsByRecordingIdStatusResponses, GetRecordingsData, GetRecordingsResponses, GetSeriesRulesData, GetSeriesRulesResponses, GetServicesBouquetsData, GetServicesBouquetsResponses, GetServicesData, GetServicesResponses, GetSessionStateData, GetSessionStateErrors, GetSessionStateResponses, GetStreamsData, GetStreamsResponses, GetSystemConfigData, GetSystemConfigResponses, GetSystemHealthData, GetSystemHealthResponses, GetSystemHealthzData, GetSystemHealthzResponses, GetSystemScanStatusData, GetSystemScanStatusErrors, GetSystemScanStatusResponses, GetTimerData, GetTimerErrors, GetTimerResponses, GetTimersData, GetTimersResponses, ListSessionsData, ListSessionsErrors, ListSessionsResponses, PostServicesByIdToggleData, PostServicesByIdToggleErrors, PostServicesByIdToggleResponses, PostServicesNowNextData, PostServicesNowNextErrors, PostServicesNowNextResponses, PostSystemRefreshData, PostSystemRefreshErrors, PostSystemRefreshResponses, PreviewConflictsData, PreviewConflictsResponses, PutSystemConfigData, PutSystemConfigErrors, PutSystemConfigResponses, ReportPlaybackFeedbackData, ReportPlaybackFeedbackErrors, ReportPlaybackFeedbackResponses, RunAllSeriesRulesData, RunAllSeriesRulesResponses, RunSeriesRuleData, RunSeriesRuleErrors, RunSeriesRuleResponses, ServeHlsData, ServeHlsErrors, ServeHlsHeadData, ServeHlsHeadErrors, ServeHlsHeadResponses, ServeHlsResponses, StreamRecordingDirectData, StreamRecordingDirectErrors, StreamRecordingDirectResponses, TriggerSystemScanData, TriggerSystemScanErrors, TriggerSystemScanResponses, UpdateSeriesRuleData, UpdateSeriesRuleErrors, UpdateSeriesRuleResponses, UpdateTimerData, UpdateTimerErrors, UpdateTimerResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Get system health
 */
export const getSystemHealth = <ThrowOnError extends boolean = false>(options?: Options<GetSystemHealthData, ThrowOnError>) => (options?.client ?? client).get<GetSystemHealthResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/system/health',
    ...options
});

/**
 * Get minimal system health
 */
export const getSystemHealthz = <ThrowOnError extends boolean = false>(options?: Options<GetSystemHealthzData, ThrowOnError>) => (options?.client ?? client).get<GetSystemHealthzResponses, unknown, ThrowOnError>({ url: '/system/healthz', ...options });

/**
 * Get system configuration
 */
export const getSystemConfig = <ThrowOnError extends boolean = false>(options?: Options<GetSystemConfigData, ThrowOnError>) => (options?.client ?? client).get<GetSystemConfigResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/system/config',
    ...options
});

/**
 * Update system configuration
 */
export const putSystemConfig = <ThrowOnError extends boolean = false>(options: Options<PutSystemConfigData, ThrowOnError>) => (options.client ?? client).put<PutSystemConfigResponses, PutSystemConfigErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/system/config',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Trigger data refresh (EPG/Channels)
 */
export const postSystemRefresh = <ThrowOnError extends boolean = false>(options?: Options<PostSystemRefreshData, ThrowOnError>) => (options?.client ?? client).post<PostSystemRefreshResponses, PostSystemRefreshErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/system/refresh',
    ...options
});

/**
 * List all bouquets
 */
export const getServicesBouquets = <ThrowOnError extends boolean = false>(options?: Options<GetServicesBouquetsData, ThrowOnError>) => (options?.client ?? client).get<GetServicesBouquetsResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/services/bouquets',
    ...options
});

/**
 * Get now/next EPG for a list of services
 */
export const postServicesNowNext = <ThrowOnError extends boolean = false>(options: Options<PostServicesNowNextData, ThrowOnError>) => (options.client ?? client).post<PostServicesNowNextResponses, PostServicesNowNextErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/services/now-next',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get EPG data
 */
export const getEpg = <ThrowOnError extends boolean = false>(options?: Options<GetEpgData, ThrowOnError>) => (options?.client ?? client).get<GetEpgResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/epg',
    ...options
});

/**
 * List all services (channels)
 */
export const getServices = <ThrowOnError extends boolean = false>(options?: Options<GetServicesData, ThrowOnError>) => (options?.client ?? client).get<GetServicesResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/services',
    ...options
});

/**
 * Toggle service enabled state
 */
export const postServicesByIdToggle = <ThrowOnError extends boolean = false>(options: Options<PostServicesByIdToggleData, ThrowOnError>) => (options.client ?? client).post<PostServicesByIdToggleResponses, PostServicesByIdToggleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/services/{id}/toggle',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List active streams
 */
export const getStreams = <ThrowOnError extends boolean = false>(options?: Options<GetStreamsData, ThrowOnError>) => (options?.client ?? client).get<GetStreamsResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/streams',
    ...options
});

/**
 * Browse recordings
 */
export const getRecordings = <ThrowOnError extends boolean = false>(options?: Options<GetRecordingsData, ThrowOnError>) => (options?.client ?? client).get<GetRecordingsResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings',
    ...options
});

/**
 * Delete a recording
 *
 * Deletes the recording via OpenWebIF on the receiver.
 */
export const deleteRecording = <ThrowOnError extends boolean = false>(options: Options<DeleteRecordingData, ThrowOnError>) => (options.client ?? client).delete<DeleteRecordingResponses, DeleteRecordingErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}',
    ...options
});

/**
 * Get recording build status
 */
export const getRecordingsByRecordingIdStatus = <ThrowOnError extends boolean = false>(options: Options<GetRecordingsByRecordingIdStatusData, ThrowOnError>) => (options.client ?? client).get<GetRecordingsByRecordingIdStatusResponses, GetRecordingsByRecordingIdStatusErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/status',
    ...options
});

/**
 * Get playback strategy for a recording
 */
export const getRecordingPlaybackInfo = <ThrowOnError extends boolean = false>(options: Options<GetRecordingPlaybackInfoData, ThrowOnError>) => (options.client ?? client).get<GetRecordingPlaybackInfoResponses, GetRecordingPlaybackInfoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/stream-info',
    ...options
});

/**
 * Stream recording as MP4 (Direct VOD)
 */
export const streamRecordingDirect = <ThrowOnError extends boolean = false>(options: Options<StreamRecordingDirectData, ThrowOnError>) => (options.client ?? client).get<StreamRecordingDirectResponses, StreamRecordingDirectErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/stream.mp4',
    ...options
});

/**
 * Get VOD HLS playlist for a recording
 */
export const getRecordingHlsPlaylist = <ThrowOnError extends boolean = false>(options: Options<GetRecordingHlsPlaylistData, ThrowOnError>) => (options.client ?? client).get<GetRecordingHlsPlaylistResponses, GetRecordingHlsPlaylistErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/playlist.m3u8',
    ...options
});

/**
 * Get VOD HLS playlist metadata (Safari compatibility)
 */
export const getRecordingHlsPlaylistHead = <ThrowOnError extends boolean = false>(options: Options<GetRecordingHlsPlaylistHeadData, ThrowOnError>) => (options.client ?? client).head<GetRecordingHlsPlaylistHeadResponses, GetRecordingHlsPlaylistHeadErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/playlist.m3u8',
    ...options
});

/**
 * Get timeshift HLS playlist for a recording
 */
export const getRecordingHlsTimeshift = <ThrowOnError extends boolean = false>(options: Options<GetRecordingHlsTimeshiftData, ThrowOnError>) => (options.client ?? client).get<GetRecordingHlsTimeshiftResponses, GetRecordingHlsTimeshiftErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/timeshift.m3u8',
    ...options
});

/**
 * Get timeshift HLS playlist metadata (Safari compatibility)
 */
export const getRecordingHlsTimeshiftHead = <ThrowOnError extends boolean = false>(options: Options<GetRecordingHlsTimeshiftHeadData, ThrowOnError>) => (options.client ?? client).head<GetRecordingHlsTimeshiftHeadResponses, GetRecordingHlsTimeshiftHeadErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/timeshift.m3u8',
    ...options
});

/**
 * Get HLS segment for a recording
 */
export const getRecordingHlsCustomSegment = <ThrowOnError extends boolean = false>(options: Options<GetRecordingHlsCustomSegmentData, ThrowOnError>) => (options.client ?? client).get<GetRecordingHlsCustomSegmentResponses, GetRecordingHlsCustomSegmentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/{segment}',
    ...options
});

/**
 * Get HLS segment metadata (Safari compatibility)
 */
export const getRecordingHlsCustomSegmentHead = <ThrowOnError extends boolean = false>(options: Options<GetRecordingHlsCustomSegmentHeadData, ThrowOnError>) => (options.client ?? client).head<GetRecordingHlsCustomSegmentHeadResponses, GetRecordingHlsCustomSegmentHeadErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/recordings/{recordingId}/{segment}',
    ...options
});

/**
 * Create session cookie
 *
 * Exchanges the Bearer token for a secure HttpOnly session cookie, enabling native playback (HLS) without token in URL.
 */
export const createSession = <ThrowOnError extends boolean = false>(options?: Options<CreateSessionData, ThrowOnError>) => (options?.client ?? client).post<CreateSessionResponses, CreateSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/auth/session',
    ...options
});

/**
 * List all timers
 */
export const getTimers = <ThrowOnError extends boolean = false>(options?: Options<GetTimersData, ThrowOnError>) => (options?.client ?? client).get<GetTimersResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/timers',
    ...options
});

/**
 * Create a timer
 */
export const addTimer = <ThrowOnError extends boolean = false>(options: Options<AddTimerData, ThrowOnError>) => (options.client ?? client).post<AddTimerResponses, AddTimerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/timers',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete timer
 */
export const deleteTimer = <ThrowOnError extends boolean = false>(options: Options<DeleteTimerData, ThrowOnError>) => (options.client ?? client).delete<DeleteTimerResponses, DeleteTimerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/timers/{timerId}',
    ...options
});

/**
 * Get timer
 */
export const getTimer = <ThrowOnError extends boolean = false>(options: Options<GetTimerData, ThrowOnError>) => (options.client ?? client).get<GetTimerResponses, GetTimerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/timers/{timerId}',
    ...options
});

/**
 * Edit timer
 */
export const updateTimer = <ThrowOnError extends boolean = false>(options: Options<UpdateTimerData, ThrowOnError>) => (options.client ?? client).patch<UpdateTimerResponses, UpdateTimerErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/timers/{timerId}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Preview conflicts
 */
export const previewConflicts = <ThrowOnError extends boolean = false>(options: Options<PreviewConflictsData, ThrowOnError>) => (options.client ?? client).post<PreviewConflictsResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/timers/conflicts:preview',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get DVR capabilities
 */
export const getDvrCapabilities = <ThrowOnError extends boolean = false>(options?: Options<GetDvrCapabilitiesData, ThrowOnError>) => (options?.client ?? client).get<GetDvrCapabilitiesResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/dvr/capabilities',
    ...options
});

/**
 * Get DVR recording status
 */
export const getDvrStatus = <ThrowOnError extends boolean = false>(options?: Options<GetDvrStatusData, ThrowOnError>) => (options?.client ?? client).get<GetDvrStatusResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/dvr/status',
    ...options
});

/**
 * Terminate a stream session
 */
export const deleteStreamsId = <ThrowOnError extends boolean = false>(options: Options<DeleteStreamsIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteStreamsIdResponses, DeleteStreamsIdErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/streams/{id}',
    ...options
});

/**
 * Report playback feedback (e.g. valid errors)
 */
export const reportPlaybackFeedback = <ThrowOnError extends boolean = false>(options: Options<ReportPlaybackFeedbackData, ThrowOnError>) => (options.client ?? client).post<ReportPlaybackFeedbackResponses, ReportPlaybackFeedbackErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/sessions/{sessionId}/feedback',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get recent logs
 */
export const getLogs = <ThrowOnError extends boolean = false>(options?: Options<GetLogsData, ThrowOnError>) => (options?.client ?? client).get<GetLogsResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/logs',
    ...options
});

/**
 * List all series recording rules
 */
export const getSeriesRules = <ThrowOnError extends boolean = false>(options?: Options<GetSeriesRulesData, ThrowOnError>) => (options?.client ?? client).get<GetSeriesRulesResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/series-rules',
    ...options
});

/**
 * Create a new series rule
 */
export const createSeriesRule = <ThrowOnError extends boolean = false>(options: Options<CreateSeriesRuleData, ThrowOnError>) => (options.client ?? client).post<CreateSeriesRuleResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/series-rules',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Run a specific series rule immediately
 */
export const runSeriesRule = <ThrowOnError extends boolean = false>(options: Options<RunSeriesRuleData, ThrowOnError>) => (options.client ?? client).post<RunSeriesRuleResponses, RunSeriesRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/series-rules/{id}/run',
    ...options
});

/**
 * Run all enabled series rules immediately
 */
export const runAllSeriesRules = <ThrowOnError extends boolean = false>(options?: Options<RunAllSeriesRulesData, ThrowOnError>) => (options?.client ?? client).post<RunAllSeriesRulesResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/series-rules/run',
    ...options
});

/**
 * Delete a series rule
 */
export const deleteSeriesRule = <ThrowOnError extends boolean = false>(options: Options<DeleteSeriesRuleData, ThrowOnError>) => (options.client ?? client).delete<DeleteSeriesRuleResponses, DeleteSeriesRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/series-rules/{id}',
    ...options
});

/**
 * Update an existing series rule
 */
export const updateSeriesRule = <ThrowOnError extends boolean = false>(options: Options<UpdateSeriesRuleData, ThrowOnError>) => (options.client ?? client).put<UpdateSeriesRuleResponses, UpdateSeriesRuleErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/series-rules/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get status of the capability scan
 */
export const getSystemScanStatus = <ThrowOnError extends boolean = false>(options?: Options<GetSystemScanStatusData, ThrowOnError>) => (options?.client ?? client).get<GetSystemScanStatusResponses, GetSystemScanStatusErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/system/scan',
    ...options
});

/**
 * Trigger a background scan of all channels for capabilities
 */
export const triggerSystemScan = <ThrowOnError extends boolean = false>(options?: Options<TriggerSystemScanData, ThrowOnError>) => (options?.client ?? client).post<TriggerSystemScanResponses, TriggerSystemScanErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/system/scan',
    ...options
});

/**
 * Create stream intent (start or stop session)
 */
export const createIntent = <ThrowOnError extends boolean = false>(options: Options<CreateIntentData, ThrowOnError>) => (options.client ?? client).post<CreateIntentResponses, CreateIntentErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/intents',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all sessions (admin only)
 */
export const listSessions = <ThrowOnError extends boolean = false>(options?: Options<ListSessionsData, ThrowOnError>) => (options?.client ?? client).get<ListSessionsResponses, ListSessionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/sessions',
    ...options
});

/**
 * Get session state
 */
export const getSessionState = <ThrowOnError extends boolean = false>(options: Options<GetSessionStateData, ThrowOnError>) => (options.client ?? client).get<GetSessionStateResponses, GetSessionStateErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/sessions/{sessionID}',
    ...options
});

/**
 * Serve HLS playlist or segment
 */
export const serveHls = <ThrowOnError extends boolean = false>(options: Options<ServeHlsData, ThrowOnError>) => (options.client ?? client).get<ServeHlsResponses, ServeHlsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/sessions/{sessionID}/hls/{filename}',
    ...options
});

/**
 * Get HLS content metadata (Safari compatibility)
 */
export const serveHlsHead = <ThrowOnError extends boolean = false>(options: Options<ServeHlsHeadData, ThrowOnError>) => (options.client ?? client).head<ServeHlsHeadResponses, ServeHlsHeadErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/sessions/{sessionID}/hls/{filename}',
    ...options
});
