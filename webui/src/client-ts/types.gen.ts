// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}/api/v3` | (string & {});
};

export type ApiError = {
    /**
     * Machine-readable error code
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Request ID for debugging
     */
    requestId: string;
    /**
     * Optional additional context
     */
    details?: unknown;
};

export type IntentRequest = {
    type?: 'stream.start' | 'stream.stop';
    /**
     * Required for stream.start. Enigma2 service reference (live playback only).
     */
    serviceRef?: string;
    /**
     * Hardware acceleration override (v3.1+).
     * - auto: Server decides based on GPU availability
     * - force: Force GPU encoding (fails if no GPU)
     * - off: Force CPU encoding
     *
     */
    hwaccel?: 'auto' | 'force' | 'off';
    /**
     * Optional correlation ID for end-to-end tracing
     */
    correlationId?: string;
    /**
     * Required for stream.stop intent
     */
    sessionId?: string;
    /**
     * Optional idempotency key for at-most-once semantics
     */
    idempotencyKey?: string;
    /**
     * Additional parameters
     */
    params?: {
        [key: string]: string;
    };
};

export type SessionResponse = {
    sessionId: string;
    /**
     * Request ID for debugging/tracing. Mandatory in P3-1.
     */
    requestId: string;
    serviceRef?: string;
    profile?: string;
    /**
     * Session lifecycle state. STARTING guarantees a session ticket is allocated.
     * READY/ACTIVE guarantees a playable HLS stream.
     *
     */
    state: 'STARTING' | 'BUFFERING' | 'ACTIVE' | 'STALLED' | 'ENDING' | 'IDLE' | 'ERROR' | 'NEW' | 'PRIMING' | 'READY' | 'DRAINING' | 'STOPPING' | 'STOPPED' | 'FAILED' | 'CANCELLED';
    /**
     * Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
     */
    reason?: 'R_NONE' | 'R_UNKNOWN' | 'R_BAD_REQUEST' | 'R_NOT_FOUND' | 'R_LEASE_BUSY' | 'R_TUNE_TIMEOUT' | 'R_LEASE_EXPIRED' | 'R_TUNE_FAILED' | 'R_INVARIANT_VIOLATION' | 'R_FFMPEG_START_FAILED' | 'R_PROCESS_ENDED' | 'R_PACKAGER_FAILED' | 'R_CANCELLED' | 'R_IDLE_TIMEOUT' | 'R_CLIENT_STOP';
    reasonDetail?: string;
    correlationId?: string;
    updatedAtMs?: number;
    /**
     * Playback mode for the session.
     */
    mode?: 'LIVE' | 'RECORDING';
    /**
     * DVR window length for live sessions, in seconds.
     */
    durationSeconds?: number;
    /**
     * Earliest seekable position in seconds.
     */
    seekableStartSeconds?: number;
    /**
     * Latest seekable position in seconds.
     */
    seekableEndSeconds?: number;
    /**
     * Current live edge position in seconds (live only).
     */
    liveEdgeSeconds?: number;
    /**
     * Playback URL for the HLS playlist.
     */
    playbackUrl?: string;
};

export type Service = {
    id?: string;
    name?: string;
    number?: string;
    group?: string;
    logoUrl?: string;
    enabled?: boolean;
    /**
     * Service reference for streaming (extracted from M3U URL)
     */
    serviceRef?: string;
};

export type SessionRecord = {
    sessionId?: string;
    serviceRef?: string;
    profile?: {
        [key: string]: unknown;
    };
    /**
     * Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
     * atomically published). PRIMING means FFmpeg is running but content is not yet playable.
     *
     */
    state?: 'NEW' | 'STARTING' | 'PRIMING' | 'READY' | 'DRAINING' | 'STOPPING' | 'STOPPED' | 'FAILED' | 'CANCELLED';
    /**
     * Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
     */
    reason?: 'R_NONE' | 'R_UNKNOWN' | 'R_BAD_REQUEST' | 'R_NOT_FOUND' | 'R_LEASE_BUSY' | 'R_TUNE_TIMEOUT' | 'R_LEASE_EXPIRED' | 'R_TUNE_FAILED' | 'R_INVARIANT_VIOLATION' | 'R_FFMPEG_START_FAILED' | 'R_PROCESS_ENDED' | 'R_PACKAGER_FAILED' | 'R_CANCELLED' | 'R_IDLE_TIMEOUT' | 'R_CLIENT_STOP';
    reasonDetail?: string;
    createdAtUnix?: number;
    updatedAtUnix?: number;
    lastAccessUnix?: number;
    tunerID?: string;
    correlationId?: string;
    contextData?: {
        [key: string]: string;
    };
};

export type ScanStatus = {
    state?: 'idle' | 'running' | 'complete' | 'failed' | 'cancelled';
    /**
     * Unix timestamp of when the current or last scan started
     */
    startedAt?: number;
    /**
     * Unix timestamp of when the last scan completed
     */
    finishedAt?: number;
    /**
     * Total number of channels in the playlist
     */
    totalChannels?: number;
    /**
     * Number of attempts (successful/failed) to probe channels so far
     */
    scannedChannels?: number;
    /**
     * Number of capabilities successfully updated in the store
     */
    updatedCount?: number;
    lastError?: string;
};

export type PlaybackFeedbackRequest = {
    event: 'error' | 'warning' | 'info';
    /**
     * MediaError code if applicable
     */
    code?: number;
    message?: string;
    details?: {
        [key: string]: unknown;
    };
};

export type Error = {
    type?: string;
    title?: string;
    status?: number;
    detail?: string;
};

export type SystemHealth = {
    status?: 'ok' | 'degraded' | 'error';
    receiver?: ComponentStatus;
    epg?: EpgStatus;
    version?: string;
    uptimeSeconds?: number;
};

export type SystemInfoData = {
    hardware?: {
        brand?: string;
        model?: string;
        boxtype?: string;
        chipset?: string;
        chipsetDescription?: string;
    };
    software?: {
        oeVersion?: string;
        imageDistro?: string;
        imageVersion?: string;
        enigmaVersion?: string;
        kernelVersion?: string;
        driverDate?: string;
        webifVersion?: string;
    };
    tuners?: Array<{
        name?: string;
        type?: string;
        status?: string;
    }>;
    network?: {
        interfaces?: Array<{
            name?: string;
            type?: string;
            speed?: string;
            mac?: string;
            ip?: string;
            ipv6?: string;
            dhcp?: boolean;
        }>;
    };
    storage?: {
        devices?: Array<StorageItem>;
        locations?: Array<StorageItem>;
    };
    runtime?: {
        uptime?: string;
    };
    resource?: {
        memoryTotal?: string;
        memoryAvailable?: string;
        memoryUsed?: string;
    };
};

export type StorageItem = {
    model?: string;
    capacity?: string;
    mount?: string;
    mountStatus: 'mounted' | 'unmounted' | 'unknown';
    /**
     * Status of the storage device. 'skipped' indicates the monitor was too busy to evaluate.
     */
    healthStatus: 'ok' | 'timeout' | 'error' | 'unknown' | 'skipped';
    /**
     * Access level detected during probe.
     */
    access: 'none' | 'ro' | 'rw';
    isNas: boolean;
    fsType?: string;
    checkedAt?: string;
};

export type ComponentStatus = {
    status?: 'ok' | 'error';
    lastCheck?: string;
};

export type EpgStatus = {
    status?: 'ok' | 'missing';
    missingChannels?: number;
};

/**
 * Current live service and EPG information from receiver
 */
export type CurrentServiceInfo = {
    status?: 'ok' | 'unavailable';
    channel?: {
        name?: string;
        ref?: string;
    };
    now?: {
        title?: string;
        description?: string;
        beginTimestamp?: number;
        durationSec?: number;
    };
    next?: {
        title?: string;
    };
};

export type OpenWebIfConfig = {
    baseUrl?: string;
    username?: string;
    password?: string;
    streamPort?: number;
};

export type EpgConfig = {
    enabled?: boolean;
    days?: number;
    source?: 'bouquet' | 'per-service';
};

export type PiconsConfig = {
    baseUrl?: string;
};

/**
 * Streaming delivery policy configuration (ADR-00X)
 */
export type StreamingConfig = {
    /**
     * Streaming delivery policy (only 'universal' is supported)
     */
    deliveryPolicy?: 'universal';
};

export type FeatureFlags = {
    [key: string]: unknown;
};

export type SeriesRuleRunReport = {
    ruleId?: string;
    runId?: string;
    trigger?: string;
    startedAt?: string;
    finishedAt?: string;
    durationMs?: number;
    windowFrom?: number;
    windowTo?: number;
    status?: 'success' | 'partial' | 'failed';
    summary?: RunSummary;
    snapshot?: RuleSnapshot;
    decisions?: Array<RunDecision>;
    errors?: Array<RunError>;
    conflicts?: Array<RunConflict>;
};

export type RunSummary = {
    epgItemsScanned?: number;
    epgItemsMatched?: number;
    timersAttempted?: number;
    timersCreated?: number;
    timersSkipped?: number;
    timersConflicted?: number;
    timersErrored?: number;
    maxTimersGlobalPerRunHit?: boolean;
    maxMatchesScannedPerRuleHit?: boolean;
    receiverUnreachable?: boolean;
};

export type RunDecision = {
    serviceRef?: string;
    begin?: number;
    end?: number;
    title?: string;
    action?: string;
    reason?: string;
    matchReason?: Array<string>;
    timerId?: string;
    details?: string;
};

export type RunError = {
    type?: string;
    message?: string;
    at?: string;
    retryable?: boolean;
};

export type RunConflict = {
    serviceRef?: string;
    begin?: number;
    end?: number;
    title?: string;
    blockingTimerId?: string;
    overlapSeconds?: number;
    message?: string;
};

export type RuleSnapshot = {
    id?: string;
    enabled?: boolean;
    keyword?: string;
    channelRef?: string;
    days?: Array<number>;
    startWindow?: string;
    priority?: number;
};

export type SeriesRule = {
    readonly id?: string;
    enabled?: boolean;
    /**
     * Search term or regex for event title
     */
    keyword?: string;
    /**
     * Optional service reference to restrict rule
     */
    channelRef?: string;
    /**
     * Days of week (0=Sunday)
     */
    days?: Array<number>;
    /**
     * Time window HHMM-HHMM
     */
    startWindow?: string;
    priority?: number;
    lastRunAt?: string;
    lastRunStatus?: string;
    lastRunSummary?: RunSummary;
};

export type SeriesRuleUpdate = {
    enabled: boolean;
    /**
     * Search term or regex for event title
     */
    keyword: string;
    /**
     * Optional service reference to restrict rule
     */
    channelRef?: string;
    /**
     * Days of week (0=Sunday)
     */
    days?: Array<number>;
    /**
     * Time window HHMM-HHMM
     */
    startWindow?: string;
    priority: number;
};

export type ConfigUpdate = {
    openWebIF?: OpenWebIfConfig;
    bouquets?: Array<string>;
    epg?: EpgConfig;
    picons?: PiconsConfig;
    featureFlags?: FeatureFlags;
};

export type AppConfig = {
    version?: string;
    dataDir?: string;
    logLevel?: string;
    openWebIF?: OpenWebIfConfig;
    bouquets?: Array<string>;
    epg?: EpgConfig;
    picons?: PiconsConfig;
    streaming?: StreamingConfig;
    featureFlags?: FeatureFlags;
};

export type Bouquet = {
    name?: string;
    services?: number;
};

export type NowNextRequest = {
    services: Array<string>;
};

export type NowNextEntry = {
    title: string;
    /**
     * Unix timestamp (seconds)
     */
    start: number;
    /**
     * Unix timestamp (seconds)
     */
    end: number;
};

export type NowNextItem = {
    serviceRef: string;
    now?: NowNextEntry;
    next?: NowNextEntry;
};

export type NowNextResponse = {
    items: Array<NowNextItem>;
};

export type ProblemDetails = {
    type: string;
    title: string;
    status: number;
    detail?: string;
    instance?: string;
    fields?: {
        [key: string]: unknown;
    };
    conflicts?: Array<TimerConflict>;
};

export type Timer = {
    timerId: string;
    serviceRef: string;
    begin: number;
    end: number;
    name: string;
    description?: string;
    serviceName?: string;
    state: 'scheduled' | 'recording' | 'completed' | 'disabled' | 'unknown';
    receiverState?: {
        [key: string]: unknown;
    };
    createdAt?: string;
    updatedAt?: string;
};

export type PlaybackInfo = {
    /**
     * Correlation ID for the request. Mandatory in P3-1.
     */
    requestId: string;
    /**
     * Unique ID for the stream session. Mandatory in P3-1.
     */
    sessionId: string;
    mode: PlaybackInfoMode;
    /**
     * Relative URL for the selected playback strategy. Optional for deny or decision-led cases.
     */
    url?: string;
    /**
     * Whether the stream is seekable. Omitted if unknown. Deprecated in favor of isSeekable.
     */
    seekable?: boolean;
    /**
     * Authoritative flag if the stream is seekable. Becomes required in P3-4.
     */
    isSeekable?: boolean;
    /**
     * Absolute DVR window length in seconds. Becomes required in P3-4.
     */
    dvr_window_seconds?: number;
    /**
     * wall-clock timestamp (UNIX) of the latest segment. Becomes required in P3-4.
     */
    live_edge_unix?: number;
    /**
     * wall-clock timestamp (UNIX) of the earliest segment in window. Becomes required in P3-4.
     */
    startUnix?: number;
    /**
     * Duration in seconds. Omitted if unknown or preparing.
     */
    durationSeconds?: number;
    durationSource?: PlaybackInfoDurationSource;
    /**
     * Optional resume state if available.
     */
    resume?: {
        /**
         * last known playback position in seconds
         */
        posSeconds: number;
        durationSeconds?: number;
        finished?: boolean;
    };
    /**
     * Truthful container name if known (e.g., ts, mp4, mkv).
     */
    container?: string;
    /**
     * Truthful video codec if known (e.g., h264, hevc, mpeg2).
     */
    videoCodec?: string;
    /**
     * Truthful audio codec if known (e.g., aac, ac3, mp2).
     */
    audioCodec?: string;
    reason?: PlaybackInfoReason;
    decision?: PlaybackDecision;
};

/**
 * Selected playback strategy output mode.
 */
export type PlaybackInfoMode = 'hls' | 'direct_mp4' | 'deny';

/**
 * Source of the reported duration, when durationSeconds is present.
 */
export type PlaybackInfoDurationSource = 'store' | 'cache' | 'probe';

/**
 * Reason for the playback decision.
 */
export type PlaybackInfoReason = 'directplay_match' | 'transcode_audio' | 'transcode_video' | 'transcode_all' | 'container_mismatch' | 'unknown';

/**
 * Client capabilities for playback decision (P4-1)
 */
export type PlaybackCapabilities = {
    /**
     * Capabilities contract version (current: 1)
     */
    capabilitiesVersion: number;
    /**
     * Supported container formats
     */
    container: Array<string>;
    /**
     * Supported video codecs
     */
    videoCodecs: Array<string>;
    /**
     * Supported audio codecs
     */
    audioCodecs: Array<string>;
    /**
     * Optional resolution/FPS constraints
     */
    maxVideo?: {
        width?: number;
        height?: number;
        fps?: number;
    };
    /**
     * Whether client supports HLS playlists
     */
    supportsHls?: boolean;
    /**
     * Whether client supports HTTP range requests
     */
    supportsRange?: boolean;
    /**
     * Client device category for policy decisions
     */
    deviceType?: string;
    /**
     * Whether client allows transcoding (force bypass)
     */
    allowTranscode?: boolean;
};

/**
 * Complete playback decision from backend (P4-1)
 */
export type PlaybackDecision = {
    /**
     * Playback mode decision
     */
    mode: 'direct_play' | 'direct_stream' | 'transcode' | 'deny';
    /**
     * The explicitly selected playback URL (backend-driven).
     */
    selectedOutputUrl: string;
    /**
     * The explicitly selected playback kind.
     */
    selectedOutputKind: 'file' | 'hls';
    /**
     * Selected output format
     */
    selected: {
        container: string;
        videoCodec: string;
        audioCodec: string;
    };
    /**
     * Available output URLs/playlists
     */
    outputs: Array<PlaybackOutput>;
    /**
     * Applied constraints (e.g., downscale_required)
     */
    constraints: Array<string>;
    /**
     * Machine-readable decision reason codes
     */
    reasons: Array<string>;
    trace: PlaybackTrace;
};

/**
 * Traceability information
 */
export type PlaybackTrace = {
    /**
     * Correlation ID (UUID or prefixed string like req_abc123)
     */
    requestId: string;
    sessionId?: string | null;
};

/**
 * Output URL for client playback
 */
export type PlaybackOutput = PlaybackOutputFile | PlaybackOutputHls;

export type PlaybackOutputFile = {
    /**
     * Static file output
     */
    kind: 'file';
    /**
     * Direct playback URL
     */
    url: string;
};

export type PlaybackOutputHls = {
    /**
     * HLS stream output
     */
    kind: 'hls';
    /**
     * Canonical HLS playlist URL (.m3u8)
     */
    playlistUrl: string;
    /**
     * Alternate playback URL (optional)
     */
    url?: string;
};

export type ProblemCapabilitiesMissing = ProblemDetails & {
    code?: 'capabilities_missing';
};

export type ProblemCapabilitiesInvalid = ProblemDetails & {
    code?: 'capabilities_invalid';
};

export type ProblemDecisionAmbiguous = ProblemDetails & {
    code?: 'decision_ambiguous';
};

export type TimerCreateRequest = {
    serviceRef: string;
    begin: number;
    end: number;
    name: string;
    description?: string;
    enabled?: boolean;
    justPlay?: boolean;
    afterEvent?: 'default' | 'standby' | 'deepstandby' | 'nothing';
    paddingBeforeSec?: number;
    paddingAfterSec?: number;
    idempotencyKey?: string;
};

export type TimerPatchRequest = {
    begin?: number;
    end?: number;
    name?: string;
    description?: string;
    enabled?: boolean;
    paddingBeforeSec?: number;
    paddingAfterSec?: number;
};

export type TimerConflict = {
    type: 'overlap' | 'duplicate' | 'tuner_limit' | 'unknown';
    blockingTimer: Timer;
    overlapSeconds?: number;
    message?: string;
};

export type TimerConflictPreviewRequest = {
    proposed: TimerCreateRequest;
    mode?: 'conservative' | 'receiverAware';
};

export type TimerConflictPreviewResponse = {
    canSchedule: boolean;
    conflicts: Array<TimerConflict>;
    suggestions?: Array<{
        kind?: 'reduce_padding' | 'shift_start' | 'shift_end';
        proposedBegin?: number;
        proposedEnd?: number;
        note?: string;
    }>;
};

export type DvrCapabilities = {
    timers: {
        edit?: boolean;
        delete?: boolean;
        readBackVerify?: boolean;
    };
    conflicts: {
        preview?: boolean;
        receiverAware?: boolean;
    };
    series: {
        supported?: boolean;
        mode?: 'none' | 'delegated' | 'managed';
        delegatedProvider?: string;
    };
};

export type RecordingStatus = {
    isRecording: boolean;
    serviceName?: string;
};

export type RecordingBuildStatus = {
    /**
     * Correlation ID for the request.
     */
    requestId: string;
    state: 'IDLE' | 'RUNNING' | 'FAILED' | 'READY';
    segmentCount?: number;
    lastProgress?: string;
    startedAt?: string;
    attemptMode?: 'fast' | 'robust';
    error?: string;
    /**
     * True if a progressive (timeshift) playlist is playable.
     */
    progressiveReady?: boolean;
};

export type TimerList = {
    items: Array<Timer>;
};

export type LogEntry = {
    time?: string;
    level?: string;
    message?: string;
    fields?: {
        [key: string]: unknown;
    };
};

export type StreamSession = {
    /**
     * Internal database ID (deprecated).
     */
    id?: string;
    /**
     * Mandatory stream lifecycle ID (domain truth).
     */
    sessionId: string;
    /**
     * Correlation ID for the trace. Mandatory in P3-1.
     */
    requestId: string;
    clientIp?: string;
    channelName?: string;
    startedAt?: string;
    state: 'starting' | 'buffering' | 'active' | 'stalled' | 'ending' | 'idle' | 'error';
    program?: {
        title?: string;
        description?: string;
        beginTimestamp?: number;
        durationSec?: number;
    };
};

export type RecordingRoot = {
    id?: string;
    name?: string;
};

export type Breadcrumb = {
    name?: string;
    path?: string;
};

export type DirectoryItem = {
    name?: string;
    path?: string;
};

export type RecordingItem = {
    /**
     * Legacy receiver service reference (read-only).
     */
    serviceRef?: string;
    /**
     * Base64url-encoded recording ID (RFC 4648, unpadded) to use for /recordings/{recordingId}.
     */
    recordingId?: string;
    title?: string;
    description?: string;
    /**
     * Recording start time as UNIX seconds.
     */
    begin_unix_seconds?: number;
    /**
     * Recording duration in seconds, if known.
     */
    durationSeconds?: number;
    /**
     * Human-readable duration string for display only.
     */
    length?: string;
    filename?: string;
    /**
     * Consolidated recording status. Becomes required in P3-3.
     */
    status?: 'pending' | 'recording' | 'completed' | 'failed' | 'deleting';
    resume?: ResumeSummary;
};

export type ResumeSummary = {
    posSeconds?: number;
    durationSeconds?: number;
    finished?: boolean;
    updatedAt?: string;
};

export type RecordingResponse = {
    /**
     * Correlation ID for the request.
     */
    requestId: string;
    roots?: Array<RecordingRoot>;
    currentRoot?: string;
    currentPath?: string;
    breadcrumbs?: Array<Breadcrumb>;
    directories?: Array<DirectoryItem>;
    recordings?: Array<RecordingItem>;
};

export type FeatureFlagsWritable = {
    [key: string]: unknown;
};

export type SeriesRuleWritable = {
    enabled?: boolean;
    /**
     * Search term or regex for event title
     */
    keyword?: string;
    /**
     * Optional service reference to restrict rule
     */
    channelRef?: string;
    /**
     * Days of week (0=Sunday)
     */
    days?: Array<number>;
    /**
     * Time window HHMM-HHMM
     */
    startWindow?: string;
    priority?: number;
    lastRunAt?: string;
    lastRunStatus?: string;
    lastRunSummary?: RunSummary;
};

export type GetSystemHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/health';
};

export type GetSystemHealthResponses = {
    /**
     * Health status
     */
    200: SystemHealth;
};

export type GetSystemHealthResponse = GetSystemHealthResponses[keyof GetSystemHealthResponses];

export type GetSystemHealthzData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/healthz';
};

export type GetSystemHealthzResponses = {
    /**
     * Health status
     */
    200: {
        status: 'ok';
    };
};

export type GetSystemHealthzResponse = GetSystemHealthzResponses[keyof GetSystemHealthzResponses];

export type GetSystemConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/config';
};

export type GetSystemConfigResponses = {
    /**
     * Configuration
     */
    200: AppConfig;
};

export type GetSystemConfigResponse = GetSystemConfigResponses[keyof GetSystemConfigResponses];

export type PutSystemConfigData = {
    body: ConfigUpdate;
    path?: never;
    query?: never;
    url: '/system/config';
};

export type PutSystemConfigErrors = {
    /**
     * Invalid configuration
     */
    400: unknown;
    /**
     * Failed to save configuration
     */
    500: unknown;
};

export type PutSystemConfigResponses = {
    /**
     * Configuration updated
     */
    200: {
        restartRequired?: boolean;
    };
};

export type PutSystemConfigResponse = PutSystemConfigResponses[keyof PutSystemConfigResponses];

export type GetReceiverCurrentData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/receiver/current';
};

export type GetReceiverCurrentErrors = {
    /**
     * Failed to query receiver
     */
    502: ProblemDetails;
    /**
     * Receiver client unavailable
     */
    503: ProblemDetails;
};

export type GetReceiverCurrentError = GetReceiverCurrentErrors[keyof GetReceiverCurrentErrors];

export type GetReceiverCurrentResponses = {
    /**
     * Current service information
     */
    200: CurrentServiceInfo;
};

export type GetReceiverCurrentResponse = GetReceiverCurrentResponses[keyof GetReceiverCurrentResponses];

export type GetSystemInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/info';
};

export type GetSystemInfoResponses = {
    /**
     * System information
     */
    200: SystemInfoData;
};

export type GetSystemInfoResponse = GetSystemInfoResponses[keyof GetSystemInfoResponses];

export type PostSystemRefreshData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/refresh';
};

export type PostSystemRefreshErrors = {
    /**
     * Refresh already in progress
     */
    409: unknown;
};

export type PostSystemRefreshResponses = {
    /**
     * Refresh started
     */
    202: unknown;
};

export type GetServicesBouquetsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/services/bouquets';
};

export type GetServicesBouquetsResponses = {
    /**
     * List of bouquets
     */
    200: Array<Bouquet>;
};

export type GetServicesBouquetsResponse = GetServicesBouquetsResponses[keyof GetServicesBouquetsResponses];

export type PostServicesNowNextData = {
    body: NowNextRequest;
    path?: never;
    query?: never;
    url: '/services/now-next';
};

export type PostServicesNowNextErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type PostServicesNowNextResponses = {
    /**
     * Now/next EPG entries per service
     */
    200: NowNextResponse;
};

export type PostServicesNowNextResponse = PostServicesNowNextResponses[keyof PostServicesNowNextResponses];

export type GetEpgData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Start timestamp (unix seconds)
         */
        from?: number;
        /**
         * End timestamp (unix seconds)
         */
        to?: number;
        /**
         * Filter by bouquet name
         */
        bouquet?: string;
        /**
         * Filter by search query
         */
        q?: string;
    };
    url: '/epg';
};

export type GetEpgResponses = {
    /**
     * EPG data
     */
    200: {
        items?: Array<{
            serviceRef?: string;
            title?: string;
            desc?: string;
            start?: number;
            end?: number;
        }>;
    };
};

export type GetEpgResponse = GetEpgResponses[keyof GetEpgResponses];

export type GetServicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by bouquet name
         */
        bouquet?: string;
    };
    url: '/services';
};

export type GetServicesResponses = {
    /**
     * List of services
     */
    200: Array<Service>;
};

export type GetServicesResponse = GetServicesResponses[keyof GetServicesResponses];

export type PostServicesByIdToggleData = {
    body: {
        enabled?: boolean;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/services/{id}/toggle';
};

export type PostServicesByIdToggleErrors = {
    /**
     * Service not found
     */
    404: unknown;
};

export type PostServicesByIdToggleResponses = {
    /**
     * Status updated
     */
    200: unknown;
};

export type GetStreamsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/streams';
};

export type GetStreamsResponses = {
    /**
     * Active sessions
     */
    200: Array<StreamSession>;
};

export type GetStreamsResponse = GetStreamsResponses[keyof GetStreamsResponses];

export type GetRecordingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Root location ID
         */
        root?: string;
        /**
         * Relative path
         */
        path?: string;
    };
    url: '/recordings';
};

export type GetRecordingsResponses = {
    /**
     * Recordings list
     */
    200: RecordingResponse;
};

export type GetRecordingsResponse = GetRecordingsResponses[keyof GetRecordingsResponses];

export type DeleteRecordingData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recordingId
         */
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}';
};

export type DeleteRecordingErrors = {
    /**
     * Invalid recording reference
     */
    400: unknown;
    /**
     * Access denied
     */
    403: unknown;
    /**
     * Recording not found
     */
    404: unknown;
    /**
     * Failed to delete recording
     */
    500: unknown;
};

export type DeleteRecordingResponses = {
    /**
     * Recording deleted
     */
    204: void;
};

export type DeleteRecordingResponse = DeleteRecordingResponses[keyof DeleteRecordingResponses];

export type GetRecordingsByRecordingIdStatusData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/status';
};

export type GetRecordingsByRecordingIdStatusErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
};

export type GetRecordingsByRecordingIdStatusError = GetRecordingsByRecordingIdStatusErrors[keyof GetRecordingsByRecordingIdStatusErrors];

export type GetRecordingsByRecordingIdStatusResponses = {
    /**
     * Build status
     */
    200: RecordingBuildStatus;
};

export type GetRecordingsByRecordingIdStatusResponse = GetRecordingsByRecordingIdStatusResponses[keyof GetRecordingsByRecordingIdStatusResponses];

export type GetRecordingPlaybackInfoData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/stream-info';
};

export type GetRecordingPlaybackInfoErrors = {
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Preparing (media truth unknown, retryable)
     */
    503: ProblemDetails;
};

export type GetRecordingPlaybackInfoError = GetRecordingPlaybackInfoErrors[keyof GetRecordingPlaybackInfoErrors];

export type GetRecordingPlaybackInfoResponses = {
    /**
     * Playback strategy info
     */
    200: PlaybackInfo;
};

export type GetRecordingPlaybackInfoResponse = GetRecordingPlaybackInfoResponses[keyof GetRecordingPlaybackInfoResponses];

export type PostRecordingPlaybackInfoData = {
    /**
     * Client capabilities for decision making
     */
    body: PlaybackCapabilities;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/stream-info';
};

export type PostRecordingPlaybackInfoErrors = {
    /**
     * Invalid capabilities
     */
    400: ProblemCapabilitiesInvalid;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Capabilities missing (required for v3.1+)
     */
    412: ProblemCapabilitiesMissing;
    /**
     * Decision ambiguous (media truth unknown)
     */
    422: ProblemDecisionAmbiguous;
    /**
     * Preparing (media truth unknown, retryable)
     */
    503: ProblemDetails;
};

export type PostRecordingPlaybackInfoError = PostRecordingPlaybackInfoErrors[keyof PostRecordingPlaybackInfoErrors];

export type PostRecordingPlaybackInfoResponses = {
    /**
     * Playback decision and info
     */
    200: PlaybackInfo;
};

export type PostRecordingPlaybackInfoResponse = PostRecordingPlaybackInfoResponses[keyof PostRecordingPlaybackInfoResponses];

export type StreamRecordingDirectData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/stream.mp4';
};

export type StreamRecordingDirectErrors = {
    /**
     * Recording not found
     */
    404: unknown;
    /**
     * Preparing (retryable)
     */
    503: unknown;
};

export type StreamRecordingDirectResponses = {
    /**
     * Video stream
     */
    200: Blob | File;
};

export type StreamRecordingDirectResponse = StreamRecordingDirectResponses[keyof StreamRecordingDirectResponses];

export type ProbeRecordingMp4Data = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/stream.mp4';
};

export type ProbeRecordingMp4Errors = {
    /**
     * Not found
     */
    404: unknown;
    /**
     * Preparing (retryable)
     */
    503: unknown;
};

export type ProbeRecordingMp4Responses = {
    /**
     * Available
     */
    200: unknown;
};

export type GetRecordingHlsPlaylistData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recordingId
         */
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/playlist.m3u8';
};

export type GetRecordingHlsPlaylistErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Recording not ready for VOD
     */
    503: ProblemDetails;
};

export type GetRecordingHlsPlaylistError = GetRecordingHlsPlaylistErrors[keyof GetRecordingHlsPlaylistErrors];

export type GetRecordingHlsPlaylistResponses = {
    /**
     * HLS Playlist
     */
    200: string;
};

export type GetRecordingHlsPlaylistResponse = GetRecordingHlsPlaylistResponses[keyof GetRecordingHlsPlaylistResponses];

export type GetRecordingHlsPlaylistHeadData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/playlist.m3u8';
};

export type GetRecordingHlsPlaylistHeadErrors = {
    /**
     * Recording not found
     */
    404: unknown;
};

export type GetRecordingHlsPlaylistHeadResponses = {
    /**
     * HLS playlist metadata
     */
    200: unknown;
};

export type GetRecordingHlsTimeshiftData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recordingId
         */
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/timeshift.m3u8';
};

export type GetRecordingHlsTimeshiftErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Recording not ready for timeshift
     */
    503: ApiError;
};

export type GetRecordingHlsTimeshiftError = GetRecordingHlsTimeshiftErrors[keyof GetRecordingHlsTimeshiftErrors];

export type GetRecordingHlsTimeshiftResponses = {
    /**
     * HLS Playlist
     */
    200: string;
};

export type GetRecordingHlsTimeshiftResponse = GetRecordingHlsTimeshiftResponses[keyof GetRecordingHlsTimeshiftResponses];

export type GetRecordingHlsTimeshiftHeadData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/timeshift.m3u8';
};

export type GetRecordingHlsTimeshiftHeadErrors = {
    /**
     * Recording not found
     */
    404: unknown;
};

export type GetRecordingHlsTimeshiftHeadResponses = {
    /**
     * HLS playlist metadata
     */
    200: unknown;
};

export type GetRecordingHlsCustomSegmentData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recordingId
         */
        recordingId: string;
        segment: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/{segment}';
};

export type GetRecordingHlsCustomSegmentErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Recording not ready
     */
    409: ApiError;
};

export type GetRecordingHlsCustomSegmentError = GetRecordingHlsCustomSegmentErrors[keyof GetRecordingHlsCustomSegmentErrors];

export type GetRecordingHlsCustomSegmentResponses = {
    /**
     * Media Segment
     */
    200: Blob | File;
};

export type GetRecordingHlsCustomSegmentResponse = GetRecordingHlsCustomSegmentResponses[keyof GetRecordingHlsCustomSegmentResponses];

export type GetRecordingHlsCustomSegmentHeadData = {
    body?: never;
    path: {
        recordingId: string;
        segment: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/{segment}';
};

export type GetRecordingHlsCustomSegmentHeadErrors = {
    /**
     * Segment not found
     */
    404: unknown;
};

export type GetRecordingHlsCustomSegmentHeadResponses = {
    /**
     * Segment metadata
     */
    200: unknown;
};

export type CreateSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/session';
};

export type CreateSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateSessionResponses = {
    /**
     * Session created
     */
    204: void;
};

export type CreateSessionResponse = CreateSessionResponses[keyof CreateSessionResponses];

export type GetTimersData = {
    body?: never;
    path?: never;
    query?: {
        state?: string;
        from?: number;
    };
    url: '/timers';
};

export type GetTimersResponses = {
    /**
     * List of timers
     */
    200: TimerList;
};

export type GetTimersResponse = GetTimersResponses[keyof GetTimersResponses];

export type AddTimerData = {
    body: TimerCreateRequest;
    path?: never;
    query?: never;
    url: '/timers';
};

export type AddTimerErrors = {
    /**
     * Duplicate timer
     */
    409: ProblemDetails;
    /**
     * Conflict or validation error
     */
    422: ProblemDetails;
    /**
     * Receiver inconsistent (verification failed)
     */
    502: ProblemDetails;
};

export type AddTimerError = AddTimerErrors[keyof AddTimerErrors];

export type AddTimerResponses = {
    /**
     * Timer created
     */
    201: Timer;
};

export type AddTimerResponse = AddTimerResponses[keyof AddTimerResponses];

export type DeleteTimerData = {
    body?: never;
    path: {
        timerId: string;
    };
    query?: never;
    url: '/timers/{timerId}';
};

export type DeleteTimerErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type DeleteTimerResponses = {
    /**
     * Deleted
     */
    204: void;
};

export type DeleteTimerResponse = DeleteTimerResponses[keyof DeleteTimerResponses];

export type GetTimerData = {
    body?: never;
    path: {
        timerId: string;
    };
    query?: never;
    url: '/timers/{timerId}';
};

export type GetTimerErrors = {
    /**
     * Timer not found
     */
    404: unknown;
};

export type GetTimerResponses = {
    /**
     * Timer details
     */
    200: Timer;
};

export type GetTimerResponse = GetTimerResponses[keyof GetTimerResponses];

export type UpdateTimerData = {
    body: TimerPatchRequest;
    path: {
        timerId: string;
    };
    query?: never;
    url: '/timers/{timerId}';
};

export type UpdateTimerErrors = {
    /**
     * Timer not found
     */
    404: unknown;
    /**
     * Duplicate resulting from edit
     */
    409: ProblemDetails;
    /**
     * Conflict
     */
    422: ProblemDetails;
    /**
     * Receiver fail / Rollback
     */
    502: unknown;
};

export type UpdateTimerError = UpdateTimerErrors[keyof UpdateTimerErrors];

export type UpdateTimerResponses = {
    /**
     * Timer updated
     */
    200: Timer;
};

export type UpdateTimerResponse = UpdateTimerResponses[keyof UpdateTimerResponses];

export type PreviewConflictsData = {
    body: TimerConflictPreviewRequest;
    path?: never;
    query?: never;
    url: '/timers/conflicts:preview';
};

export type PreviewConflictsResponses = {
    /**
     * Preview result
     */
    200: TimerConflictPreviewResponse;
};

export type PreviewConflictsResponse = PreviewConflictsResponses[keyof PreviewConflictsResponses];

export type GetDvrCapabilitiesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/dvr/capabilities';
};

export type GetDvrCapabilitiesResponses = {
    /**
     * Capabilities
     */
    200: DvrCapabilities;
};

export type GetDvrCapabilitiesResponse = GetDvrCapabilitiesResponses[keyof GetDvrCapabilitiesResponses];

export type GetDvrStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/dvr/status';
};

export type GetDvrStatusResponses = {
    /**
     * Recording status
     */
    200: RecordingStatus;
};

export type GetDvrStatusResponse = GetDvrStatusResponses[keyof GetDvrStatusResponses];

export type DeleteStreamsIdData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/streams/{id}';
};

export type DeleteStreamsIdErrors = {
    /**
     * Session not found
     */
    404: unknown;
};

export type DeleteStreamsIdResponses = {
    /**
     * Session terminated
     */
    204: void;
};

export type DeleteStreamsIdResponse = DeleteStreamsIdResponses[keyof DeleteStreamsIdResponses];

export type ReportPlaybackFeedbackData = {
    body?: PlaybackFeedbackRequest;
    path: {
        sessionId: string;
    };
    query?: never;
    url: '/sessions/{sessionId}/feedback';
};

export type ReportPlaybackFeedbackErrors = {
    /**
     * Session not found
     */
    404: unknown;
};

export type ReportPlaybackFeedbackResponses = {
    /**
     * Feedback accepted
     */
    202: unknown;
};

export type GetLogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/logs';
};

export type GetLogsResponses = {
    /**
     * Recent log entries
     */
    200: Array<LogEntry>;
};

export type GetLogsResponse = GetLogsResponses[keyof GetLogsResponses];

export type GetSeriesRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/series-rules';
};

export type GetSeriesRulesResponses = {
    /**
     * List of rules
     */
    200: Array<SeriesRule>;
};

export type GetSeriesRulesResponse = GetSeriesRulesResponses[keyof GetSeriesRulesResponses];

export type CreateSeriesRuleData = {
    body: SeriesRuleWritable;
    path?: never;
    query?: never;
    url: '/series-rules';
};

export type CreateSeriesRuleResponses = {
    /**
     * Created
     */
    201: SeriesRule;
};

export type CreateSeriesRuleResponse = CreateSeriesRuleResponses[keyof CreateSeriesRuleResponses];

export type RunSeriesRuleData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        trigger?: string;
    };
    url: '/series-rules/{id}/run';
};

export type RunSeriesRuleErrors = {
    /**
     * Rule not found
     */
    404: unknown;
};

export type RunSeriesRuleResponses = {
    /**
     * Run report
     */
    200: SeriesRuleRunReport;
};

export type RunSeriesRuleResponse = RunSeriesRuleResponses[keyof RunSeriesRuleResponses];

export type RunAllSeriesRulesData = {
    body?: never;
    path?: never;
    query?: {
        trigger?: string;
    };
    url: '/series-rules/run';
};

export type RunAllSeriesRulesResponses = {
    /**
     * List of run reports
     */
    200: Array<SeriesRuleRunReport>;
};

export type RunAllSeriesRulesResponse = RunAllSeriesRulesResponses[keyof RunAllSeriesRulesResponses];

export type DeleteSeriesRuleData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/series-rules/{id}';
};

export type DeleteSeriesRuleErrors = {
    /**
     * Rule not found
     */
    404: unknown;
};

export type DeleteSeriesRuleResponses = {
    /**
     * Deleted
     */
    204: void;
};

export type DeleteSeriesRuleResponse = DeleteSeriesRuleResponses[keyof DeleteSeriesRuleResponses];

export type UpdateSeriesRuleData = {
    body: SeriesRuleUpdate;
    path: {
        id: string;
    };
    query?: never;
    url: '/series-rules/{id}';
};

export type UpdateSeriesRuleErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Rule not found
     */
    404: unknown;
};

export type UpdateSeriesRuleResponses = {
    /**
     * Updated
     */
    200: SeriesRule;
};

export type UpdateSeriesRuleResponse = UpdateSeriesRuleResponses[keyof UpdateSeriesRuleResponses];

export type GetSystemScanStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/scan';
};

export type GetSystemScanStatusErrors = {
    /**
     * Unauthorized
     */
    401: ApiError;
    /**
     * Scanner not initialized
     */
    503: ApiError;
};

export type GetSystemScanStatusError = GetSystemScanStatusErrors[keyof GetSystemScanStatusErrors];

export type GetSystemScanStatusResponses = {
    /**
     * Current scan status
     */
    200: ScanStatus;
};

export type GetSystemScanStatusResponse = GetSystemScanStatusResponses[keyof GetSystemScanStatusResponses];

export type TriggerSystemScanData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/scan';
};

export type TriggerSystemScanErrors = {
    /**
     * Unauthorized
     */
    401: ApiError;
    /**
     * Internal Server Error
     */
    500: ApiError;
};

export type TriggerSystemScanError = TriggerSystemScanErrors[keyof TriggerSystemScanErrors];

export type TriggerSystemScanResponses = {
    /**
     * Scan already running
     */
    200: {
        status?: string;
    };
    /**
     * Scan initiated
     */
    202: {
        status?: string;
    };
};

export type TriggerSystemScanResponse = TriggerSystemScanResponses[keyof TriggerSystemScanResponses];

export type CreateIntentData = {
    body: IntentRequest;
    path?: never;
    query?: never;
    url: '/intents';
};

export type CreateIntentErrors = {
    /**
     * Invalid request
     */
    400: ApiError;
    /**
     * Lease busy (capacity rejection; no session created)
     */
    409: ApiError;
    /**
     * V3 control plane unavailable
     */
    503: ApiError;
};

export type CreateIntentError = CreateIntentErrors[keyof CreateIntentErrors];

export type CreateIntentResponses = {
    /**
     * Intent accepted
     */
    202: {
        sessionId?: string;
        status?: 'accepted' | 'idempotent_replay';
        correlationId?: string;
    };
};

export type CreateIntentResponse = CreateIntentResponses[keyof CreateIntentResponses];

export type ListSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination offset
         */
        offset?: number;
        /**
         * Pagination limit (max 1000)
         */
        limit?: number;
    };
    url: '/sessions';
};

export type ListSessionsErrors = {
    /**
     * V3 control plane unavailable
     */
    503: ApiError;
};

export type ListSessionsError = ListSessionsErrors[keyof ListSessionsErrors];

export type ListSessionsResponses = {
    /**
     * Sessions list with pagination metadata
     */
    200: {
        sessions?: Array<SessionRecord>;
        pagination?: {
            offset?: number;
            limit?: number;
            total?: number;
            count?: number;
        };
    };
};

export type ListSessionsResponse = ListSessionsResponses[keyof ListSessionsResponses];

export type GetSessionStateData = {
    body?: never;
    path: {
        sessionID: string;
    };
    query?: never;
    url: '/sessions/{sessionID}';
};

export type GetSessionStateErrors = {
    /**
     * Invalid session ID
     */
    400: ApiError;
    /**
     * Session not found
     */
    404: ApiError;
};

export type GetSessionStateError = GetSessionStateErrors[keyof GetSessionStateErrors];

export type GetSessionStateResponses = {
    /**
     * Session state
     */
    200: SessionResponse;
};

export type GetSessionStateResponse = GetSessionStateResponses[keyof GetSessionStateResponses];

export type ServeHlsData = {
    body?: never;
    path: {
        sessionID: string;
        filename: string;
    };
    query?: never;
    url: '/sessions/{sessionID}/hls/{filename}';
};

export type ServeHlsErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * File not found
     */
    404: unknown;
    /**
     * V3 control plane unavailable
     */
    503: unknown;
};

export type ServeHlsResponses = {
    /**
     * HLS content
     */
    200: string;
};

export type ServeHlsResponse = ServeHlsResponses[keyof ServeHlsResponses];

export type ServeHlsHeadData = {
    body?: never;
    path: {
        sessionID: string;
        filename: string;
    };
    query?: never;
    url: '/sessions/{sessionID}/hls/{filename}';
};

export type ServeHlsHeadErrors = {
    /**
     * File not found
     */
    404: unknown;
    /**
     * V3 control plane unavailable
     */
    503: unknown;
};

export type ServeHlsHeadResponses = {
    /**
     * HLS content metadata (headers only)
     */
    200: unknown;
};
