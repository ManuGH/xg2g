// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}/api/v3` | (string & {});
};

export type ApiError = {
    /**
     * Machine-readable error code
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Request ID for debugging
     */
    request_id: string;
    /**
     * Optional additional context
     */
    details?: unknown;
};

export type IntentRequest = {
    type?: 'stream.start' | 'stream.stop';
    /**
     * Required for stream.start. Enigma2 service reference (live playback only).
     */
    serviceRef?: string;
    /**
     * Transcoding profile ID
     */
    profileID?: string;
    /**
     * Legacy alias for profileID (decode-only, will be removed in v3.2)
     *
     * @deprecated
     */
    profile?: string;
    /**
     * Optional correlation ID for end-to-end tracing
     */
    correlationId?: string;
    /**
     * Required for stream.stop intent
     */
    sessionId?: string;
    /**
     * Optional idempotency key for at-most-once semantics
     */
    idempotencyKey?: string;
    /**
     * Additional parameters
     */
    params?: {
        [key: string]: string;
    };
};

export type SessionResponse = {
    sessionId: string;
    serviceRef?: string;
    profile?: string;
    /**
     * Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
     * atomically published). PRIMING means FFmpeg is running but content is not yet playable.
     *
     */
    state: 'NEW' | 'STARTING' | 'PRIMING' | 'READY' | 'DRAINING' | 'STOPPING' | 'STOPPED' | 'FAILED' | 'CANCELLED';
    /**
     * Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
     */
    reason?: 'R_NONE' | 'R_UNKNOWN' | 'R_BAD_REQUEST' | 'R_NOT_FOUND' | 'R_LEASE_BUSY' | 'R_TUNE_TIMEOUT' | 'R_LEASE_EXPIRED' | 'R_TUNE_FAILED' | 'R_INVARIANT_VIOLATION' | 'R_FFMPEG_START_FAILED' | 'R_PROCESS_ENDED' | 'R_PACKAGER_FAILED' | 'R_CANCELLED' | 'R_IDLE_TIMEOUT' | 'R_CLIENT_STOP';
    reasonDetail?: string;
    correlationId?: string;
    updatedAtMs?: number;
    /**
     * Playback mode for the session.
     */
    mode?: 'LIVE' | 'RECORDING';
    /**
     * DVR window length for live sessions, in seconds.
     */
    durationSeconds?: number;
    /**
     * Earliest seekable position in seconds.
     */
    seekableStartSeconds?: number;
    /**
     * Latest seekable position in seconds.
     */
    seekableEndSeconds?: number;
    /**
     * Current live edge position in seconds (live only).
     */
    liveEdgeSeconds?: number;
    /**
     * Playback URL for the HLS playlist.
     */
    playbackUrl?: string;
};

export type SessionRecord = {
    sessionId?: string;
    serviceRef?: string;
    profile?: {
        [key: string]: unknown;
    };
    /**
     * Session lifecycle state. READY guarantees a playable HLS stream (playlist + at least one segment,
     * atomically published). PRIMING means FFmpeg is running but content is not yet playable.
     *
     */
    state?: 'NEW' | 'STARTING' | 'PRIMING' | 'READY' | 'DRAINING' | 'STOPPING' | 'STOPPED' | 'FAILED' | 'CANCELLED';
    /**
     * Reason code; R_LEASE_BUSY means capacity rejection (no tuner available), not a system fault.
     */
    reason?: 'R_NONE' | 'R_UNKNOWN' | 'R_BAD_REQUEST' | 'R_NOT_FOUND' | 'R_LEASE_BUSY' | 'R_TUNE_TIMEOUT' | 'R_LEASE_EXPIRED' | 'R_TUNE_FAILED' | 'R_INVARIANT_VIOLATION' | 'R_FFMPEG_START_FAILED' | 'R_PROCESS_ENDED' | 'R_PACKAGER_FAILED' | 'R_CANCELLED' | 'R_IDLE_TIMEOUT' | 'R_CLIENT_STOP';
    reasonDetail?: string;
    createdAtUnix?: number;
    updatedAtUnix?: number;
    lastAccessUnix?: number;
    tunerID?: string;
    correlationId?: string;
    contextData?: {
        [key: string]: string;
    };
};

export type Error = {
    type?: string;
    title?: string;
    status?: number;
    detail?: string;
};

export type SystemHealth = {
    status?: 'ok' | 'degraded' | 'error';
    receiver?: ComponentStatus;
    epg?: EpgStatus;
    version?: string;
    uptime_seconds?: number;
};

export type ComponentStatus = {
    status?: 'ok' | 'error';
    last_check?: string;
};

export type EpgStatus = {
    status?: 'ok' | 'missing';
    missing_channels?: number;
};

export type OpenWebIfConfig = {
    baseUrl?: string;
    username?: string;
    password?: string;
    streamPort?: number;
};

export type EpgConfig = {
    enabled?: boolean;
    days?: number;
    source?: 'bouquet' | 'per-service';
};

export type PiconsConfig = {
    baseUrl?: string;
};

export type FeatureFlags = {
    instantTune?: boolean;
};

export type SeriesRuleRunReport = {
    ruleId?: string;
    runId?: string;
    trigger?: string;
    startedAt?: string;
    finishedAt?: string;
    durationMs?: number;
    windowFrom?: number;
    windowTo?: number;
    status?: 'success' | 'partial' | 'failed';
    summary?: RunSummary;
    snapshot?: RuleSnapshot;
    decisions?: Array<RunDecision>;
    errors?: Array<RunError>;
    conflicts?: Array<RunConflict>;
};

export type RunSummary = {
    epgItemsScanned?: number;
    epgItemsMatched?: number;
    timersAttempted?: number;
    timersCreated?: number;
    timersSkipped?: number;
    timersConflicted?: number;
    timersErrored?: number;
    maxTimersGlobalPerRunHit?: boolean;
    maxMatchesScannedPerRuleHit?: boolean;
    receiverUnreachable?: boolean;
};

export type RunDecision = {
    serviceRef?: string;
    begin?: number;
    end?: number;
    title?: string;
    action?: string;
    reason?: string;
    matchReason?: Array<string>;
    timerId?: string;
    details?: string;
};

export type RunError = {
    type?: string;
    message?: string;
    at?: string;
    retryable?: boolean;
};

export type RunConflict = {
    serviceRef?: string;
    begin?: number;
    end?: number;
    title?: string;
    blockingTimerId?: string;
    overlapSeconds?: number;
    message?: string;
};

export type RuleSnapshot = {
    id?: string;
    enabled?: boolean;
    keyword?: string;
    channelRef?: string;
    days?: Array<number>;
    startWindow?: string;
    priority?: number;
};

export type SeriesRule = {
    readonly id?: string;
    enabled?: boolean;
    /**
     * Search term or regex for event title
     */
    keyword?: string;
    /**
     * Optional service reference to restrict rule
     */
    channel_ref?: string;
    /**
     * Days of week (0=Sunday)
     */
    days?: Array<number>;
    /**
     * Time window HHMM-HHMM
     */
    start_window?: string;
    priority?: number;
    lastRunAt?: string;
    lastRunStatus?: string;
    lastRunSummary?: RunSummary;
};

export type SeriesRuleUpdate = {
    enabled: boolean;
    /**
     * Search term or regex for event title
     */
    keyword: string;
    /**
     * Optional service reference to restrict rule
     */
    channel_ref?: string;
    /**
     * Days of week (0=Sunday)
     */
    days?: Array<number>;
    /**
     * Time window HHMM-HHMM
     */
    start_window?: string;
    priority: number;
};

export type ConfigUpdate = {
    openWebIF?: OpenWebIfConfig;
    bouquets?: Array<string>;
    epg?: EpgConfig;
    picons?: PiconsConfig;
    featureFlags?: FeatureFlags;
};

export type AppConfig = {
    version?: string;
    dataDir?: string;
    logLevel?: string;
    openWebIF?: OpenWebIfConfig;
    bouquets?: Array<string>;
    epg?: EpgConfig;
    picons?: PiconsConfig;
    featureFlags?: FeatureFlags;
};

export type Bouquet = {
    name?: string;
    services?: number;
};

export type Service = {
    id?: string;
    name?: string;
    group?: string;
    logo_url?: string;
    number?: string;
    enabled?: boolean;
    /**
     * Service reference for streaming (extracted from M3U URL)
     */
    service_ref?: string;
};

export type NowNextRequest = {
    services: Array<string>;
};

export type NowNextEntry = {
    title: string;
    /**
     * Unix timestamp (seconds)
     */
    start: number;
    /**
     * Unix timestamp (seconds)
     */
    end: number;
};

export type NowNextItem = {
    service_ref: string;
    now?: NowNextEntry;
    next?: NowNextEntry;
};

export type NowNextResponse = {
    items: Array<NowNextItem>;
};

export type ProblemDetails = {
    type: string;
    title: string;
    status: number;
    detail?: string;
    instance?: string;
    fields?: {
        [key: string]: unknown;
    };
    conflicts?: Array<TimerConflict>;
};

export type Timer = {
    timerId: string;
    serviceRef: string;
    begin: number;
    end: number;
    name: string;
    description?: string;
    serviceName?: string;
    state: 'scheduled' | 'recording' | 'completed' | 'disabled' | 'unknown';
    receiverState?: {
        [key: string]: unknown;
    };
    createdAt?: string;
    updatedAt?: string;
};

export type PlaybackInfo = {
    mode: 'hls' | 'direct_mp4';
    url: string;
    seekable?: boolean;
    reason?: string;
};

export type TimerCreateRequest = {
    serviceRef: string;
    begin: number;
    end: number;
    name: string;
    description?: string;
    enabled?: boolean;
    justPlay?: boolean;
    afterEvent?: 'default' | 'standby' | 'deepstandby' | 'nothing';
    paddingBeforeSec?: number;
    paddingAfterSec?: number;
    idempotencyKey?: string;
};

export type TimerPatchRequest = {
    begin?: number;
    end?: number;
    name?: string;
    description?: string;
    enabled?: boolean;
    paddingBeforeSec?: number;
    paddingAfterSec?: number;
};

export type TimerConflict = {
    type: 'overlap' | 'duplicate' | 'tuner_limit' | 'unknown';
    blockingTimer: Timer;
    overlapSeconds?: number;
    message?: string;
};

export type TimerConflictPreviewRequest = {
    proposed: TimerCreateRequest;
    mode?: 'conservative' | 'receiverAware';
};

export type TimerConflictPreviewResponse = {
    canSchedule: boolean;
    conflicts: Array<TimerConflict>;
    suggestions?: Array<{
        kind?: 'reduce_padding' | 'shift_start' | 'shift_end';
        proposedBegin?: number;
        proposedEnd?: number;
        note?: string;
    }>;
};

export type DvrCapabilities = {
    timers: {
        edit?: boolean;
        delete?: boolean;
        readBackVerify?: boolean;
    };
    conflicts: {
        preview?: boolean;
        receiverAware?: boolean;
    };
    series: {
        supported?: boolean;
        mode?: 'none' | 'delegated' | 'managed';
        delegatedProvider?: string;
    };
};

export type RecordingStatus = {
    isRecording: boolean;
    serviceName?: string;
};

export type RecordingBuildStatus = {
    state: 'IDLE' | 'RUNNING' | 'FAILED' | 'READY';
    segment_count?: number;
    last_progress?: string;
    started_at?: string;
    attempt_mode?: 'fast' | 'robust';
    error?: string;
    /**
     * True if a progressive (timeshift) playlist is playable.
     */
    progressive_ready?: boolean;
};

export type TimerList = {
    items: Array<Timer>;
};

export type LogEntry = {
    time?: string;
    level?: string;
    message?: string;
    fields?: {
        [key: string]: unknown;
    };
};

export type StreamSession = {
    id?: string;
    client_ip?: string;
    channel_name?: string;
    started_at?: string;
    state?: 'active' | 'idle';
};

export type RecordingRoot = {
    id?: string;
    name?: string;
};

export type Breadcrumb = {
    name?: string;
    path?: string;
};

export type DirectoryItem = {
    name?: string;
    path?: string;
};

export type RecordingItem = {
    /**
     * Legacy receiver service reference (read-only).
     */
    service_ref?: string;
    /**
     * Base64url-encoded recording ID (RFC 4648, unpadded) to use for /recordings/{recordingId}.
     */
    recording_id?: string;
    title?: string;
    description?: string;
    /**
     * Recording start time as UNIX seconds.
     */
    begin_unix_seconds?: number;
    /**
     * Recording duration in seconds, if known.
     */
    duration_seconds?: number;
    /**
     * Human-readable duration string for display only.
     */
    length?: string;
    filename?: string;
};

export type RecordingResponse = {
    roots?: Array<RecordingRoot>;
    current_root?: string;
    current_path?: string;
    breadcrumbs?: Array<Breadcrumb>;
    directories?: Array<DirectoryItem>;
    recordings?: Array<RecordingItem>;
};

export type SeriesRuleWritable = {
    enabled?: boolean;
    /**
     * Search term or regex for event title
     */
    keyword?: string;
    /**
     * Optional service reference to restrict rule
     */
    channel_ref?: string;
    /**
     * Days of week (0=Sunday)
     */
    days?: Array<number>;
    /**
     * Time window HHMM-HHMM
     */
    start_window?: string;
    priority?: number;
    lastRunAt?: string;
    lastRunStatus?: string;
    lastRunSummary?: RunSummary;
};

export type GetSystemHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/health';
};

export type GetSystemHealthResponses = {
    /**
     * Health status
     */
    200: SystemHealth;
};

export type GetSystemHealthResponse = GetSystemHealthResponses[keyof GetSystemHealthResponses];

export type GetSystemHealthzData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/healthz';
};

export type GetSystemHealthzResponses = {
    /**
     * Health status
     */
    200: {
        status: 'ok';
    };
};

export type GetSystemHealthzResponse = GetSystemHealthzResponses[keyof GetSystemHealthzResponses];

export type GetSystemConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/config';
};

export type GetSystemConfigResponses = {
    /**
     * Configuration
     */
    200: AppConfig;
};

export type GetSystemConfigResponse = GetSystemConfigResponses[keyof GetSystemConfigResponses];

export type PutSystemConfigData = {
    body: ConfigUpdate;
    path?: never;
    query?: never;
    url: '/system/config';
};

export type PutSystemConfigErrors = {
    /**
     * Invalid configuration
     */
    400: unknown;
    /**
     * Failed to save configuration
     */
    500: unknown;
};

export type PutSystemConfigResponses = {
    /**
     * Configuration updated
     */
    200: {
        restart_required?: boolean;
    };
};

export type PutSystemConfigResponse = PutSystemConfigResponses[keyof PutSystemConfigResponses];

export type PostSystemRefreshData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/system/refresh';
};

export type PostSystemRefreshErrors = {
    /**
     * Refresh already in progress
     */
    409: unknown;
};

export type PostSystemRefreshResponses = {
    /**
     * Refresh started
     */
    202: unknown;
};

export type GetServicesBouquetsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/services/bouquets';
};

export type GetServicesBouquetsResponses = {
    /**
     * List of bouquets
     */
    200: Array<Bouquet>;
};

export type GetServicesBouquetsResponse = GetServicesBouquetsResponses[keyof GetServicesBouquetsResponses];

export type PostServicesNowNextData = {
    body: NowNextRequest;
    path?: never;
    query?: never;
    url: '/services/now-next';
};

export type PostServicesNowNextErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type PostServicesNowNextResponses = {
    /**
     * Now/next EPG entries per service
     */
    200: NowNextResponse;
};

export type PostServicesNowNextResponse = PostServicesNowNextResponses[keyof PostServicesNowNextResponses];

export type GetEpgData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Start timestamp (unix seconds)
         */
        from?: number;
        /**
         * End timestamp (unix seconds)
         */
        to?: number;
        /**
         * Filter by bouquet name
         */
        bouquet?: string;
        /**
         * Filter by search query
         */
        q?: string;
    };
    url: '/epg';
};

export type GetEpgResponses = {
    /**
     * EPG data
     */
    200: {
        items?: Array<{
            service_ref?: string;
            title?: string;
            desc?: string;
            start?: number;
            end?: number;
        }>;
    };
};

export type GetEpgResponse = GetEpgResponses[keyof GetEpgResponses];

export type GetServicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by bouquet name
         */
        bouquet?: string;
    };
    url: '/services';
};

export type GetServicesResponses = {
    /**
     * List of services
     */
    200: Array<Service>;
};

export type GetServicesResponse = GetServicesResponses[keyof GetServicesResponses];

export type PostServicesByIdToggleData = {
    body: {
        enabled?: boolean;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/services/{id}/toggle';
};

export type PostServicesByIdToggleErrors = {
    /**
     * Service not found
     */
    404: unknown;
};

export type PostServicesByIdToggleResponses = {
    /**
     * Status updated
     */
    200: unknown;
};

export type GetStreamsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/streams';
};

export type GetStreamsResponses = {
    /**
     * Active sessions
     */
    200: Array<StreamSession>;
};

export type GetStreamsResponse = GetStreamsResponses[keyof GetStreamsResponses];

export type GetRecordingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Root location ID
         */
        root?: string;
        /**
         * Relative path
         */
        path?: string;
    };
    url: '/recordings';
};

export type GetRecordingsResponses = {
    /**
     * Recordings list
     */
    200: RecordingResponse;
};

export type GetRecordingsResponse = GetRecordingsResponses[keyof GetRecordingsResponses];

export type DeleteRecordingData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recording_id
         */
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}';
};

export type DeleteRecordingErrors = {
    /**
     * Invalid recording reference
     */
    400: unknown;
    /**
     * Access denied
     */
    403: unknown;
    /**
     * Recording not found
     */
    404: unknown;
    /**
     * Failed to delete recording
     */
    500: unknown;
};

export type DeleteRecordingResponses = {
    /**
     * Recording deleted
     */
    204: void;
};

export type DeleteRecordingResponse = DeleteRecordingResponses[keyof DeleteRecordingResponses];

export type GetRecordingsByRecordingIdStatusData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/status';
};

export type GetRecordingsByRecordingIdStatusErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
};

export type GetRecordingsByRecordingIdStatusError = GetRecordingsByRecordingIdStatusErrors[keyof GetRecordingsByRecordingIdStatusErrors];

export type GetRecordingsByRecordingIdStatusResponses = {
    /**
     * Build status
     */
    200: RecordingBuildStatus;
};

export type GetRecordingsByRecordingIdStatusResponse = GetRecordingsByRecordingIdStatusResponses[keyof GetRecordingsByRecordingIdStatusResponses];

export type GetRecordingPlaybackInfoData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/playback';
};

export type GetRecordingPlaybackInfoErrors = {
    /**
     * Recording not found
     */
    404: ApiError;
};

export type GetRecordingPlaybackInfoError = GetRecordingPlaybackInfoErrors[keyof GetRecordingPlaybackInfoErrors];

export type GetRecordingPlaybackInfoResponses = {
    /**
     * Playback strategy info
     */
    200: PlaybackInfo;
};

export type GetRecordingPlaybackInfoResponse = GetRecordingPlaybackInfoResponses[keyof GetRecordingPlaybackInfoResponses];

export type StreamRecordingDirectData = {
    body?: never;
    path: {
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/stream.mp4';
};

export type StreamRecordingDirectErrors = {
    /**
     * Recording not found
     */
    404: unknown;
};

export type StreamRecordingDirectResponses = {
    /**
     * Video stream
     */
    200: Blob | File;
};

export type StreamRecordingDirectResponse = StreamRecordingDirectResponses[keyof StreamRecordingDirectResponses];

export type GetRecordingHlsPlaylistData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recording_id
         */
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/playlist.m3u8';
};

export type GetRecordingHlsPlaylistErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Recording not ready for VOD
     */
    503: ApiError;
};

export type GetRecordingHlsPlaylistError = GetRecordingHlsPlaylistErrors[keyof GetRecordingHlsPlaylistErrors];

export type GetRecordingHlsPlaylistResponses = {
    /**
     * HLS Playlist
     */
    200: string;
};

export type GetRecordingHlsPlaylistResponse = GetRecordingHlsPlaylistResponses[keyof GetRecordingHlsPlaylistResponses];

export type GetRecordingHlsTimeshiftData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recording_id
         */
        recordingId: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/timeshift.m3u8';
};

export type GetRecordingHlsTimeshiftErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Recording not ready for timeshift
     */
    503: ApiError;
};

export type GetRecordingHlsTimeshiftError = GetRecordingHlsTimeshiftErrors[keyof GetRecordingHlsTimeshiftErrors];

export type GetRecordingHlsTimeshiftResponses = {
    /**
     * HLS Playlist
     */
    200: string;
};

export type GetRecordingHlsTimeshiftResponse = GetRecordingHlsTimeshiftResponses[keyof GetRecordingHlsTimeshiftResponses];

export type GetRecordingHlsCustomSegmentData = {
    body?: never;
    path: {
        /**
         * Base64url-encoded recording ID (RFC 4648, unpadded) from RecordingItem.recording_id
         */
        recordingId: string;
        segment: string;
    };
    query?: never;
    url: '/recordings/{recordingId}/{segment}';
};

export type GetRecordingHlsCustomSegmentErrors = {
    /**
     * Invalid recording ID
     */
    400: ApiError;
    /**
     * Recording not found
     */
    404: ApiError;
    /**
     * Recording not ready
     */
    409: ApiError;
};

export type GetRecordingHlsCustomSegmentError = GetRecordingHlsCustomSegmentErrors[keyof GetRecordingHlsCustomSegmentErrors];

export type GetRecordingHlsCustomSegmentResponses = {
    /**
     * Media Segment
     */
    200: Blob | File;
};

export type GetRecordingHlsCustomSegmentResponse = GetRecordingHlsCustomSegmentResponses[keyof GetRecordingHlsCustomSegmentResponses];

export type CreateSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/session';
};

export type CreateSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateSessionResponses = {
    /**
     * Session created
     */
    204: void;
};

export type CreateSessionResponse = CreateSessionResponses[keyof CreateSessionResponses];

export type GetTimersData = {
    body?: never;
    path?: never;
    query?: {
        state?: string;
        from?: number;
    };
    url: '/timers';
};

export type GetTimersResponses = {
    /**
     * List of timers
     */
    200: TimerList;
};

export type GetTimersResponse = GetTimersResponses[keyof GetTimersResponses];

export type AddTimerData = {
    body: TimerCreateRequest;
    path?: never;
    query?: never;
    url: '/timers';
};

export type AddTimerErrors = {
    /**
     * Duplicate timer
     */
    409: ProblemDetails;
    /**
     * Conflict or validation error
     */
    422: ProblemDetails;
    /**
     * Receiver inconsistent (verification failed)
     */
    502: ProblemDetails;
};

export type AddTimerError = AddTimerErrors[keyof AddTimerErrors];

export type AddTimerResponses = {
    /**
     * Timer created
     */
    201: Timer;
};

export type AddTimerResponse = AddTimerResponses[keyof AddTimerResponses];

export type DeleteTimerData = {
    body?: never;
    path: {
        timerId: string;
    };
    query?: never;
    url: '/timers/{timerId}';
};

export type DeleteTimerErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type DeleteTimerResponses = {
    /**
     * Deleted
     */
    204: void;
};

export type DeleteTimerResponse = DeleteTimerResponses[keyof DeleteTimerResponses];

export type GetTimerData = {
    body?: never;
    path: {
        timerId: string;
    };
    query?: never;
    url: '/timers/{timerId}';
};

export type GetTimerErrors = {
    /**
     * Timer not found
     */
    404: unknown;
};

export type GetTimerResponses = {
    /**
     * Timer details
     */
    200: Timer;
};

export type GetTimerResponse = GetTimerResponses[keyof GetTimerResponses];

export type UpdateTimerData = {
    body: TimerPatchRequest;
    path: {
        timerId: string;
    };
    query?: never;
    url: '/timers/{timerId}';
};

export type UpdateTimerErrors = {
    /**
     * Timer not found
     */
    404: unknown;
    /**
     * Duplicate resulting from edit
     */
    409: ProblemDetails;
    /**
     * Conflict
     */
    422: ProblemDetails;
    /**
     * Receiver fail / Rollback
     */
    502: unknown;
};

export type UpdateTimerError = UpdateTimerErrors[keyof UpdateTimerErrors];

export type UpdateTimerResponses = {
    /**
     * Timer updated
     */
    200: Timer;
};

export type UpdateTimerResponse = UpdateTimerResponses[keyof UpdateTimerResponses];

export type PreviewConflictsData = {
    body: TimerConflictPreviewRequest;
    path?: never;
    query?: never;
    url: '/timers/conflicts:preview';
};

export type PreviewConflictsResponses = {
    /**
     * Preview result
     */
    200: TimerConflictPreviewResponse;
};

export type PreviewConflictsResponse = PreviewConflictsResponses[keyof PreviewConflictsResponses];

export type GetDvrCapabilitiesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/dvr/capabilities';
};

export type GetDvrCapabilitiesResponses = {
    /**
     * Capabilities
     */
    200: DvrCapabilities;
};

export type GetDvrCapabilitiesResponse = GetDvrCapabilitiesResponses[keyof GetDvrCapabilitiesResponses];

export type GetDvrStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/dvr/status';
};

export type GetDvrStatusResponses = {
    /**
     * Recording status
     */
    200: RecordingStatus;
};

export type GetDvrStatusResponse = GetDvrStatusResponses[keyof GetDvrStatusResponses];

export type DeleteStreamsIdData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/streams/{id}';
};

export type DeleteStreamsIdErrors = {
    /**
     * Session not found
     */
    404: unknown;
};

export type DeleteStreamsIdResponses = {
    /**
     * Session terminated
     */
    204: void;
};

export type DeleteStreamsIdResponse = DeleteStreamsIdResponses[keyof DeleteStreamsIdResponses];

export type GetLogsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/logs';
};

export type GetLogsResponses = {
    /**
     * Recent log entries
     */
    200: Array<LogEntry>;
};

export type GetLogsResponse = GetLogsResponses[keyof GetLogsResponses];

export type GetSeriesRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/series-rules';
};

export type GetSeriesRulesResponses = {
    /**
     * List of rules
     */
    200: Array<SeriesRule>;
};

export type GetSeriesRulesResponse = GetSeriesRulesResponses[keyof GetSeriesRulesResponses];

export type CreateSeriesRuleData = {
    body: SeriesRuleWritable;
    path?: never;
    query?: never;
    url: '/series-rules';
};

export type CreateSeriesRuleResponses = {
    /**
     * Created
     */
    201: SeriesRule;
};

export type CreateSeriesRuleResponse = CreateSeriesRuleResponses[keyof CreateSeriesRuleResponses];

export type RunSeriesRuleData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        trigger?: string;
    };
    url: '/series-rules/{id}/run';
};

export type RunSeriesRuleErrors = {
    /**
     * Rule not found
     */
    404: unknown;
};

export type RunSeriesRuleResponses = {
    /**
     * Run report
     */
    200: SeriesRuleRunReport;
};

export type RunSeriesRuleResponse = RunSeriesRuleResponses[keyof RunSeriesRuleResponses];

export type RunAllSeriesRulesData = {
    body?: never;
    path?: never;
    query?: {
        trigger?: string;
    };
    url: '/series-rules/run';
};

export type RunAllSeriesRulesResponses = {
    /**
     * List of run reports
     */
    200: Array<SeriesRuleRunReport>;
};

export type RunAllSeriesRulesResponse = RunAllSeriesRulesResponses[keyof RunAllSeriesRulesResponses];

export type DeleteSeriesRuleData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/series-rules/{id}';
};

export type DeleteSeriesRuleErrors = {
    /**
     * Rule not found
     */
    404: unknown;
};

export type DeleteSeriesRuleResponses = {
    /**
     * Deleted
     */
    204: void;
};

export type DeleteSeriesRuleResponse = DeleteSeriesRuleResponses[keyof DeleteSeriesRuleResponses];

export type UpdateSeriesRuleData = {
    body: SeriesRuleUpdate;
    path: {
        id: string;
    };
    query?: never;
    url: '/series-rules/{id}';
};

export type UpdateSeriesRuleErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Rule not found
     */
    404: unknown;
};

export type UpdateSeriesRuleResponses = {
    /**
     * Updated
     */
    200: SeriesRule;
};

export type UpdateSeriesRuleResponse = UpdateSeriesRuleResponses[keyof UpdateSeriesRuleResponses];

export type CreateIntentData = {
    body: IntentRequest;
    path?: never;
    query?: never;
    url: '/intents';
};

export type CreateIntentErrors = {
    /**
     * Invalid request
     */
    400: ApiError;
    /**
     * Lease busy (capacity rejection; no session created)
     */
    409: ApiError;
    /**
     * V3 control plane unavailable
     */
    503: ApiError;
};

export type CreateIntentError = CreateIntentErrors[keyof CreateIntentErrors];

export type CreateIntentResponses = {
    /**
     * Intent accepted
     */
    202: {
        sessionId?: string;
        status?: 'accepted' | 'idempotent_replay';
        correlationId?: string;
    };
};

export type CreateIntentResponse = CreateIntentResponses[keyof CreateIntentResponses];

export type ListSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Pagination offset
         */
        offset?: number;
        /**
         * Pagination limit (max 1000)
         */
        limit?: number;
    };
    url: '/sessions';
};

export type ListSessionsErrors = {
    /**
     * V3 control plane unavailable
     */
    503: ApiError;
};

export type ListSessionsError = ListSessionsErrors[keyof ListSessionsErrors];

export type ListSessionsResponses = {
    /**
     * Sessions list with pagination metadata
     */
    200: {
        sessions?: Array<SessionRecord>;
        pagination?: {
            offset?: number;
            limit?: number;
            total?: number;
            count?: number;
        };
    };
};

export type ListSessionsResponse = ListSessionsResponses[keyof ListSessionsResponses];

export type GetSessionStateData = {
    body?: never;
    path: {
        sessionID: string;
    };
    query?: never;
    url: '/sessions/{sessionID}';
};

export type GetSessionStateErrors = {
    /**
     * Invalid session ID
     */
    400: ApiError;
    /**
     * Session not found
     */
    404: ApiError;
};

export type GetSessionStateError = GetSessionStateErrors[keyof GetSessionStateErrors];

export type GetSessionStateResponses = {
    /**
     * Session state
     */
    200: SessionResponse;
};

export type GetSessionStateResponse = GetSessionStateResponses[keyof GetSessionStateResponses];

export type ServeHlsData = {
    body?: never;
    path: {
        sessionID: string;
        filename: string;
    };
    query?: never;
    url: '/sessions/{sessionID}/hls/{filename}';
};

export type ServeHlsErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * File not found
     */
    404: unknown;
    /**
     * V3 control plane unavailable
     */
    503: unknown;
};

export type ServeHlsResponses = {
    /**
     * HLS content
     */
    200: string;
};

export type ServeHlsResponse = ServeHlsResponses[keyof ServeHlsResponses];
