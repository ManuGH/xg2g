# ADR-009.2: Hash Semantics (Decision Authority)

**Status:** Accepted
**Date:** 2026-01-23
**Parent:** [ADR-009.1](009.1-playback-decision-spec-patch.md)
**Triggers:** R3-3 Design Decision

## Decision

**Option A Adopted: InputHash is a semantic cache key.**

Semantically equivalent inputs MUST produce identical InputHash values.

## Normative Rules

### 1. Definition

```
InputHash = SHA256( CanonicalJSON( NormalizeInput(DecisionInput) ) )
```

Where `NormalizeInput` excludes `RequestID` from semantic consideration.

### 2. Equivalence Rule

For all inputs `x`:

```
InputHash(x) == InputHash(NormalizeInput(x))
```

### 3. RequestID Exclusion

`RequestID` is transport/trace metadata only. It MUST NOT affect InputHash.

### 4. Nil/False Equivalence

`SupportsRange: nil` is semantically identical to `SupportsRange: false`.
Both hash to the same value.

### 5. Nil/Empty Slice Equivalence

`nil` and `[]string{}` slices are semantically identical.
Both hash to `[]` in canonical representation.

### 6. Set Semantics for Capabilities

Capability lists (Containers, VideoCodecs, AudioCodecs) are **sets**:

- Order is irrelevant (sorted for canonicalization)
- Duplicates are irrelevant (deduplicated for canonicalization)

## Implementation

`ComputeHash()` must:

1. Apply `NormalizeInput()` semantics
2. Exclude `RequestID` from hash computation
3. Use `CanonicalJSON()` for byte representation

## Consequences

- **Caching**: Safe to cache decisions by InputHash
- **Dedup**: Identical hashes guarantee identical decisions
- **Debugging**: Hash is stable reference for incident correlation
- **Drift Detection**: Hash change implies semantic change
