name: Quality Checks (Race, Leaks, Benchmarks)

on:
  workflow_dispatch:
  schedule:
    - cron: "30 3 * * *" # Daily at 03:30 UTC
  push:
    branches: [main]
  pull_request:
    branches: [main]
    paths:
      - "**/*.go"
      - go.mod
      - go.sum
      - .github/workflows/quality-checks.yml

permissions:
  contents: read
  checks: write

concurrency:
  group: quality-${{ github.ref }}
  cancel-in-progress: true

jobs:
  race-detector:
    name: Race Detector
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Run tests with race detector
        run: |
          set -euo pipefail
          echo "## Race Detector Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Run with race detector and capture output (skip FFI packages)
          if go test -race -timeout=10m $(go list ./... | grep -v '/test$' | grep -v 'internal/daemon' | grep -v 'internal/transcoder' | grep -v 'internal/proxy') -v 2>&1 | tee /tmp/race-output.txt; then
            echo "✅ **No data races detected**" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "❌ **Data races detected!**" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            grep -A 20 "WARNING: DATA RACE" /tmp/race-output.txt | head -100 >> "$GITHUB_STEP_SUMMARY" || true
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Upload race detector output
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: race-detector-output
          path: /tmp/race-output.txt
          retention-days: 7

  memory-leak-detector:
    name: Memory Leak Detection
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Build with pprof
        run: |
          set -euo pipefail
          go build -race -o bin/xg2g-pprof ./cmd/daemon

      - name: Run memory leak tests
        env:
          XG2G_DATA: /tmp/xg2g-leak-test
          XG2G_OWI_BASE: http://127.0.0.1:18080
          XG2G_BOUQUET: Test
          XG2G_LISTEN: :18081
        run: |
          set -euo pipefail

          echo "## Memory Leak Detection" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Create test data directory
          mkdir -p "$XG2G_DATA"

          # Start daemon with pprof enabled
          GODEBUG=gctrace=1 ./bin/xg2g-pprof > /tmp/daemon-leak.log 2>&1 &
          DAEMON_PID=$!

          # Give it time to start
          sleep 3

          # Take initial heap snapshot
          curl -s http://127.0.0.1:18081/debug/pprof/heap > /tmp/heap-initial.pprof || true

          # Simulate load (multiple requests)
          for i in {1..100}; do
            curl -s http://127.0.0.1:18081/healthz >/dev/null 2>&1 || true
            curl -s http://127.0.0.1:18081/readyz >/dev/null 2>&1 || true
          done

          # Force GC
          curl -s http://127.0.0.1:18081/debug/pprof/heap?gc=1 > /tmp/heap-after-gc.pprof || true

          # Take final heap snapshot
          sleep 2
          curl -s http://127.0.0.1:18081/debug/pprof/heap > /tmp/heap-final.pprof || true

          # Stop daemon
          kill $DAEMON_PID || true
          wait $DAEMON_PID || true

          # Analyze heap profiles
          if [ -f /tmp/heap-final.pprof ]; then
            echo "### Heap Profile Summary" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            go tool pprof -top -lines=20 /tmp/heap-final.pprof 2>&1 | head -30 >> "$GITHUB_STEP_SUMMARY" || echo "Profile analysis failed" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          else
            echo "⚠️ Heap profiling not available (daemon may not have pprof enabled)" >> "$GITHUB_STEP_SUMMARY"
          fi

          # Check GC trace for suspicious patterns
          if grep -q "GC forced" /tmp/daemon-leak.log; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "✅ GC is running normally" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload memory profiles
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: memory-profiles
          path: |
            /tmp/*.pprof
            /tmp/daemon-leak.log
          retention-days: 7
          if-no-files-found: ignore

  benchmark-profiling:
    name: Benchmark & CPU Profiling
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Run benchmarks with profiling
        run: |
          set -euo pipefail

          echo "## Benchmark Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Run benchmarks with CPU and memory profiling
          if go test -bench=. -benchmem -cpuprofile=/tmp/cpu.pprof -memprofile=/tmp/mem.pprof \
             -benchtime=3s $(go list ./... | grep -v '/test$') 2>&1 | tee /tmp/benchmark-output.txt; then

            echo "### Performance Benchmarks" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
            grep "^Benchmark" /tmp/benchmark-output.txt | tail -20 >> "$GITHUB_STEP_SUMMARY" || echo "No benchmarks found" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"

            # Analyze CPU profile
            if [ -f /tmp/cpu.pprof ]; then
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "### CPU Profile Top Functions" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
              go tool pprof -top -lines=15 /tmp/cpu.pprof 2>&1 | head -25 >> "$GITHUB_STEP_SUMMARY" || true
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            fi

            # Analyze memory profile
            if [ -f /tmp/mem.pprof ]; then
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo "### Memory Allocation Hot Spots" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
              go tool pprof -top -lines=15 -alloc_space /tmp/mem.pprof 2>&1 | head -25 >> "$GITHUB_STEP_SUMMARY" || true
              echo '```' >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "⚠️ Some benchmarks may have failed" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload benchmark profiles
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: benchmark-profiles
          path: |
            /tmp/*.pprof
            /tmp/benchmark-output.txt
          retention-days: 14
          if-no-files-found: ignore

  goroutine-leak-detector:
    name: Goroutine Leak Detection
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Check for goroutine leaks
        run: |
          set -euo pipefail

          echo "## Goroutine Leak Detection" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Install leak detector (using uber-go/goleak)
          go get go.uber.org/goleak@latest || true

          # Run tests with leak detection
          # Note: This requires tests to use goleak.VerifyNone(t) or similar
          if go test -v $(go list ./... | grep -v '/test$') 2>&1 | tee /tmp/leak-output.txt; then

            # Check for leaked goroutines in output
            if grep -q "goroutine.*leaked" /tmp/leak-output.txt; then
              echo "❌ **Goroutine leaks detected!**" >> "$GITHUB_STEP_SUMMARY"
              echo "" >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
              grep -A 10 "leaked" /tmp/leak-output.txt | head -50 >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
              exit 1
            else
              echo "✅ **No goroutine leaks detected**" >> "$GITHUB_STEP_SUMMARY"
            fi
          fi

      - name: Upload leak detector output
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: goroutine-leak-output
          path: /tmp/leak-output.txt
          retention-days: 7
          if-no-files-found: ignore

  test-coverage-quality:
    name: Test Coverage Quality
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version-file: go.mod
          cache: true

      - name: Generate detailed coverage
        run: |
          set -euo pipefail

          # Run tests with coverage
          go test -coverprofile=coverage.out -covermode=atomic $(go list ./... | grep -v '/test$')

          # Generate coverage report
          go tool cover -func=coverage.out > /tmp/coverage-detailed.txt

          # Generate HTML coverage
          go tool cover -html=coverage.out -o /tmp/coverage.html

      - name: Analyze coverage quality
        run: |
          set -euo pipefail

          echo "## Test Coverage Analysis" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Total coverage
          TOTAL_COV=$(go tool cover -func=coverage.out | awk '/total:/ {print $3}')
          echo "**Total Coverage:** $TOTAL_COV" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Low coverage packages (< 50%)
          echo "### Packages needing attention (< 50% coverage):" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          awk '/\.go:/ {
            pkg=$1;
            cov=$3;
            gsub(/%/, "", cov);
            if (cov+0 < 50 && cov+0 > 0) print pkg " - " $3
          }' /tmp/coverage-detailed.txt | sort -t'-' -k2 -n | head -20 >> "$GITHUB_STEP_SUMMARY" || echo "All packages have >= 50% coverage!" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

          # High coverage packages (>= 80%)
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "### Well-tested packages (>= 80% coverage):" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          awk '/\.go:/ {
            pkg=$1;
            cov=$3;
            gsub(/%/, "", cov);
            if (cov+0 >= 80) print pkg " - " $3
          }' /tmp/coverage-detailed.txt | sort -t'-' -k2 -nr | head -15 >> "$GITHUB_STEP_SUMMARY" || true
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: coverage-reports
          path: |
            coverage.out
            /tmp/coverage-detailed.txt
            /tmp/coverage.html
          retention-days: 14
