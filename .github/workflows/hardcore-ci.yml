name: Hardcore CI/CD Pipeline

on:
  push:
    branches: [main, "release/*"]
  pull_request:
    branches: [main, "release/*"]
  workflow_dispatch:

env:
  GO_VERSION: "1.25.x"
  COVERAGE_THRESHOLD: 65
  EPG_COVERAGE_THRESHOLD: 60

jobs:
  # Static Analysis & Security
  static-analysis:
    name: Static Analysis & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Clean Go module cache
        run: |
          go clean -modcache
          rm -rf ~/.cache/go-build || true
          mkdir -p ~/.cache/go-build

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Run go vet
        run: go vet ./...

      - name: Install golangci-lint
        run: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

      - name: Run golangci-lint
        run: golangci-lint run --timeout=5m

      - name: gofmt check
        run: |
          set -euo pipefail
          files=$(git ls-files '*.go' || true)
          if [ -z "${files}" ]; then
            echo "No Go files to format-check."
            exit 0
          fi
          bad=$(gofmt -l ${files})
          if [ -n "${bad}" ]; then
            echo "Files need gofmt:"; echo "${bad}"; exit 1; fi

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Run govulncheck
        run: govulncheck ./...

  # Tests with Race Detection
  test-race:
    name: Test with Race Detection
    runs-on: ubuntu-latest
    env:
      CGO_ENABLED: "1"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build essentials
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential gcc

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Clean Go module cache
        run: |
          go clean -modcache
          rm -rf ~/.cache/go-build || true
          mkdir -p ~/.cache/go-build

      - name: Run tests with race detection
        run: |
          echo "Running tests with race detection (CGO_ENABLED=1)..."
          go test ./... -race -count=1 -v

  # Coverage Analysis
  coverage:
    name: Coverage Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Clean Go module cache
        run: |
          go clean -modcache
          rm -rf ~/.cache/go-build || true
          mkdir -p ~/.cache/go-build

      - name: Generate coverage profile
        run: go test -tags=security ./... -covermode=atomic -coverprofile=coverage.out

      - name: Check overall coverage
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')
          echo "Overall coverage: ${COVERAGE}%"
          COVERAGE_INT=${COVERAGE%.*}
          if [ "${COVERAGE_INT}" -lt "${COVERAGE_THRESHOLD}" ]; then
            echo "‚ùå Coverage ${COVERAGE}% is below threshold ${COVERAGE_THRESHOLD}%"
            exit 1
          fi
          echo "‚úÖ Coverage ${COVERAGE}% meets threshold ${COVERAGE_THRESHOLD}%"

      - name: Check EPG module coverage
        run: |
          go test -covermode=atomic -coverprofile=epg_coverage.out ./internal/epg
          EPG_COVERAGE=$(go tool cover -func=epg_coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')
          echo "EPG module coverage: ${EPG_COVERAGE}%"
          EPG_COVERAGE_INT=$(printf "%.0f" "${EPG_COVERAGE}")
          EPG_THRESHOLD_INT=$(printf "%.0f" "${EPG_COVERAGE_THRESHOLD}")
          if [ "${EPG_COVERAGE_INT}" -lt "${EPG_THRESHOLD_INT}" ]; then
            echo "‚ùå EPG coverage ${EPG_COVERAGE}% is below threshold ${EPG_COVERAGE_THRESHOLD}%"
            exit 1
          fi
          echo "‚úÖ EPG coverage ${EPG_COVERAGE}% meets threshold ${EPG_COVERAGE_THRESHOLD}%"

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: coverage.out

  # Fuzzing
  fuzz-test:
    name: Fuzzing Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run fuzzing tests
        run: |
          set -e
          echo "Running fuzzing tests..."

          # Check if fuzz functions exist before running
          if go test ./internal/epg -list=FuzzLevenshtein >/dev/null 2>&1; then
            echo "Running FuzzLevenshtein..."
            go test ./internal/epg -fuzz=FuzzLevenshtein -fuzztime=10s -run '^$' -v
          else
            echo "‚ùå FuzzLevenshtein not found"
            exit 1
          fi

          if go test ./internal/epg -list=FuzzXMLTVGeneration >/dev/null 2>&1; then
            echo "Running FuzzXMLTVGeneration..."  
            go test ./internal/epg -fuzz=FuzzXMLTVGeneration -fuzztime=10s -run '^$' -v
          else
            echo "‚ùå FuzzXMLTVGeneration not found"
            exit 1
          fi

          if go test ./internal/epg -list=FuzzParseChannelName >/dev/null 2>&1; then
            echo "Running FuzzParseChannelName..."
            go test ./internal/epg -fuzz=FuzzParseChannelName -fuzztime=10s -run '^$' -v
          else
            echo "‚ùå FuzzParseChannelName not found"
            exit 1
          fi

          echo "‚úÖ All fuzz tests completed successfully"

  # Cross-platform Build Matrix
  build-matrix:
    name: Cross-Platform Build
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-2022]
        arch: [amd64]
        include:
          - os: ubuntu-latest
            goos: linux
          - os: macos-latest
            goos: darwin
          - os: windows-2022
            goos: windows
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build binary (Unix)
        if: matrix.goos != 'windows'
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.arch }}
          CGO_ENABLED: 0
          GOFLAGS: "-trimpath"
        run: |
          VERSION="${{ github.ref_name }}"
          if [ "$VERSION" = "main" ]; then
            VERSION="${{ github.sha }}"
          fi
          go build -ldflags "-s -w -X main.Version=${VERSION}" -o xg2g-${{ matrix.goos }}-${{ matrix.arch }} ./cmd/daemon

      - name: Build binary (Windows)
        if: matrix.goos == 'windows'
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.arch }}
          CGO_ENABLED: 0
          GOFLAGS: "-trimpath"
        shell: pwsh
        run: |
          $VERSION = "${{ github.ref_name }}"
          if ($VERSION -eq "main") {
            $VERSION = "${{ github.sha }}"
          }
          go build -ldflags "-s -w -X main.Version=$VERSION" -o xg2g-${{ matrix.goos }}-${{ matrix.arch }}.exe ./cmd/daemon

      - name: Test binary (Unix)
        if: matrix.goos != 'windows'
        run: |
          ./xg2g-${{ matrix.goos }}-${{ matrix.arch }} --version || echo "Version flag not implemented yet"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: xg2g-${{ matrix.goos }}-${{ matrix.arch }}
          path: xg2g-*

  # Container Security
  container-security:
    name: Container Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          format: table
          severity: CRITICAL,HIGH
          exit-code: "1"

  # SBOM Generation
  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOM
        run: |
          syft packages . -o spdx-json=sbom.spdx.json
          syft packages . -o cyclonedx-json=sbom.cyclonedx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: |
            sbom.spdx.json
            sbom.cyclonedx.json

  # Dependency Check
  dependency-check:
    name: Dependency Security Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Verify dependencies
        run: |
          go mod verify
          go mod tidy
          git diff --exit-code go.mod go.sum || (echo "‚ùå go.mod or go.sum is not tidy" && exit 1)

      - name: Check for known vulnerabilities in dependencies
        run: go list -json -deps ./... | jq -r '.Module.Path' | sort -u | head -20

  # Integration Smoke Test
  integration-smoke:
    name: Integration Smoke Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build daemon
        run: go build -o daemon ./cmd/daemon

      - name: Build OpenWebIF stub
        run: go build -o openwebif_stub ./test/stub_openwebif.go

      - name: Start OpenWebIF stub
        run: |
          ./openwebif_stub --port 18080 > /tmp/openwebif_stub.log 2>&1 &
          for i in {1..30}; do
            curl -fsS http://127.0.0.1:18080/api/status >/dev/null && break
            sleep 1
          done
          curl -fsS http://127.0.0.1:18080/api/status || (echo "=== STUB LOG ==="; cat /tmp/openwebif_stub.log; exit 1)

      - name: Run integration smoke test
        run: |
          echo "Running integration smoke test with real stub..."

          # Create temp data directory
          TEMP_DATA=$(mktemp -d)
          echo "Using data directory: $TEMP_DATA"

          # Start daemon with stub backend
          XG2G_DATA="$TEMP_DATA" \
          XG2G_OWI_BASE=http://127.0.0.1:18080 \
          XG2G_BOUQUET=Premium \
          XG2G_LISTEN=:8080 \
          XG2G_METRICS_LISTEN=:9090 \
          timeout 10 ./daemon > /tmp/daemon.log 2>&1 &
          DAEMON_PID=$!

          # Give daemon time to start  
          sleep 2

          # Check if daemon is still running 
          if ! kill -0 $DAEMON_PID 2>/dev/null; then
            echo "‚ùå Daemon exited prematurely"
            echo "Daemon log:"
            cat /tmp/daemon.log || true
            exit 1
          fi

          # Use fixed daemon port 8080
          DAEMON_PORT=8080
          echo "üîç Using fixed daemon port: $DAEMON_PORT"

          # Wait for daemon to fully start and bind port
          sleep 3

          # Debug: Show daemon process and ports
          echo "üìä Debug info:"
          ps aux | grep daemon | grep -v grep || echo "No daemon process found"
          ss -ltn | grep ':8080' || echo "Port 8080 not bound yet"

          # Verify daemon is listening on expected port (with brief retry)
          for i in $(seq 1 10); do
            if ss -ltn sport = :8080 | grep -q ':8080'; then
              break
            fi
            sleep 0.5
          done
          if ! ss -ltn sport = :8080 | grep -q ':8080'; then
            echo "‚ùå Daemon is not listening on port 8080"
            echo "üìã Daemon log contents:"
            cat /tmp/daemon.log || echo "No daemon log found"
            echo "üìã Network status:"
            ss -ltn || echo "No local listeners"
            echo "üìã Process info:"
            ps aux | grep daemon | grep -v grep || echo "No daemon process"
            kill $DAEMON_PID 2>/dev/null || true
            exit 1
          fi

          DAEMON_BASE="http://127.0.0.1:${DAEMON_PORT}"
          echo "üì° Daemon base: $DAEMON_BASE"

          # Test health endpoints
          echo "üè• Testing health endpoints..."
          if ! curl --fail --silent "$DAEMON_BASE/healthz" > /dev/null; then
            echo "‚ùå Health check failed"
            echo "Daemon log:"
            cat /tmp/daemon.log || true
            kill $DAEMON_PID || true
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Trigger refresh
          echo "üîÑ Triggering refresh operation..."
          if ! curl --fail --silent -X POST "$DAEMON_BASE/api/refresh" > /dev/null; then
            echo "‚ùå Refresh trigger failed"
            echo "Daemon log:"
            cat /tmp/daemon.log || true
            kill $DAEMON_PID || true
            exit 1
          fi
          echo "‚úÖ Refresh triggered successfully"

          # Give refresh time to complete
          sleep 3

          # Check generated files
          echo "üìã Checking generated artifacts..."

          # Check M3U file
          M3U_FILE="$TEMP_DATA/playlist.m3u"
          if [ -f "$M3U_FILE" ]; then
            M3U_SIZE=$(wc -c < "$M3U_FILE")
            M3U_ENTRIES=$(grep -c "^#EXTINF" "$M3U_FILE" 2>/dev/null || echo "0")
            echo "üì∫ M3U file: ${M3U_SIZE} bytes, ${M3U_ENTRIES} entries"
          else
            echo "‚ö†Ô∏è  No M3U file generated"
          fi

          # Check XMLTV file  
          XMLTV_FILE="$TEMP_DATA/xmltv.xml"
          if [ -f "$XMLTV_FILE" ]; then
            XMLTV_SIZE=$(wc -c < "$XMLTV_FILE")
            XMLTV_CHANNELS=$(grep -c "<channel " "$XMLTV_FILE" 2>/dev/null || echo "0")
            echo "üì° XMLTV file: ${XMLTV_SIZE} bytes, ${XMLTV_CHANNELS} channels"
          else
            echo "‚ö†Ô∏è  No XMLTV file generated"
          fi

          # Final status check
          echo "üìä Final status check..."
          FINAL_STATUS=$(curl --fail --silent "$DAEMON_BASE/api/status" || echo "FAILED")
          echo "Status response: $FINAL_STATUS"

          echo "‚úÖ Integration smoke test completed successfully"
          echo "üìã Summary:"
          echo "  - Coverage: $(go tool cover -func=coverage.out 2>/dev/null | grep total | awk '{print $3}' || echo 'N/A')"
          echo "  - Playlist entries (#EXTINF): ${M3U_ENTRIES:-0}"
          echo "  - XMLTV Channels: ${XMLTV_CHANNELS:-0}"
          echo "  - Daemon base: $DAEMON_BASE"

          # Cleanup
          kill $DAEMON_PID || true
          pkill -f stub_openwebif || true

  # Integration Gate
  integration-gate:
    name: Integration Gate
    needs:
      [
        static-analysis,
        test-race,
        coverage,
        build-matrix,
        container-security,
        dependency-check,
        integration-smoke,
      ]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check all jobs status
        run: |
          if [[ "${{ needs.static-analysis.result }}" != "success" ]]; then
            echo "‚ùå Static analysis failed"
            exit 1
          fi
          if [[ "${{ needs.test-race.result }}" != "success" ]]; then
            echo "‚ùå Race detection tests failed"
            exit 1
          fi
          if [[ "${{ needs.coverage.result }}" != "success" ]]; then
            echo "‚ùå Coverage check failed"
            exit 1
          fi
          if [[ "${{ needs.build-matrix.result }}" != "success" ]]; then
            echo "‚ùå Cross-platform build failed"
            exit 1
          fi
          if [[ "${{ needs.container-security.result }}" != "success" ]]; then
            echo "‚ùå Container security check failed"
            exit 1
          fi
          if [[ "${{ needs.dependency-check.result }}" != "success" ]]; then
            echo "‚ùå Dependency check failed"
            exit 1
          fi
          if [[ "${{ needs.integration-smoke.result }}" != "success" ]]; then
            echo "‚ùå Integration smoke test failed"
            exit 1
          fi
          echo "‚úÖ All quality gates passed - Ready for production!"
