name: Hardcore CI/CD Pipeline

on:
  push:
    branches: [main, "release/*"]
  pull_request:
    branches: [main, "release/*"]
  workflow_dispatch:

env:
  GO_VERSION: "1.22.x"
  COVERAGE_THRESHOLD: 65
  EPG_COVERAGE_THRESHOLD: 60

jobs:
  # Static Analysis & Security
  static-analysis:
    name: Static Analysis & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Run go vet
        run: go vet ./...

      - name: Install golangci-lint
        run: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

      - name: Run golangci-lint
        run: golangci-lint run --timeout=5m

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Run govulncheck
        run: govulncheck ./...

  # Tests with Race Detection
  test-race:
    name: Test with Race Detection
    runs-on: ubuntu-latest
    env:
      CGO_ENABLED: "1"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build essentials
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential gcc

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run tests with race detection
        run: |
          echo "Running tests with race detection (CGO_ENABLED=1)..."
          go test ./... -race -count=1 -v

  # Coverage Analysis
  coverage:
    name: Coverage Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Generate coverage profile
        run: go test ./... -covermode=atomic -coverprofile=coverage.out

      - name: Check overall coverage
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')
          echo "Overall coverage: ${COVERAGE}%"
          COVERAGE_INT=${COVERAGE%.*}
          if [ "${COVERAGE_INT}" -lt "${COVERAGE_THRESHOLD}" ]; then
            echo "‚ùå Coverage ${COVERAGE}% is below threshold ${COVERAGE_THRESHOLD}%"
            exit 1
          fi
          echo "‚úÖ Coverage ${COVERAGE}% meets threshold ${COVERAGE_THRESHOLD}%"

      - name: Check EPG module coverage
        run: |
          go test -covermode=atomic -coverprofile=epg_coverage.out ./internal/epg
          EPG_COVERAGE=$(go tool cover -func=epg_coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')
          echo "EPG module coverage: ${EPG_COVERAGE}%"
          EPG_COVERAGE_INT=$(printf "%.0f" "${EPG_COVERAGE}")
          EPG_THRESHOLD_INT=$(printf "%.0f" "${EPG_COVERAGE_THRESHOLD}")
          if [ "${EPG_COVERAGE_INT}" -lt "${EPG_THRESHOLD_INT}" ]; then
            echo "‚ùå EPG coverage ${EPG_COVERAGE}% is below threshold ${EPG_COVERAGE_THRESHOLD}%"
            exit 1
          fi
          echo "‚úÖ EPG coverage ${EPG_COVERAGE}% meets threshold ${EPG_COVERAGE_THRESHOLD}%"

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: coverage.out

  # Fuzzing
  fuzz-test:
    name: Fuzzing Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run fuzzing tests
        run: |
          set -e
          echo "Running fuzzing tests..."

          # Check if fuzz functions exist before running
          if go test ./internal/epg -list=FuzzLevenshtein >/dev/null 2>&1; then
            echo "Running FuzzLevenshtein..."
            go test ./internal/epg -fuzz=FuzzLevenshtein -fuzztime=10s -run '^$' -v
          else
            echo "‚ùå FuzzLevenshtein not found"
            exit 1
          fi

          if go test ./internal/epg -list=FuzzXMLTVGeneration >/dev/null 2>&1; then
            echo "Running FuzzXMLTVGeneration..."  
            go test ./internal/epg -fuzz=FuzzXMLTVGeneration -fuzztime=10s -run '^$' -v
          else
            echo "‚ùå FuzzXMLTVGeneration not found"
            exit 1
          fi

          if go test ./internal/epg -list=FuzzParseChannelName >/dev/null 2>&1; then
            echo "Running FuzzParseChannelName..."
            go test ./internal/epg -fuzz=FuzzParseChannelName -fuzztime=10s -run '^$' -v
          else
            echo "‚ùå FuzzParseChannelName not found"
            exit 1
          fi

          echo "‚úÖ All fuzz tests completed successfully"

  # Cross-platform Build Matrix
  build-matrix:
    name: Cross-Platform Build
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-2022]
        arch: [amd64]
        include:
          - os: ubuntu-latest
            goos: linux
          - os: macos-latest
            goos: darwin
          - os: windows-2022
            goos: windows
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build binary (Unix)
        if: matrix.goos != 'windows'
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.arch }}
          CGO_ENABLED: 0
          GOFLAGS: "-trimpath"
        run: |
          VERSION="${{ github.ref_name }}"
          if [ "$VERSION" = "main" ]; then
            VERSION="${{ github.sha }}"
          fi
          go build -ldflags "-s -w -X main.Version=${VERSION}" -o xg2g-${{ matrix.goos }}-${{ matrix.arch }} ./cmd/daemon

      - name: Build binary (Windows)
        if: matrix.goos == 'windows'
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.arch }}
          CGO_ENABLED: 0
          GOFLAGS: "-trimpath"
        shell: pwsh
        run: |
          $VERSION = "${{ github.ref_name }}"
          if ($VERSION -eq "main") {
            $VERSION = "${{ github.sha }}"
          }
          go build -ldflags "-s -w -X main.Version=$VERSION" -o xg2g-${{ matrix.goos }}-${{ matrix.arch }}.exe ./cmd/daemon

      - name: Test binary (Unix)
        if: matrix.goos != 'windows'
        run: |
          ./xg2g-${{ matrix.goos }}-${{ matrix.arch }} --version || echo "Version flag not implemented yet"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: xg2g-${{ matrix.goos }}-${{ matrix.arch }}
          path: xg2g-*

  # Container Security
  container-security:
    name: Container Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          format: table
          severity: CRITICAL,HIGH
          exit-code: "1"

  # SBOM Generation
  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOM
        run: |
          syft packages . -o spdx-json=sbom.spdx.json
          syft packages . -o cyclonedx-json=sbom.cyclonedx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: |
            sbom.spdx.json
            sbom.cyclonedx.json

  # Dependency Check
  dependency-check:
    name: Dependency Security Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Verify dependencies
        run: |
          go mod verify
          go mod tidy
          git diff --exit-code go.mod go.sum || (echo "‚ùå go.mod or go.sum is not tidy" && exit 1)

      - name: Check for known vulnerabilities in dependencies
        run: go list -json -deps ./... | jq -r '.Module.Path' | sort -u | head -20

  # Integration Smoke Test
  integration-smoke:
    name: Integration Smoke Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build daemon
        run: go build -o daemon ./cmd/daemon

      - name: Setup OpenWebIF stub server
        run: |
          echo "üöÄ Starting OpenWebIF stub server setup..."

          # Verify stub file exists 
          if [ ! -f "test/stub_openwebif.go" ]; then
            echo "‚ùå stub_openwebif.go not found!"
            ls -la test/
            exit 1
          fi
          echo "‚úÖ Found stub_openwebif.go in test/ directory"

          # Check if port 18080 is already in use
          if netstat -tuln | grep ':18080 '; then
            echo "‚ö†Ô∏è  Port 18080 is already in use:"
            netstat -tuln | grep ':18080 '
            echo "Attempting to kill any existing processes..."
            pkill -f 18080 || true
            sleep 2
          fi

          # Start stub server in project context (not /tmp)
          echo "üîß Starting stub server in project context..."
          echo "üìç Working directory: $(pwd)"
          echo "ÔøΩ Go version: $(go version)"
          
          # Start stub server from project directory to maintain module context
          nohup go run test/stub_openwebif.go > /tmp/stub_openwebif.log 2>&1 &
          STUB_PID=$!
          echo "üìù Stub PID: $STUB_PID"

          # Give process a moment to initialize
          sleep 1
          
          # Monitor stub startup with detailed logging
          echo "üîç Monitoring stub startup..."
          for attempt in {1..5}; do
            if kill -0 $STUB_PID 2>/dev/null; then
              echo "‚úÖ Stub process is running (attempt $attempt/5)"
              break
            else
              echo "‚ö†Ô∏è  Stub process check failed (attempt $attempt/5)"
              if [ $attempt -eq 5 ]; then
                echo "‚ùå Stub process died immediately after start"
                echo "üìã Stub log contents:"
                cat /tmp/stub_openwebif.log 2>/dev/null || echo "No log file found"
                echo "üìã Go module status:"
                go mod tidy -v 2>&1 || echo "Go module check failed"
                echo "üìã Test directory contents:"
                ls -la test/
                exit 1
              fi
              sleep 1
            fi
          done

          echo "üîç Process is running, checking server readiness..."

          # Wait for stub to be ready (up to 15 seconds with more detailed feedback)
          for i in {1..15}; do
            echo "‚è≥ Checking readiness (attempt $i/15)..."
            
            # Show current stub log for debugging
            if [ $i -eq 1 ] || [ $((i % 5)) -eq 0 ]; then
              echo "üìã Current stub log (last 10 lines):"
              tail -10 /tmp/stub_openwebif.log 2>/dev/null || echo "No log entries yet"
            fi
            
            # Try health check endpoint first
            if curl --fail --show-error --silent --max-time 1 "http://127.0.0.1:18080/api/status" > /dev/null 2>&1; then
              echo "‚úÖ Stub server is ready on port 18080!"
              curl --silent "http://127.0.0.1:18080/api/status" | jq '.' 2>/dev/null || echo "Health check successful"
              break
            fi
            
            # If we reach max attempts, show debug info
            if [ $i -eq 15 ]; then
              echo "‚ùå Stub server failed to become ready after 15 seconds"
              echo ""
              echo "üîç Debug information:"
              echo "üìã Stub log contents:"
              cat /tmp/stub_openwebif.log 2>/dev/null || echo "No log file found"
              echo ""
              echo "üîç Process status:"
              ps aux | grep -E "(stub_openwebif|18080)" | grep -v grep || echo "No stub processes found"
              echo ""
              echo "üîç Network status:"
              netstat -tuln | grep 18080 || echo "Port 18080 not bound"
              echo ""
              echo "üîç Go processes:"
              ps aux | grep go | grep -v grep || echo "No go processes found"
              echo ""
              kill $STUB_PID 2>/dev/null || true
              exit 1
            fi
            
            sleep 1
          done

      - name: Run integration smoke test
        run: |
          echo "Running integration smoke test with real stub..."

          # Create temp data directory
          TEMP_DATA=$(mktemp -d)
          echo "Using data directory: $TEMP_DATA"

          # Start daemon with stub backend
          XG2G_DATA="$TEMP_DATA" \
          XG2G_OWI_BASE=http://127.0.0.1:18080 \
          XG2G_BOUQUET=Premium \
          XG2G_LISTEN=:0 \
          XG2G_METRICS_LISTEN=:0 \
          timeout 10 ./daemon > /tmp/daemon.log 2>&1 &
          DAEMON_PID=$!

          # Give daemon time to start  
          sleep 2

          # Check if daemon is still running 
          if ! kill -0 $DAEMON_PID 2>/dev/null; then
            echo "‚ùå Daemon exited prematurely"
            echo "Daemon log:"
            cat /tmp/daemon.log || true
            exit 1
          fi

          # Find the actual daemon port
          echo "üîç Discovering daemon port..."

          # Wait a bit more for daemon to fully start and bind port
          sleep 3

          # Debug: Show daemon process and ports
          echo "üìä Debug info:"
          ps aux | grep daemon | grep -v grep || echo "No daemon process found"
          netstat -tuln | grep '127.0.0.1' || echo "No listening ports found"

          # Try multiple methods to find the daemon port
          DAEMON_PORT=""

          # Method 1: Parse daemon log for actual port
          if [ -f "/tmp/daemon.log" ]; then
            DAEMON_PORT=$(grep -o 'listen.*:[0-9]*' /tmp/daemon.log 2>/dev/null | grep -o '[0-9]*$' | head -1)
            echo "üìã Method 1 (log parsing): ${DAEMON_PORT:-'not found'}"
          fi

          # Method 2: Find non-18080 listening ports
          if [ -z "$DAEMON_PORT" ]; then
            DAEMON_PORT=$(netstat -tuln 2>/dev/null | grep '127.0.0.1:' | grep -v ':18080' | awk '{print $4}' | cut -d: -f2 | head -1)
            echo "üìã Method 2 (netstat): ${DAEMON_PORT:-'not found'}"
          fi

          # Method 3: Try common ephemeral ports
          if [ -z "$DAEMON_PORT" ]; then
            for port in 8080 8081 9000 9001 $(seq 32768 32778); do
              if curl --connect-timeout 1 --max-time 1 --silent "http://127.0.0.1:${port}/healthz" >/dev/null 2>&1; then
                DAEMON_PORT=$port
                echo "üìã Method 3 (port scan): found on $port"
                break
              fi
            done
          fi

          # If still no port found, try to read from daemon process info
          if [ -z "$DAEMON_PORT" ]; then
            echo "‚ùå Could not determine daemon port using any method"
            echo "üìã Daemon log contents:"
            cat /tmp/daemon.log || echo "No daemon log found"
            echo "üìã Network status:"
            netstat -tuln | grep '127.0.0.1' || echo "No local listeners"
            echo "üìã Process info:"
            ps aux | grep daemon | grep -v grep || echo "No daemon process"
            kill $DAEMON_PID 2>/dev/null || true
            exit 1
          fi

          DAEMON_BASE="http://127.0.0.1:${DAEMON_PORT}"
          echo "üì° Daemon base: $DAEMON_BASE"

          # Test health endpoints
          echo "üè• Testing health endpoints..."
          if ! curl --fail --silent "$DAEMON_BASE/healthz" > /dev/null; then
            echo "‚ùå Health check failed"
            echo "Daemon log:"
            cat /tmp/daemon.log || true
            kill $DAEMON_PID || true
            exit 1
          fi
          echo "‚úÖ Health check passed"

          # Trigger refresh
          echo "üîÑ Triggering refresh operation..."
          if ! curl --fail --silent -X POST "$DAEMON_BASE/api/refresh" > /dev/null; then
            echo "‚ùå Refresh trigger failed"
            echo "Daemon log:"
            cat /tmp/daemon.log || true
            kill $DAEMON_PID || true
            exit 1
          fi
          echo "‚úÖ Refresh triggered successfully"

          # Give refresh time to complete
          sleep 3

          # Check generated files
          echo "üìã Checking generated artifacts..."

          # Check M3U file
          M3U_FILE="$TEMP_DATA/playlist.m3u"
          if [ -f "$M3U_FILE" ]; then
            M3U_SIZE=$(wc -c < "$M3U_FILE")
            M3U_ENTRIES=$(grep -c "^#EXTINF" "$M3U_FILE" 2>/dev/null || echo "0")
            echo "üì∫ M3U file: ${M3U_SIZE} bytes, ${M3U_ENTRIES} entries"
          else
            echo "‚ö†Ô∏è  No M3U file generated"
          fi

          # Check XMLTV file  
          XMLTV_FILE="$TEMP_DATA/xmltv.xml"
          if [ -f "$XMLTV_FILE" ]; then
            XMLTV_SIZE=$(wc -c < "$XMLTV_FILE")
            XMLTV_CHANNELS=$(grep -c "<channel " "$XMLTV_FILE" 2>/dev/null || echo "0")
            echo "üì° XMLTV file: ${XMLTV_SIZE} bytes, ${XMLTV_CHANNELS} channels"
          else
            echo "‚ö†Ô∏è  No XMLTV file generated"
          fi

          # Final status check
          echo "üìä Final status check..."
          FINAL_STATUS=$(curl --fail --silent "$DAEMON_BASE/api/status" || echo "FAILED")
          echo "Status response: $FINAL_STATUS"

          echo "‚úÖ Integration smoke test completed successfully"
          echo "üìã Summary:"
          echo "  - Coverage: $(go tool cover -func=coverage.out 2>/dev/null | grep total | awk '{print $3}' || echo 'N/A')"
          echo "  - Playlist entries (#EXTINF): ${M3U_ENTRIES:-0}"
          echo "  - XMLTV Channels: ${XMLTV_CHANNELS:-0}"
          echo "  - Daemon base: $DAEMON_BASE"

          # Cleanup
          kill $DAEMON_PID || true
          pkill -f stub_openwebif || true

  # Integration Gate
  integration-gate:
    name: Integration Gate
    needs:
      [
        static-analysis,
        test-race,
        coverage,
        build-matrix,
        container-security,
        dependency-check,
        integration-smoke,
      ]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check all jobs status
        run: |
          if [[ "${{ needs.static-analysis.result }}" != "success" ]]; then
            echo "‚ùå Static analysis failed"
            exit 1
          fi
          if [[ "${{ needs.test-race.result }}" != "success" ]]; then
            echo "‚ùå Race detection tests failed"
            exit 1
          fi
          if [[ "${{ needs.coverage.result }}" != "success" ]]; then
            echo "‚ùå Coverage check failed"
            exit 1
          fi
          if [[ "${{ needs.build-matrix.result }}" != "success" ]]; then
            echo "‚ùå Cross-platform build failed"
            exit 1
          fi
          if [[ "${{ needs.container-security.result }}" != "success" ]]; then
            echo "‚ùå Container security check failed"
            exit 1
          fi
          if [[ "${{ needs.dependency-check.result }}" != "success" ]]; then
            echo "‚ùå Dependency check failed"
            exit 1
          fi
          if [[ "${{ needs.integration-smoke.result }}" != "success" ]]; then
            echo "‚ùå Integration smoke test failed"
            exit 1
          fi
          echo "‚úÖ All quality gates passed - Ready for production!"
